[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V28.00 P0 E1 W28.00 T1757511906 M28.00 I0 O0
# ----------------------------------------
# - REALISE PAR                 --> FS
# ---------------------------------------- config PP
# - TYPE PP                     --> FRAISAGE
# - NOMBRE d'AXES               --> 4
# - AXE                        	--> A ou B
# - TYPE DE LANGAGE             --> SIEMENS
#            VERSION            --> 840D/828D/840 et SL
# ---------------------------------------- client / infos machine
# - CLIENT                      -->
# - NON MACHINE                 -->
# - AXE ROTATIF(1)              --> A/B
# ----------------------------------------
#
# Variables d'ajustement des temps d'usinage
# 	- Valeurs fixes en secondes, après être remonté au point haut ***changement UNIQUEMENT***
#	correction de la valeur définie dans "l'armoire" 1 Seconde par défaut 
Temps_chang_outil 	: 5		# secondes en +- par outil
# A configurer par type d'opération 
#	- en utilisant un FACTEUR 1=1 1.1= * 1.1 le temps de ces types d'opérations
coefficient_G0		: 10	# Facteur de correction des rapides en --> accélération & décélération 
							# exprimé en 1/10 de secondes d'accélération/décélération par "G0"
							# obligatoirement > 0 --> 1 mini

#region possibilites_PP
# ---------------------------------------- infos complEmentaires / config PP
# - RESTRICTIONS D'UTILISATION	--> OUI - numéro de clé/en durée/version MC
# - ENTETEs
#                   ANCIENNE    --> OUI
#                   NOUVELLE    --> OUI
#         OP MC COMMENTAIRE     --> OUI
# - LECTURE INFOS ARMOIRE       --> OUI ou NON --> Suivant config choisie dans le PP
# - LECTURE INFOS MACHINE       --> OUI ou NON --> Suivant config choisie dans le PP
# - ORIGINES                    --> OUI
# - INSPECTION D'OUTIL          --> OUI
# - ARROSAGES VX                --> OUI
# - AVANCES EN VARIABLES        --> OUI
# - OUTILS EN VARIABLES         --> OUI
# - CYCLES PALPAGES             --> OUI / OPTIONNEL
# - SOUS-PROGRAMMES
#                       en Z    --> OUI
#                translation    --> OUI?
#                   Rotation    --> OUI?
#                     Miroir    --> OUI?
# - SUBSTITUTION D'AXES         --> OUI
# - NOM D'OUTILS                --> OUI
# - TEXTES AVANT/AVEC/APRES     --> OUI / NON a completer
# ---------------------------------------- infos complEmentaires
# - SIMULATION ISO              --> NON
# - PERCAGES AVANCé             --> OUI - ARROSAGES et ROTATIONS BROCHE
# - PERC. TRES PROFOND          --> OUI - M4,G1Z...,M3,M7...
# - PERCAGES "5 AXES" A ou B	--> OUI
#			TRANSITION SECU		--> OUI
# - MODIFICATION AUTO DU NOM    --> OUI    - F12345.H ou 12345-HERM.H ou F12345-HERM.H
# - OUVERTURE D'UN AUTRE EDITEUR--> OUI
# - AFFICHAGE DU TEMPS D'USINAGE
# 					PAR OUTIL 	--> OUI
#						TOTAL	--> OUI
#					TOTAL DLL	--> OUI
# - AJUSTEMENT DES TEMPS   		--> OUI	--> explications ci-dessous 
# - ARRET CONTROLE BRIS D'OUTIL --> OUI
# - CYCLE TEST BRIS D'OUTIL     --> OUI --> A VALIDER
# - OPTIMISATION AVANCES ARCS   --> NON/OUI MC
# - RENVOIE D'ANGLE				--> OUI
# - MORTAISAGE ANGULAIRE BROCHE --> OUI
# - ORIGINES EN ENTETE			--> OUI
# 						FICHIER	--> OUI
# - BLOCAGE-DEBLOCAGE axe A/B	--> OUI
# - GESTION DES PALETTES 		--> OUI 
# - Axes A/B en DEG/Mn			--> OUI
# - CYCLE D EBAVURAGE BROSSE	--> OUI
# - ORIGINE par TRANSFORMATION	--> OUI --> A DEVELOPPER
# - RENVOI D'ANGLE
#					FIXE MANUEL --> OUI
#				CIRCULAIRE AUTO --> OUI
# ---------------------------------------- INFOS
# mi1$ sans
# mi2$ utilisé pour FORCER le Z sécu de l'op si la config est remonter en Z HAUT 
# mi3$ utilisé pour "Val. angulaire index. broche (mortaisage)
# mi4$ 
# mi5$ utilisé pour "Bris outil 1=AXIAL-FORET 2=FRAISE 3=??
# mi6$ utilisé pour "Test_Bris_Out =1 (en FIN d OPERATION)
# mi7$ utilisé pour Ecrire M10 M11 (blocage/dEblocage du diviseur)
# mi8$
# mi9$ - CYCLE832 pour FORCER LE lissage 832 
#
# mr1$ 
# mr7$ FORCE LE Cycle832 à 3 valeurs--> Tol: mm		Type_lissage = 1
# mr8$ FORCE LE Cycle832 à 3 valeurs--> Tol: DEG	Type_lissage = 1
# mr9$ - CYCLE832 Valeurs Technologiques
#   0 = Off
#   1 = Ebauche 
#   2 = Demi-finition
#   3 = Finition
# mr10$ utilisé pour "Cycle lis832 VAL. INF. Fini.025 demi/f.1 EB. sup0.1 si >0
#
#*************
# ##mr9$ - CYCLE832 - remplacer et utiliser Surface Avancée ou activer/désactiver le lissage des Surfaces
#   Note: Ce commutateur n'est efficace que lorsque cycle832_format est 3 ou 4 pour Top Surface et que mi9$ est 1 pour utiliser les diverses valeurs. Quand mi9 est
#           0 pour utiliser les valeurs par défaut pour le CYCLE832, la publication remplacera cela et définira mr9 sur 2 pour la surface supérieure avec le lissage activé.
#   0 = Utiliser Surface avancée
#   1 = Utiliser Surface supérieure avec Smoothing Off
#   2 = Utiliser Surface supérieure avec Smoothing On
#
# ##mr10$ - CYCLE832 Tolerance (Used only when mi9 - "CYCLE832 from misc values?" is set to 1)
#   0 = use default tolerance defined in post
#   Non-zero = The tolerance that will be output on the CYCLE832 line
#
# Workofs (n°de Décalage) 
#	Siemens 840D/828D, 0=G54, 1=G55, 2=G56, 3=G57, 4=G507, 5=G508, ..., 96=G599
#	Siemens 808D, 0=G54, 1=G55, 2=G56, 3=G57, 4=G58, 5=G59.  
# ecriture des parametres dans NCI et du fichier OPS (pour lire les infos de surep)
#
# lecture de la def armoire pour :
#   l'extension de l'iso
#   les arcs /CONFIGURATION FORCEE dans le PP
#   les commentaires
#   la preparation de l'outil suivant
# Lecture de la def machine pour :
#   Le nom de la machine
#   Le nombre d'axes rotatif (1 seul supporté)
#   Le sens de rotation de l'axe rotatif
#
# Affichages (à activer): 
#	surepaisseurs OPs
#	type de compensations outils par OP 
#
# AJUSTEMENT DES TEMPS   		
# 	Acces au client aux variables pour ajuster 
#	suivant des types d'opérations uniquement
# ----------------------------------------
#endregion

# ----------------------------------------
erreur_type_arcs	= 1	# message d'alerte si les ARCS sont mal configurés dans la DEF. ARMOIRE

type_pp_SIEMENS 	= 1 # 1= 840D, 2= 840D SL, 3= 828D, 4= 810 ...

# ----- dEgagements au changement d'outil, rotations d'axes et inspection de plaquettes
type_deg    : 1     # 1 = G53  ..."D0"                  
					# 2 = G153 ..."D0"
					# 3 = SUPA ..."D0"
					# 4 = G75  ..."D0" 
					# 5 = G90 G500... #+ VARIABLES _X_HOME, _Y_HOME, _Z_HOME								
                    # 0 = G0 Z... ;  X... Y...    #VALEURS ABSOLU OPERATIONS MASTERCAM
					
s_fin_deg	: "D0"

S_macro_deg : "M130 ; RET. PT CHANG. OUTIL"        # NOM de la macro de dégagement si active
# configuration des dEgagements
# --------------------------------  0=SANS  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY  6=MACRO_CN 
deg_debut   		: 3             # Degagement au debut du prog
deg_outil   		= 3             # Degagement au changement d'outil
deg_4_axes  		= 0             # Degagement au changement de position en 4 axes ET RENVOI D'ANGLE
                                    	# 0 = VALEURS MC DE L'OPERATION
deg_fin             : 3             # Degagement en fin de programme
deg_inspection_plaq = 1             # Degagement l'outil lors de l'inspection de l'état de l'outil

deg_apres_outil     = 2          	# >0 = Affichage des dégagements EGALEMENT apres l'appel de l'outil "sécurité" lors du démarrage à X outil
                                    # type = idem au "deg_outil"
deg_palette_deb_fin = 4     		# dEgagements au debut et fin prog pour rotation des palettes 
										# s'il y a un élément génant pour la rotation, ex: bloc du 4ème axe 	         
# en 3 axes
# Exemple : "G0 G53 Z-1 D0"
degageX    = 0                     	# Valeur de degagement en X pour l'appel d'outil
degageY    = 0                     	# "    Y "
degageZ    = 0	                    # "    Z "

# FIN
degageX_fin = -1					# Valeur de degagement en X UNIQUEMENT EN FIN DE PROGRAMME 
degageY_fin = -1  					# "    Y "
degageZ_fin = -1 					# "    Z "

# en 4 axes    --> ENTRE 2 opérations        SI "deg_4_axes" = 0 valeur X/Y & Z = à la valeur SECURITE de l'opération MASTERCAM
# et TETE A RENVOI
degageX4   = 0                     	# Valeur de degagement en X avant rotation
degageY4   = 0                     	# "    Y "
degageZ4   = 0                    	# "    Z "

# dEgagements palettes 				# si palettes actives "dEgagements au debut et fin prog pour rotation des palettes 	
degageX_pal = 0 					# Valeur de degagement en X avant rotation
degageY_pal = 0  					# "    Y "
degageZ_pal = 0	 					# "    Z "

#     SI "deg_inspection_plaq " = 0 valeur X/Y & Z = à la valeur SECURITE de l'opération MASTERCAM
deg_insp_X = 0                     	# Valeur de degagement en X avant inspection de l'état de la plaquette
deg_insp_Y = 0                     	# "    Y "
deg_insp_Z = 0                     	# "    Z "

# ----------------------------------------------
Cycles_palpage_YN   = 0  	# activation ou pas de l'utilisation des cycles de palpages "BASICs" (en perCages)
change_nom          = 0     # 1 = nomination des programmes avec un préfix "PF" + "numARTICLE" + "INDICE" + "CODE_CN"  = PF15662-A-2-HE.H ////    0 = NOM DANS MC
F_variables        	= 0     # utiliser les avances F en variables R50=... R51=...
output_z    		= 0  	# Output Z Min and Z Max des parcours (1 ou 0)
program_stop        = 22    # Stop M00 ou M01
							# 1 = M00 AVANT le changement d'outil
							# 2 = M01 AVANT le changement d'outil
							# 11 = M00 APRES le changement d'outil
							# 22 = M01 APRES le changement d'outil
entete_questions    = 2     # 0 = pas d'entEte
                            # 1 = entEte suivant OP MC TEXTE
                            # 2 = Nouvelle entEte questions
                            # 3 = Ancienne entEte questions
affiche_ori_entete	= 1		# Affiche les origines du programme en entête
							# 0 = NON
							# 1 = APRES LA LISTE D'OUTILS
							# 11 = APRES LA LISTE D'OUTILS SI > 54
							# 2 = DANS UN FICHIER A PART
							# 22 = DANS UN FICHIER A PART si > 54
#Outils ----------------------------------------
Type_appel_outil    = 1     # 1 = NUMERO de l'outil                     	"T1...
                            # 2 = NOM de l'outil                         	"FRAISE D..."
                            # 3 = VARIABLE suivie du NUMERO de l'outil     	"R501=1 ; FR. CA. D=8.
							# 4 = Changement MANUEL --> M0 et type infos outil appelé

type_dec_outil		= 1		# 1 = Appel du correcteur toujours a 1 "Tx D1"
							# 2 = Appel du correcteur identique au NUMERO outil "Tx Dx"
							# 3 = Appel du correcteur toujours a 1 sauf si different de num outil	"T2 D1" ou "Tx Dy"
							
Type_infos_outil    = 1     # 1 = NOM de l'outil "texte NOM" --> strtool$
                            # 2 = Infos géométrique réelle de l'outil
                            # 3 = NOM MC de l'outil et Infos géométrique réelle de l'outil
                            # 4 = NOM de l'outil "texte NOM" & Infos géométrique réelle de l'outil --> = 1 + 2
							
Position_info_outil = 1     # 1 = Affichage AVANT l'appel de l'outil
                            #        Nxx T2 M6
                            # 2 = Affichage APRES l'appel de l'outil

utilise_palette		= 0		# Affiche la gestion des palettes, codes M début et fin pour rotations et degagements outils avant rotations
							# 1 = Fonctions M uniquement sans dEgagements spécifiques
							# 11 = Fonctions M ET dEgagements spécifiques

#prEparation de l'outil SUIVANT
bldnxtool$          = 1     # 0 = n'affiche pas la préparation de l'outil suivant
                            # 1 = affiche				
type_prep_outil     = 0     # 0 = Pas de prEparation du 1er outil
                            # 1 = PrEparation A chaque outil (ptlchg$)
                            # 2 = PrEparation A chaque outil et A LA FIN (peof)
# Déchargement de l'outil en broche
decharge_outil_fin  = 1     # 1 = affiche un "T0 M6" à la fin

# Fin de programme
fin_programme		= 1		# 1 = M30	2 = M02 	3 = M99

# RENVOI D'ANGLE
S_maxi_renvoi_angle = 2000	#
prepa_out_renvoi	= 0		# 1 = préparation de l'outil avec le renvoi d'angle		

lire_def_machine    = 1     # 1 = Lire les valeurs de la def machine / armoire --> AXES/ARCs/cycles ...
                            # 0 = suivant les données du PP

Systeme_rot_plans	: 0 	# SystEme de gestion des différentes valeurs lors d'une rotation
                                # 0  = pas de calculs --> origine gEnEralement **PAR FACE/G55/G56... ou **au centre de la palette
                                # 1  = calculs AUTO "G68" --> origine oU on veut
                                # 2X =	Calcul suivant une transition de l'origine CALCULé
									# 21 = utilise le sous-programme O8000 pour calculer automatiquement les origines pour chaque face
                                    	# utilise_O8000 --> G54 au dEbut et ensuite G55 calculE, Exemple : G54 G90 B122.; M98 P8000 ...
                                    	# Fichier contenant le O8000 à integrer dans la CN et valider
									# 22 = suivant un décalage d'origine G52/92 calculé
									# 23 = création du G54 depuis un G55 ou G59 avec les coordonnées de l'axe de rotation 
										# rotation en A info de Y et Z
										# rotation en B info de X et Z
                                # 3  = un origine par angle de rotation dEfini par l'opérateur --> G54,G55 ...
                                # 4  = FONCTION "M" en ABSOLU module de rotation à part "automate" (1 ORIGINE PAR ANGLE)
                                # 5  = FONCTION "M" en RELATIF **chaque M=90°** module de rotation à part "capteur automate" (1 ORIGINE PAR ANGLE)
	#
rot_AB_un_sens  	= 0			# sens AB 	0 = libre (en +/-) 	1 = SEULEMENT dans le sens + pour certaines CNs

Nom_porte_outil_entete 	= 3		# Affiche le nom du porte outil avec la liste des outils en entête, s'il y en a un
									# 1 = porte outil & longueur de sortie
									# 2 = assemblage & longueur de sortie
									# 3 = porte outil & assemblage & longueur de sortie

affiche_num_op_MC		= 2		# affiche le numéro de l'OP Masctercam extraite 
									# 1 = depuis la DLL
									# 2 = prmcode$

affiche_type_op_MC		= 1		# affiche le type de l'opération MC

groupe_descripteur	   	= 0		# Affiche en ENTETE 0 = NON
									# 1 Nom de la Machine
									# 2 Nom du groupe PRINCIPAL d'opErations
									# 3 Nom du groupe 1
									# 4 Descripteur de fichier A ACTIVER AVEC LE G1
									# 5 Les 4 									

nom_programmeur_PC 		= 0 	# Affiche le nom du programmeur
									# 1 = Nom du programmeur
									# 2 = Non de l'ORDI
									# 3 = Les deux
								
type_dec_4x_percage		= 0		# Type de gestion du perçage 4/5 axes
									# 0 perçage en absolu, classique
									# 1 perçage en relatif depuis le nouveau pt XYZ passé à 0	
																	
utilise_prog_reg_usi 	= 0		# Affiche la possibilité de bloquer les rapides "%" --> associé à un sous-prog
									# 1 = 	R99=1 ; 1= PIECE DE REGLAGE
										#; BLOCAGE DES G0 A 20 POUR CENT MAXI
										#R99==1 / (R99==1)
										#REDUCTION_GO ; APPEL DU SOUS-PROG.
										#ENDIF
										
type_cycle_percages		: 2		# type de cycles de percage
									# 1 = avec les variables 	--> MCALL CYCLE83(R101,R102, ...)
									# 2 = classique				--> MCALL CYCLE83(0,10, ...)
									
prof_cycle_Abs_Relatif	: 1		# 1 = Z en Absolu  --> DP
								# 2 = Z en Relatif --> DPR
																													
Type_lissage 			= 11    # CYCLE832 & MODE PRISMATIQUE // infos page 275 "manuel sinumerik 840.pdf"
								# 1 = CYCLE832 ON avec prise en compte de la TOLERANCE de l'opération MASTERCAM ....mr10$/OK
										# EBAUCHE tol >= 0.05 		_ROUGH
										# DEMI-FINITION tol < 0.05	_SEMIFIN
										# FINITION tol <= 0.025		_FINISH
									# Force le cycle832_format : 2
									# valeurs manuels mr7$ et mr8$ UNIQUEMENT avec ce type
								# 11 = CYCLE832 ON avec prise en compte du type d'OPERATION						....mr10$/OK
									# cycle832_format : 2/3/32/4 2D & 3D OK
								# 2 = CYCLE832 TOUJOURS sur OFF à chaque appel d'outil
									# OK
								# 3 = EMULATION du CYCLE832 MODE PRISMATIQUE  --> MACHINES SANS L'OPTION CYCLE 832
									#affichez une série de commandes qui émuleront le CYCLE832

# POUR Type_lissage 11 UNIQUEMENT
cycle832_format 		: 2 	# Sélectionnez le format de sortie pour le CYCLE832
								# 1 = CYCLE832, sortie numérique de la valeur technologique (0, 1, 2, 3)
								# 2 = CYCLE832, sortie de chaîne de valeur technologique (_OFF, _FINISH, _SEMIFIN, _ROUGH)								SINUMERIK --> SW 4.5
								# 3 = CYCLE832, sortie numérique de la valeur technologique (1000000, 1000001, 1000002, 1000003) "_TOLM"	 			SANS Smoothing	SINUMERIK --> SW 7.5
								# 32 = CYCLE832, sortie numérique de la valeur technologique (2000000, 2000001, 2000002, 2000003) "_TOLM" 				AVEC Smoothing
								# 4 = CYCLE832, sortie de chaîne de valeur technologique (_TOP_SURFACE_SMOOTH_OFF+_FINISH, _TOP_SURFACE_SMOOTH_ON+_FINISH, _TOP_SURFACE_SMOOTH_OFF+_ROUGH, etc.)

#NON UTILISE
cycle832_version 		: 1     #NON UTILISE	3ème paramètre sur la ligne de sortie CYCLE832. 0=jusqu'à la version 7.5 du logiciel Siemens, 1=à partir de la version 2.6 du logiciel HMI sl
#
									
affiche_chemin 			: 0     # activation/dEsactivation de l'affichage du prog. et sous-prog. avec le repertoire client
								# 1 = ;$PATH=/_N_WKS_DIR/_N_ .WPD
nom_repert 				: 0   	# 0 = ;$PATH=/_N_WKS_DIR/_N_0013_2_WPD (sans le rEpA¨rtoire client) 
								# 1 = ;$PATH=/_N_WKS_DIR/_N_SNECMA_0013_2_WPD et 

info_corr   			: 1     # afficher le type de correction
info_surep     			: 1  	# afficher les surepaisseurs
texte       			: 1     # afficher les commentaires
sous_prog_int_ext 		= 1   	# 1 =INTER 2 =EXTER   sous-programmes INTER ou EXTER
pas_taraud_egale_ISO 	: 0     # Affichage du pas suivant l'ISO du diam. du taraud (=1) ou du pas affectE au taraud =0

Affiche_temps_dll		: 0	# 1 = YES / 0 = NO							 
#string de reference	 654321								
s_Types_Temps_DLL 		"111111.00000000"	# configuration des différents affichages
					# OPTIMISES  
					# 	"100000.00000000" = Uniquement à la fin du programme 
					# 	"010000.00000000" = A chaque outil 
					# 	"001000.00000000" = A chaque Opération 
					# 	"110000.00000000" = 6+5
					# 	"111000.00000000" = 6+5+4
					# EN ENTETE --> NON optimisEs
					# 	"000100.00000000" = TOTAL 
					# 	"000010.00000000" = par OUTIL
					# 	"000001.00000000" = par OPERATION							
					
affiche_groupe 	: no$   	# 0/no$ = pas d'affichage des groupes d'usinage, 1/yes$ = affichage
outils_param 	: 0    		# pour Valider / dévalider l'affichage des outils en parametres
Liste_outils	: yes$  	# A préviligier pour activer la liste d'outils au "tooltable$" 
tooltable$  	: yes$      # creation liste outil en entete va dans pwrtt oui ou non
block_form     	: yes$  	# Sortie du 'WORKPIECE

convoyeur				= 1 #

compteur_pieces			= 1	#

# **** OPTIONS MACHINE ****
#string de reference   12-11-10-987654321								
s_Options_840D				"111111111111.0000"	# configuration des différents affichages							OPTION/		TYPE CN :810D	828D	840SL	840D
s_Options_840D_SL			"111111111111.0000"	# configuration des différents affichages							OPTION/		TYPE CN :810D	828D	840SL	840D
s_Options_828D				"111111111111.0000"	# configuration des différents affichages							OPTION/		TYPE CN :810D	828D	840SL	840D
s_Options_810D				"000111101001.0000"	# configuration des différents affichages							OPTION/		TYPE CN :810D	828D	840SL	840D
						#  
						# 	"100000000000.0000" = Activation du chronometre											CHRONO				:		:		:		:1
						# 	"010000000000.0000" = Activation du convoyeur											CONVO				:		:		:		:1
						# 	"001000000000.0000" = Activation de "la gestion de la pression de l'arrosage au centre 	$A_OUTA --> "M7"	:		:		:		:1
						# 	"000100000000.0000" = Activation de "l'anticipation"									FFWON				:1		:		:		:1
						# 	"000010000000.0000" = Activation de "gestion des accouts"								SOFT				:1		:		:		:1
						# 	"000001000000.0000" = Activation de "la coupe constante point de contact outil"			CFTCP				:1		:		:		:1
						# 	"000000100000.0000" = Activation de la "lecture des blocs A l'avance"					G642				:1		:		:		:1
						# 	"000000010000.0000" = Activation de la "compensation de dilatation"						M50					:?		:		:		:1
						# 	"000000001000.0000" = Activation du "compactage Type BSpline"							COMPCAD				:1		:		:		:1
						# 	"000000000100.0000" = Activation de la "Tolerance d'usinage"							TOL(0.035)			:?		:		:		:1
						# 	"000000000010.0000" = Activation du "Lissage acceleration de 25 A 150 pour 100"			JERK_ON(100)		:?		:		:		:1
						# 	"000000000001.0000" = Activation du groupe d'axes 										FGROUP				:1		:		:		:1

# QUESTIONS ENTETE ----------------------------------------------------
# Questions UNIQUEMENT des STRINGS NON VIDES !!
s_texte_question_1 : "CLIENT"
s_texte_question_2 : "DESIGNATION PIECE"
s_texte_question_3 : "NUMERO DU PLAN"
s_texte_question_4 : "INDICE DU PLAN"
s_texte_question_5 : "NUM. PHASE :"
s_texte_question_6 : "ORIGINE PIECE"
s_texte_question_7 : "X :"
s_texte_question_8 : "Y :"
s_texte_question_9 : "Z :"
s_texte_question_10 : "COMMENTAIRE :"
s_texte_question_11 : ""
s_texte_question_12 : ""
s_texte_question_13 : ""
s_texte_question_14 : ""
s_texte_question_15 : ""
s_texte_question_16 : "NOMBRE DE PIECES EN PALETTE A :" 	# ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M..."
s_texte_question_17 : "NOMBRE DE PIECES EN PALETTE B :"	# ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
s_texte_question_18 : "Numero de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"
s_texte_question_19 : ""	# exemple : "TOLERANCE CORDALE POUR DEVELOPPE"    #plus utilisé
s_texte_question_20 : "VEUILLEZ ENTRER UN NUMERO DE PROGRAMME"

# CODES M -------------------------------------------------------------

# Coolant output code selection for X style coolant
# Note: To enable X style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, disable first check box
#   Output of X style coolant commands in this post is controlled by pcan, pcan1, & pcan2
scool50    : "M8 ; BUSE ON"                		#Coolant 1 on value
scool51    : "M9"                				#Coolant 1 off value
scool52    : "M56 ; AIR ON"                		#Coolant 2 on value
scool53    : "M9"                 				#Coolant 2 off value
scool54    : "M7 ; ARROSAGE AU CENTRE ON"    	#Coolant 3 on value
scool55    : "M9"   							#Coolant 3 off value
scool56    : "M8(Coolant4=ON)"                  #Coolant 4 on value
scool57    : "M9"                               #Coolant 4 off value
scool58    : "M8(Coolant5=ON)"                  #Coolant 5 on value
scool59    : "M9"                               #Coolant 5 off value
scool60    : "M8(Coolant6=ON)"                  #Coolant 6 on value
scool61    : "M9"                               #Coolant 6 off value
scool62    : "M8(Coolant7=ON)"                  #Coolant 7 on value
scool63    : "M9(Coolant7=OFF)"                 #Coolant 7 off value
scool64    : "M8(Coolant8=ON)"                  #Coolant 8 on value
scool65    : "M9(Coolant8=OFF)"                 #Coolant 8 off value
scool66    : "M8(Coolant9=ON)"                  #Coolant 9 on value
scool67    : "M9(Coolant9=OFF)"                 #Coolant 9 off value
scool68    : "M8(Coolant10=ON)"                 #Coolant 10 on value
scool69    : "M9(Coolant10=OFF)"                #Coolant 10 off value
scoolantx : ""                                  #Target for string

fstrsel scool50 coolantx scoolantx 20 -1

#X coolant has the option - First coolant off command shuts off ALL coolant options
sall_cool_off  : "M09" #Coolant off command output with all_cool_off
# --------------------------------------------------------------------------
# Blocage déblocage 4ieme Axe -------------------------
sblo0 			: ""       	# pour pas de blocage ni deblocage
sblo1			: "M10"   	# blocage axe A
sblo2   		: "M11"   	# déblocage axe A
sblo3 			: ""       	# pour Frein axe A
sbloque 		: ""
fstrsel sblo0 bloque sbloque 4 -1
#-------------------------------------------------------
# Rotation broche
sm0_1          	: "M4"     
sm0_2          	: "M5"     
sm0_3          	: "M3"     
spdlon 			: ""
spdlsel = fsg3(ss$)  
fstrsel  sm0_1 spdlsel spdlon 3 -1
#-------------------------------------------------------
# GESTION DES TEXTES OPTIONNELS
s_texte_0    : ""
s_texte_1    : "M0"                     #N° 1
s_texte_2    : "M1"                     #N° 2
s_texte_3    : "; BLOC OPTIONNEL ON"
s_texte_4    : "; BLOC OPTIONNEL OFF"
s_texte_5    : "; REPRISE"
s_texte_6    : "; ZONE 1"
s_texte_7    : "; ZONE 2"
s_texte_8    : "; EBAUCHE"
s_texte_9    : "; FINITION"
s_texte_10   : "; AJOUTER LES BRIDEs"
s_texte_11   : "; ENLEVER LES BRIDEs"   #N° 11
s_liste_textes : ""

fstrsel s_texte_0 liste_textes s_liste_textes 11 -1

#s_texte_12   : "BLOC OPTIONNEL ON"    	#N° 1101
#s_texte_13   : "BLOC OPTIONNEL OFF"    #N° 1102
#s_texte_14   : "REPRISE"
#s_texte_15   : "BLOC OPTIONNEL OFF"
#s_texte_16   : "REPRISE"
#s_texte_17   : "ZONE 1"
#s_texte_18   : "ZONE 2"
#s_texte_19   : "EBAUCHE"
#s_texte_20   : "FINITION"            	#N° 1109
#s_texte_20   : "FINITION"            	#N° 1110 ... 1119
# --------------------------------------------------------------------------
s_convoyeur_ON		: "M35 ;CONVOYEUR ON"
s_convoyeur_OFF		: "M36 ;CONVOYEUR OFF"
#
s_compteur_piece	: "G950 ;COMPTEUR PIECE"
#
# Remise à ZERO de la valeur du A/B pour éviter les déroulés d'axes
s_reset_AB			: "M31 (REMISE A ZERO AXE A-B)"		# HURCO M31
# --------------------------------------------------------------------------

[STARTBIN]
#property of FICAM, Eric Dauvilliers, e.dauvilliers@ficam.com, +33 (0)2 37 26 28 10
scustpost_revision    : "26.1212" #:= Revision number for use by Resellers or customers.

#aide PPs
#if prmcode$ = 20005, perc_prof = rpar(sparameter$, 1)  #affecte la valeur de la ligne NCI 20005 - colonne 1 A  la variable "perc_prof"
#nextdc$ --> retourne la valeur du prochain type de perCage de 0 A  ....
																		
#region autres switches																
#infos communes AVEC LECTURE DEFINITION de la CN 			et SWITCH sans lecture de la DEFINITION de la CN
useaxe      		: -9999 	# -9999 = mode AUTO (DEF MACHINE) -- (utiliser l'axe A/B 1=oui 0=non)
sens_A_B        	: 1     	# pour inverser les calculs de l'axe A/B -1
diviseur    		: -1    	# diviseur tourne autour de X=1-->A autour de Y=2-->B // DEF MACHINE=-1

# ZONE de FORMULES  si : uniquement au dédut si = constante
yes$           	= 1 
no$            	= 0 

rpd_typ_v7$ 	: 1     # Use Version 7 style contour flags?
strtool_v7$ 	: 2     # Use Version 7 toolname, 1= path components, 2=string
get_1004$   	: 1     # Find gcode 1004 with getnextop?
cant_tlchng$ 	: 1    	# Ignorer entrEe de texte programmE au changement avec tlchng_aft?
spaces$     	: 1
progno$        	: 100
seqmax$        	: 99999         # Max. sequence no.
skp_lead_flgs$  : 1      		# Do NOT use v9 style contour flags
getnextop$     	: 1
plane$         	: -1
ncldr$         	: 20            # No. of leader characters
ldrcode$       	: 65            # Leader character dec. equiv.
nobrk$     		: no$       	# Omit breakup of rapid linear motion? yes/no(xy,z or z,xy)
progname$   	: 1          	# force le nom du nci en majuscule
opcode$        	: 1
cc_1013$       	: 1
no_updprv$  	: no$   		# no$ = utilise / yes$ = non(message)

#----------fichier-prog
sextnc$ 		: "mpf"
#*****SOUS PROG.
sub_level$  	: 2         #1 Enable automatic subprogram support
subprg$        	: yes$
mergesub$      	: no$
extprg$ 		: 1			#'extprg$' doit Etre à  1 pour (remplacer/écraser) 
							#ou 2 (ajouter au fichier existant) pour ouvrir un fichier auxiliaire.
sextext$ 		: ".ext"
spathext$ 		= spathnc$
sextsub$ 		: ".sub"
spathsub$ 		= spathnc$
sextaux$ 		: ".aux"
spathaux$ 		= spathnc$
# POUR INFOS
type_test_bris_outils   : 0 # test de bris outil --> mi5$
								# 0 = non 
								# 1 = ecriture en cycle "AXIAL - FORET", 
								# 2 = appel sous programme qui est dans "sbris_outil" a configurer plus bas
								# 3 = "TCH PROB 586"
Test_bris_outils		: 0	# Valeur depuis 	--> mi6$
								# 1 = A la fin de chaque outil  --> ptlchg 
								#     A chaque opération --> ptlchg0 
#endregion

#region REGLAGE_DEBUG
Mode_reglage_PP  	= 1         # 1= affiche toutes les valeurs pour info
affiche_prmcodes 	= 1         # 1= Affiche les prmcode$

# ----------------------------- Restrictions
# 1=actif    0=inactif
num_clEe_DEALER    : 104632     # Sergio = 104632    --> débloque toutes les restrictions
#
restric_version_MC      : 0   	# 0/1    1=actif    0=inactif
restric_version_num     : 22	# 21=2019    22=2020
restric_num_clEe        : 0     # 0/1    1=actif    0=inactif
num_clEe_client         : 0     # numEro de la clEe atribuEe
#
restric_durEe           : 0     # 0/1    1=actif    0=inactif
jour_                   : 23    # jour limite
mois_                   : 10    # mois limite
annEe_                  : 19    # annEe limite --> 20= 2020
#
#region Historique_modifs_versions
# -   DESCRIPTION DES MODIFICATIONS  
# Cycle d'ébavurage à la brosse
# Avances en DEG/mn en substitution et 4axes continus
# Palettes sur A/B
# correction affichage du 1er Z pour G1 après rotation
# 27/01/25	- suppression de l'appel du ploc "p_ori_usi_nul" au changement d'outil nul
# 24/04/25	- Gestion du M0 entre 2 OPs avec la rotation de broche et lub
#endregion
#endregion

#region Formats
# - FORMATS DES VARIABLES
# --------------------------------------------------------------------------
# Format statements - n=non modale, l=leading(devant), t=trailing(derriEre), i=inc, d=delta
# --------------------------------------------------------------------------
fs  1  1.9lt		# Format avec toute la precision pour les variableS internes de mp
fs  2  1.3			# format d'affichage a 3 chiffres max pour les variables affichées
fs  3  1.3n     	# idem mais non modale
fs  4  1 0ln
fs  5  3 0t			# 3 chiffre mini avant virgule  pas de virgule 0 apres force 0 de queue non modal.
fs  6  2 0ln
fs  7  4 0			# 4 chiffre mini avant virgule  pas de virgule pas de chiffre apres
fs  8  1.3ln 		# 1 chiffre avant la vigule met . 3 chiffres apres virgule non modal force 0 de tete
fs  9  1 0ltn		# 1 chiffres avant pas de virgule pas de chiffre apres non modal force 0 de tete
fs  10  1.9l
fs  11  1.3i		# force 1 chiffre avant virgule met . 3 chiffres apres virgule en incremental
fs  12  1 0l
fs  13  1.3ln
fs  14  3 0n
fs  15  1.3n		# format d'affichage a 3 chiffres max pour les variables affichées \ non modale
fs  16  1.9n
fs  17  +1%3li   	# force 1 chiffre avant virgule met . 3 chiffres apres virgule en incremental
fs  18  +1%3lni
fs  19  1^3n     	# pour la liste d'outils
fs  20  1^3l
fs  21  1.5ln
fs  22  +1^4ln
fs  23  1%3ln
fs  24  0.3n  		# Decimal, absolute, 3 place
fs  25  1.3ni
fs  26  1 0n		# 1 chiffre mini avant virgule  pas de virgule pas de chiffre apres non modale 
#endregion

#region fmt AFFECTATIONS_FORMATS
#brut
# --------------------------------------------------------------------------
fmt     	7  stck_crnr$  #Origin corner of stock (0 - 8)
fmt "X" 	2  stck_x$     #X origin of block
fmt "Y" 	2  stck_y$     #Y origin of block
fmt "Z" 	2  stck_z$     #Z origin of block
fmt "LX" 	2  stck_ht$    #X - Stock Height
fmt "LY" 	2  stck_wdth$  #Y - Stock Width
fmt "LZ" 	2  stck_thck$  #Z - Stock Thickness
fmt "X" 	2  stck_x_min  #Minimum stock block position (X)
fmt "Y" 	2  stck_y_min  #Minimum stock block position (Y)
fmt "Z" 	2  stck_z_min  #Minimum stock block position (Z)
fmt "X" 	2  stck_x_max  #Maximum stock block position (X)
fmt "Y" 	2  stck_y_max  #Maximum stock block position (Y)
fmt "Z" 	2  stck_z_max  #Maximum stock block position (Z)

fmt  "DIST"	2  bottomz      		#Bottom of stock
fmt  "L"  	2  topz         		#Top of stock
fmt  ""   	2  stck_ll_x    		#Stock lower left corner X value
fmt  ""   	2  stck_ll_y    		#Stock lower left corner Y value
fmt  ""   	2  stck_ur_x   			#Stock upper right corner X value
fmt  ""   	2  stck_ur_y    		#Stock upper right corner Y value
fmt  "R"  	2  stck_cyl_dia 		#Stock diameter for Cylindrical stock
fmt  "R0"	2  stck_cyl_dia_inter 	#Stock diameter for Cylindrical stock
fmt  "" 	2 xmin
fmt  "" 	2 ymin
fmt  "" 	2 zmin
fmt  "" 	2 xmax
fmt  "" 	2 ymax
fmt  "" 	2 zmax
#--------------- OUTILS --------------
fmt  "X"     2 xr$
fmt  "Y"     2 yr$
fmt  "Z"     2 zr$
fmt  "T"     4 t$
fmt  "T"     4 first_tool$
fmt          7 nom_outil
fmt  "T"     4 next_tool$
fmt  "T" 	 4 outil            	# numéro d'outil appele pour NC
fmt  "T" 	 4 outil_suivant    	# numéro de l'outil suivant pour NC
fmt     	 4 outils_param  
fmt     	 4 outil_suiv_param         
fmt  "R"  	 4 outil_param  
fmt     	 4 outil_paramT1 
fmt  "D"     7 tloffno$
fmt  "H"     4 tlngno$
fmt  "DIA." 13 tldia$
fmt         13 diam
fmt  "N"     4 ntool
fmt          1 plane$
fmt  "OP"   13 op_id$
fmt          7 affiche_client
fmt         13 old_t
fmt  "N" 	 4 num          	# numero de bloc sur ligne appel outil si pas de numerotation des lignes
fmt	 "D"	 7 dec_outil
#------- CONDITIONS DE COUPE --------
fmt  "F"     5 fr$
fmt  "F"     5 fr_pos$
fmt  "F"     5 avance
fmt  "S"     7 ss$
fmt  "S"     7 old_ssa
fmt  "S"     7 ssa
fmt  "S"     7 _ssa
fmt  "F"     7 olf_fr_5axes
fmt  "F"     5 F_G1_rot_5x
#-------------- DIVERS --------------
fmt          4 Mode_reglage_PP
fmt          4 type_pp_SIEMENS          
fmt  "CR="   2 arcrad$
fmt  "N"     4 n$
fmt          9 progno$
fmt         12 gcode$
fmt  "opcode: "   4 opcode$
fmt          4 coolant$
fmt          4 lubrif
fmt          7 ccomp$
fmt "G"      5 origine
fmt          9 workofs$
fmt          9 workofs_
fmt  "G"  	 9 workofs_pwrtt 
fmt    		 9 workofs_dec
fmt          9 old_workofs
fmt          4 debut
#------------------- POSITIONS ------------------------------------------
fmt  "X" 	2 xabs         	# XYZ en Absolue pour NC
fmt  "Y" 	2 yabs
fmt  "Z" 	2 zabs
fmt  "Z" 	2 zabs_deb_fin_secu_p_5x

fmt  "X" 	11 xinc        	# XYZ en incremental pour NC
fmt  "Y" 	11 yinc
fmt  "Z" 	11 zinc

fmt "px" 	2 old_x        	# ancien XYZ du NC
fmt "py" 	2 old_y
fmt "pz" 	2 old_z

fmt  "I" 	2 iabs         	# IJK centre des arcs pour NC en G90
fmt  "J" 	2 jabs
fmt  "K" 	2 kabs

fmt  "I" 	2 iinc         	# ijk centre des arcs pour NC en G91
fmt  "J" 	2 jinc
fmt  "K" 	2 kinc
fmt  "R" 	3 rayon        	# valeur de rayon de l'arc pour NC 828 ... 
fmt  "CR=(" 3 rayon_CR ")" 	# valeur de rayon de l'arc pour NC 840D
s_rayon_CR : "CR="			# Rayon du cercle de base UTILISE AVEC UNE HELICE
#

fmt  "I"     1 i$
fmt  "J"     1 j$
fmt  "K"     1 k$
fmt      	 1 old_comm_cnt  	# nombre d'enregistrement dans buffeur commentaires
fmt     	 4 Type_appel_outil 
fmt "_X_HOME = " 		2 x_home
fmt "_Y_HOME = " 		2 y_home
fmt "_Z_HOME = " 		2 z_home 
fmt "_X_HOME_4X = " 	2 x_home_4X 
fmt "_Y_HOME_4X = " 	2 y_home_4X 
fmt "_Z_HOME_4X = " 	2 z_home_4X 
fmt "_X_HOME_FIN = " 	2 x_home_FIN
fmt "_Y_HOME_FIN = " 	2 y_home_FIN
fmt "_Z_HOME_FIN = "	2 z_home_FIN
#----------- VAR PERCAGES -----------
fmt    		8 RTP        # Plan de retrait (en absolu)
fmt    		8 RFP        # Plan de rEfErence (en absolu)
fmt    		8 SDIS       # Distance de sEcuritE (introduire sans signe)
fmt    		8 DP         # Profondeur finale (en absolu)
fmt    		8 DPR        # Profondeur finale par rapport au plan de rEfErence (introduire sans signe)
fmt    		8 DTB        # Temporisation en fond dEalEsage (bris du copeau)
fmt    		8 OLD_RTP    # MEMO Plan de retrait (en absolu)
fmt    		8 old_garde_RTP	# pour le 5x
fmt    		8 OLD_RFP    # MEMO Plan de rEfErence (en absolu)
fmt    		8 OLD_SDIS   # MEMO Distance de sEcuritE (introduire sans signe)
fmt    		8 OLD_DP     # MEMO Profondeur finale (en absolu)
fmt    		8 OLD_DPR    # MEMO Profondeur finale par rapport au plan de rEfErence (introduire sans signe)
fmt    		8 OLD_DTB    # MEMO Temporisation en fond dEalEsage (bris du copeau)

fmt    		8 FDEP       # PremiEre profondeur de perEage (en absolu)
fmt    		8 FDPR       # PremiEre profondeur de perEage par rapport au plan de rEfErence (introduire sans signe)
fmt    		8 DAM        # DEgression : (introduire sans signe) valeurs : > 0 dEgression en tant que valeur - < 0 facteur de dEgression - = 0 pas de dEgression
fmt    		8 DT         # Temporisation au FOND et pour dEbourrage Valeurs : > 0 en secondes - < 0 en tours
fmt    		8 DTS        # Temporisation au point de DEPART et pour dEbourrage Valeurs : > 0 en secondes - < 0 en tours
#fmt    		8 FRF        # Facteur d avance pour la premiEre profondeur de perEage (introduire sans signe) Plage de valeurs : 0.001...1
fmt    		8 FRF        # % d avance pour la premiEre profondeur de perEage (introduire sans signe) Plage de valeurs : 0.001...1
fmt    		4 VARI       # Mode d'usinage : Valeurs : 0 bris du copeau - 1 dEbourrage
fmt    		4 _AXN       # Axe de l'outil :Valeurs : 1 = 1Er axe gEomEtrique - 2 = 2Eme axe gEomEtrique - sinon 3Eme axe gEomEtrique
fmt    		8 _MDEP      # Profondeur minimale de perEage
fmt    		8 _VRT       # Trajet variable de retrait pour bris du copeau (VARI=0) Valeurs : > 0 est la valeur du trajet 0 = trajet de 1 mm
fmt    		8 _DTD       # Temporisation E la profondeur finale Valeurs : > 0 en secondes - < 0 en tours - = 0 valeur comme DTB
fmt    		8 _DIS1      # Distance programmable d'arrEt anticipE lors nouvelle pEnEtration (pour dEbourrage VARI=1) Valeurs : > 0 valeur programmEe prise en compte - = 0 calcul automatique

fmt    		4 SDAC       # Sens de rotation aprEs fin de cycle valeurs : 3, 4 ou 5
fmt    		8 MPIT       # Pas du filet en tant que taille de filetage (avec signe) Valeurs : 3 (pour M3) E 48 (pour M48), le signe dEtermine le sens de rotation dans le filetage
fmt    		8 PIT        # Pas du filet en tant que valeur (avec signe) Valeurs : 0.001 ... 2000,000 mm), le signe dEtermine le sens de rotation dans le filetage si _PTAB=0 ou 1 : en mm (inchangE) si _PTAB=2 en nombre de filets par inch
fmt    		8 POSS       # Position de broche pour lEarrEt orientE de la broche dans le cycle (en degrEs)
fmt    		8 SST        # Vitesse de rotation pour taraudage
fmt    		8 SST1       # Vitesse de rotation pour retrait
fmt    		4 _PTAB      # UnitE du pas du filet PIT Valeurs : 0... selon systEme d'unitEs programmE inch/mEtrique 1... pas du filet en mm 2... pas du filet en nombre de filets par inch 3... pas du filet en inch/tour
fmt    		4 _TECHNO
fmt    		3 _DAM       # Profondeur incrEmentale Plage de valeurs : 0 <= valeur maxi
fmt    		8 FFR        # Avance alesoir
fmt    		8 RFF        # Avance retraction alesoir

fmt         13 depth$
fmt         13 refht$
fmt          2 dwell$
fmt  "P" 	 2 dwell     	# Tempo pour percage PROFOND pst
fmt         13 initht$
fmt         13 peckclr$
fmt         13 peck1$
fmt         13 zdrl$
fmt         13 peck2$
fmt         13 retr$
#fmt         13 sdis
fmt         13 shftdrl$
fmt "F"     14 frplunge$
fmt         14 frplunge2
#fmt         13 sst
#fmt         14 vari
fmt         13 pas           # valeur du pas pour taraudage
fmt          2 profrelatif
fmt          7 mvar
fmt         13 tosz$
fmt         13 old_tosz
fmt         13 old_profrelatif
fmt         13 old_drl_prm1
fmt         13 old_drl_prm2
fmt         13 old_drl_prm8
fmt         13 old_drl_prm9
fmt         13 old_drl_prm10
fmt         15 drl_prm4$
fmt         15 drl_prm5$
fmt         15 drl_prm6$
fmt         15 drl_prm7$
fmt         15 drl_prm8$
fmt         15 drl_prm9$
fmt         15 drl_prm10$
fmt         15 drl_prm10
fmt         15 drill_cycl
#cycle de percage profond
fmt "F" 	 9 f_p_profond   
fmt "Z" 	 2 z_dep_p_prof  
fmt     	 2 drlcst7 
fmt   	     4 posi_p_prof
fmt "Z" 	 2 depth_        
fmt "Z" 	 2 tosz_         
fmt "Z" 	 2 initht_       
fmt "Z" 	 2 refht_ 
fmt	"G4 X"	 2 tempo
fmt  "Z"	 2 zr_		 			       
# Axes A/B
fmt         13 axeB
fmt         13 old_axeB
fmt "A3="   16 p_svec$
fmt "B3="   16 q_svec$
fmt "C3="   16 r_svec$
fmt         16 tourne
fmt          4 tlplnno$
fmt "u"      1 u$
fmt "v"      1 v$
fmt "w"      1 w$
fmt "old_w"  1 old_w_
# AXES ROTATIFS
fmt  		 7 useaxe       	# flag pour utiliser le 4eme axe
fmt ""	 	 2 axeA         	# POSITION pour rotation plateau en ABS
fmt "B"   	11 axeAi       		# POSITION pour rotation plateau en INCREMENTAL
fmt "" 		 2 axeAB_subs       # rotation pour continue substitutuion en ABS
fmt "AM" 	 2 memo_AB_subs		# Memo du A/B du plan pour Ajout/soustraire
fmt "C"      2 axeA1
fmt "C"      2 axeA2
fmt "C"      2 delta_axeA1
fmt "C"      2 axeA1_dep
fmt "C"      2 old_axeA1
fmt     	 4 bloque        		# pour gestion M10 M11
fmt  "Z" 	 2 zdev         		# Z pour continue substitutuion en ABS

fmt          2 old_rotaxis
fmt  "A"     2 old_axeA      		# memo de l ancien A
fmt  "Sens"  2 sensA
fmt  "A"     2 epsi
fmt  "Ntour" 4 nbrtour      		# nombre de tour realise

fmt "X"      2 new_x
fmt "Y"      2 New_Y
fmt "Z"      2 new_z
fmt "DR"    13 drill_4_axes			#percage 5axes O/N
fmt "VX"     1 vx
fmt "VY"     1 vy
fmt "VZ"     1 vz
fmt "VEC"    1 longvec
fmt "VX2:"   1 vx2
fmt "VY2:"   1 vy2
fmt "VZ2:"   1 vz2
fmt "Z"     13 zinitht
fmt "X"      2 xp
fmt "Y"      2 yp
fmt "Z"      2 zp
fmt "OX"    13 old_tox4
fmt "OY"    13 old_toy4
fmt "OZ"    13 old_toz4
fmt "X"     13 tox4$
fmt "Y"     13 toy4$
fmt "Z"     13 toz4$
fmt "X"     13 tox4_
fmt "Y"     13 toy4_
fmt "Z"     13 toz4_
fmt     	 4 debutpmx  	# flag debut prog pmx
#-----------palpages-------------
fmt "_SETVAL="   2 palpage      
fmt ""           2 X_          
fmt ""           2 Y_           
fmt "X"     	13 X_depart     
fmt "Y"         13 Y_depart    
fmt         	 4 palpeur      
#------------------------------------
fmt         2 r_bout_out # = paramT6
fmt         2 A_bout_out # = paramT8
fmt         2 Val_origine_Z
fmt         2 Val_origine_Y
fmt         2 Val_origine_X
fmt         2 Old_Val_origine_Z
fmt         2 Old_Val_origine_Y
fmt         2 Old_Val_origine_X
fmt         2 pas_filetage    
# ------------------------------
fmt  "X"    2 x_tmin     	# Total x_min
fmt  "X"    2 x_tmax     	# Total x_max
fmt  "Y"    2 y_tmin     	# Total y_min
fmt  "Y"    2 y_tmax     	# Total y_max
fmt  "Z"    2 z_tmin     	# Total z_min
fmt  "Z"    2 z_tmax     	# Total z_max
fmt  "Z"    2 min_depth    	# Tool z_min
fmt  "Z"    2 max_depth    	# Tool z_max
# pour modif entete
fmt         7 entete_ 
fmt      	4 mi2$     
fmt "SPOS=" 2 mi3$          
fmt         2 old_mi3
fmt " "     2 mi4$          
fmt         7 posi_spalpeur
fmt         7 entete_listage_cotes
fmt         7 posi_MORTAIS         
# Ajouts pour modifier le principe des dEcallages; avec plan C/U cocher dEcallage...
fmt "G"    12 g_wcs  
fmt    		4 compteur_workofs                  
fmt         4 affichage_cycle       # perCage 5x
fmt         4 old_cc
#Sous-programmes
fmt "Na"    4 nprincipal            # memo du numero de ligne en prog principal
fmt "Nb"    4 nprincipalz           # memo du numero de ligne en prog principal
fmt         4 debsousprog           # NumEro du premier sous programme
fmt         4 subprognum            # appell sous-programe
fmt         4 numsubprog            # NumEro de sous-programe
fmt         4 nomsubprog            # Nom de sous-programe
fmt         4 old_omitseq
fmt         4 sub_prg_no$           # NumEro de sous-programe interne en Z
fmt         4 main_prg_no$          # NumEro de sous prog interne en transformation
fmt         2 sub_trnsx$            # decalage en X pour usinage transformE translation
fmt         2 sub_trnsy$            # decalage en Y pour usinage transformE translation
fmt         2 sub_trnsz$            # decalage en Z pour usinage transformE translation
fmt "DEC"   2 decalage              # flag pour savoir si on a ecrit une translation
fmt         4 sous_prog_int_ext     
fmt         4 appel_S_P_trans		# Flag actif OUI NON
fmt     		4 old_sub_trnstyp 
old_sub_trnstyp : -1
#--------------------------------------------------------------------------------
fmt "inc"   1 incremental           # mode incremental ou Absolue
fmt         4 memo_incremental      # mode incremental ou Absolu
fmt         4 inc_degage            # degagement machine en INCREMENTAL ou en ABSOLUE
#--------------------------------------------------------------------------------
fmt         4 change_nom            
# -------------------------LECTURE DES PARAMETRES DE SUREP ET DE TYPE DE CORRECTION--------------------------------------------
fmt "Type correc :" 	2 cc_computer$  # Type correction G41/G42/0
fmt "1=G41-2=G42 :" 	2 cc_pos$       # correction 1= G41(G) 2= G42(D) 0= OFF
fmt          			2 type_comp     # type de correction

fmt          			2 info_surep
fmt "SUREP. XY 2D = " 	8 surep_XY_2D  
fmt                 	8 old_surep_XY_2D  		
fmt "SUREP. Z 2D = "  	8 surep_Z_2D	
fmt                 	8 old_surep_Z_2D
fmt "SUREP. Z SURF = "  8 surep_Z_surf_2D 
fmt                 	8 old_surep_Z_surf_2D   	
fmt "SUREP. XY 3D = " 	8 surep_XY_3D	
fmt                 	8 old_surep_XY_3D 
fmt "SUREP. Z 3D = "  	8 surep_Z_3D 		
fmt                 	8 old_surep_Z_3D
#
fmt "R"             2 result
# --DEGAGEMENTS
fmt      	4 deg_debut
fmt      	4 deg_outil
fmt      	4 deg_4_axes
fmt      	4 deg_fin
fmt      	4 deg_inspection_plaq
fmt  "X"    3 degageX
fmt  "Y"    3 degageY
fmt  "Z"    3 degageZ
fmt  "X"    3 degageX_fin
fmt  "Y"    3 degageY_fin
fmt  "Z"    3 degageZ_fin
fmt  "X"    3 degageX4
fmt  "Y"    3 degageY4
fmt  "Z"    3 degageZ4
fmt  "X"    3 degageX_pal
fmt  "Y"    3 degageY_pal
fmt  "Z"    3 degageZ_pal
fmt  "X"    3 deg_insp_X
fmt  "Y"    3 deg_insp_Y
fmt  "Z"    3 deg_insp_Z
fmt  "X"    3 old_degageX
fmt  "Y"    3 old_degageY
fmt  "Z"    3 old_degageZ
fmt  "X"    3 old_degageX4
fmt  "Y"    3 old_degageY4
fmt  "Z"    3 old_degageZ4
fmt      	4 deg_apres_outil
fmt         4 deg_palette_deb_fin
fmt			4 type_deg
fmt			4 old_type_deg	#memo old_deg 
fmt 		4 degage_ap_out 	
fmt 		4 rot_tlchg_zero 
fmt			4 output_z
fmt			4 Cycles_palpage_YN
fmt			4 program_stop
fmt			4 Type_infos_outil
fmt			4 Position_info_outil
fmt			4 utilise_palette
fmt			4 type_prep_outil
fmt			4 decharge_outil_fin
fmt			4 fin_programme
fmt			4 S_maxi_renvoi_angle
# en plus pour lecture du fichier INI
fmt			4 Systeme_rot_plans   
fmt			4 rot_AB_un_sens
#fmt			16 Types_Temps_DLL_INI
fmt			4 Liste_outils
fmt			4 Nom_porte_outil_entete
fmt			4 affiche_num_op_MC
fmt			4 affiche_type_op_MC
fmt			4 old_affiche_type_op_MC
fmt			4 groupe_descripteur
fmt			4 nom_programmeur_PC
fmt			4 type_dec_4x_percage
fmt			4 block_form
fmt			4 convoyeur
fmt			4 compteur_pieces
#compteurs ops
fmt         4 increment_op_outil                   
fmt         13 old_op_id		# Memo de l'operation
fmt         13 old_op
#Divers
fmt     	4 liste_textes
fmt 		4 affiche_groupe
fmt         4 affiche_ori_entete 
# Parametres de DEF MACHINE-------------------------------
fmt    		4 type_composant     # type de composant
fmt    		4 compt_axes_rot     # compteur d'axes rotatif
fmt    		7 erreur             # numero d'erreur
fmt    		7 testerreur4        # flag pour erreur 4
fmt    		4 diviseur           # Axe de l'axe rotatif
fmt    		4 old_syncaxis       # memo du numero de combinaison d'axes
fmt    		4 nbr_combi          # Nombre de combinaison d'axes
fmt    		4 palette            # flag pour machine avec palette
fmt    		2 fmaxi              # avance maxi de la machine
fmt    		2 fmini              # avance mini de la machine
fmt    		4 nbr_outil          # nombre d'outils maxi
# Axes Pwrtt$ --> lecture avant traitement parcours
fmt    		4 rotation_axe
fmt    		4 rotation_A
fmt    		4 rotation_B

fmt    		4 sub_sec_no$
fmt    		4 sub_totl_no$

fmt   	 2 Angle_PLAN_MC_renvoie_angle
fmt      2 old_Angle_PLAN_MC_renvoie_angle
fmt   	 2 ANGLE_XY_renvoie_angle 
fmt   	 2 ANGLE_Z_renvoie_angle
fmt  	 4 type_renvoie_angle
fmt  "X" 2 decX         			# decalage d'origine en X pour G52
fmt  "Y" 2 decY         			# decalage d'origine en Y pour G52
fmt  "Z" 2 decZ         			# decalage d'origine en Z pour G52
fmt  	 4 renvoi_d_angle
fmt  	 4 ra_block$				# NUM. du BLOCK
fmt  	 4 sauve_ra_block_
fmt  	 4 ra_tc_type$				# type changement, auto, fixe, manuel
fmt  	 4 sauve_ra_tc_type_	
fmt  	 3 ra_rot_head$				# Rotation ou pas NCI line 1029/11	val-->11	0=fixe 1=rotatif
fmt  	 4 ra_type$					# type de bloc
fmt 	 3 lg_port_out_outil_block	# longueur du porte outil avec l'outil
fmt      4 prepa_out_renvoi
fmt 	 4 posi_nom_programmeur

fmt 	 4 old_usecandrill
fmt 	 4 old_usecanpeck
fmt 	 4 old_usecanchip
fmt 	 4 old_usecantap
fmt 	 4 old_usecanbore1
fmt 	 4 old_usecanbore2
fmt 	 4 old_usecanmisc1
fmt 	 4 old_usecanmisc2

fmt 	 4 usecanDRILL
fmt 	 4 usecanPECK
fmt 	 4 usecanCHIP

fmt 	 4 perc_1er_perc_pour_C_ou_mm
fmt 	 2 perc_Val_pour_Cent_mm
fmt 	 2 perc_AVANCE_pour_Cent_mm
fmt 	 2 P_er_perc_0
fmt 	 2 P_er_perc_1
fmt "Z"	 2 P_er_perc_2
fmt 	 2 angle_foret

fmt 	 3 mr7$ 
fmt 	 3 mr8$ 
# --------------------------------------------------------------------------
fmt  ""  2  cycle832_tol      #1st param on CYCLE832 output line. Tolerance = tolerance used to linearize splines during toolpath generation
fmt  ""  4  cycle832_tech     #2nd param on CYCLE832 Advanced Surface output line. Technology: 0=Deselection, 1=Finishing, 2=Semi-finishing, 3=Roughing
fmt  ""  4  cycle832_top_tech #2nd param on CYCLE832 Top Surface output line. Used for string selector and calculated from cycle832_tech & smoothing
fmt  ""  4  cycle832_version  #3rd param on CYCLE832 output line. 0=up to Siemens software version 7.5, 1=from HMI sl software version 2.6 onward
#endregion

#region debug_tolerances
#--------------------------------------------------------------------------------------------------------
#   DEBUG POST PRO
fastmode$   	: yes$
bug1$         	: 2     # 1 = Output post to screen - 2 = output leader to screen
bug2$         	: 50    # Add postline label to each line at column 'bug2'
bug4$         	: 60    # Add nci no
whatno$     	: yes$  # Ignore whatline branches to plin1 etc.?
newglobal$      : 0 	# Activer la vérification d'erreur pour les variables globales?
#--------------------------------------------------------------------------------------------------------
linktolvar$ 	: 1     # Associer les variables de tolErance X aux variables V9-
linkplnvar$ 	: 1     # Associer les variables spEcifiques plan X aux variables V9-?
#linklvar$   	: 1     # Associer les variables spEcifiques X Tournage aux variables V9-
#endregion

#region valeurs_initiales
axeA1_dep     	: -999999
axeA          	: 999
nbrtour     	: 0
old_axeA     	: 0

z_min$         	: 999
z_tmin         	: 999
z_max$         	: -999
z_tmax         	: -999
old_lubrif     	: -1
incremental 	: 0
xinc        	= xabs
yinc        	= yabs
zinc        	= zabs
sub_trnsx$  	: -99999
sub_trnsy$  	: -99999
sub_trnsz$  	: -99999
decalage    	: 0
lissage     	: 0

x$             	: 999
y$             	: 999
z$             	: 999
i$             	: 0
j$             	: 0
k$             	: 0
gcode$         	: -1
drlgsel       	= -1
rotaxtyp$     	: 3
debut        	: 0

on           	: 1
off          	: 0
debut_out     	: 1     # pour forcer l'affichage des avances aprA¨s l'appel de l'outil.
longTexte     	: 0       
old_mi3     	: -1
old_workofs     : -1
palpeur       	: 0       # Cycles de palpages A 0

increment_op         	: 0
prv_drill_cycl         	: 0
affichage_cycle     	: 1
entete_listage_cotes 	: 0
erreur 			: 0
nbr_combi 		: 0
compt_axes_rot 	: 0
palette 		: 0
increment_op_outil 	: 1
rotation_axe 	: -9999
rotation_A     	: -9999
rotation_B     	: -9999
write_ops    	: 0     #Write NC operation information (True/False)
Z_dir        	: 0     #Z Axis direction flag
axis_label   	: 0     #Axis label - 1=X,2=Y,3=Z
rot_zero 		: 0    	#Rotary zero degree position
rot_dir			: 0  	#Rotary direction
rot_index    	: 0 	#Index or continuous
rot_angle    	: 0 	#Index step
rot_type     	: 0		#Rotary type
min_speed    	: 50 	#Minimum spindle speed
maxfrinv_m   	: 0		#Maximum feedrate - inverse time - metric - Minimum value from MD as this is inverse time
maxfrdeg     	: 0		#Maximum feedrate deg/min
maxfeedpm_m  	: 0		#Limit for feed in mm/min

# WORKPIECE variables - used to define the stock for FANUC graphics / simulation on control
stock_cyl_axis 	: 0     #Stock cylinder axis 0=X,1=Y,2=Z
stock_shape    	: 0     #Stock shape from toolpath group parameters. 0=Rectangular/Box, 1=Cylinder

srot_label 		: ""  	#Rotary Axis label (Generally A, B or C) - Not yet available.
s_axe_brut_cyl	: ""	#Axe du brut cylindrique

#temps
fr_rapid_mach   : 12000 # Machine Rapid feedrate
tlchg_time  	: 0  	# Tool Change Time (Minutes) OK VALEUR DANS LA CN

type_CN			: -999
posi_CN_1		: -999
posi_CN_2		: -999
posi_CN_3		: -999
posi_CN_4		: -999
posi_CN_5		: -999
posi_CN_6		: -999
posi_CN_7		: -999
posi_CN_8		: -999
posi_CN_9		: -999
posi_CN_10		: -999
posi_CN_11		: -999
posi_CN_12		: -999	

posi_options	: -1	# positions/ emplacement des différentes OPTIONS dans l'ISO	1,2,3 ...

#temps DLL
fmt    			1 last_op_id_pwrtt 	# Derniere operation
fmt 			2 timeTT
fmt 			2 timeOp
fmt 			10 Heure	"H "
fmt 			10 min		"M "
fmt 			10 sec		"S "
fmt             4 Affiche_temps_dll
fmt "time_OP :" 	1 Tot_time_op 	# Total operation time
fmt "total_time :"  1 time_total	# Total time programme
fmt "OPs_time :"  	1 time_OPs		# Time operations
fmt    				4 Time_hrs    	# Time in hours
fmt    				4 Time_min    	# Time in minutes
fmt    				4 Time_sec    	# Time in seconds
fmt    				2 F_USI_prmcode # Feedrate
fmt "time_OUT :"    15 Tot_time_Out
fmt 				15 nbr_correct_XY_G0_time
fmt 				15 correc_dwell_time
fmt					4 Nbr_outils
fmt					4 Temps_chang_outil
fmt             	4 info_temps
fmt             	4 prof_temps
fmt             	4 div_prof_temps
sdllTimeOp 			: ""
sOpId 				: ""
stimeTT 			: ""
reste 				: 0
sNcPath 			: ""
last_op_id_pwrtt 	: 0
Types_Temps_DLL  	: -1	# Temps depuis la DLL
Types_Temps_DLL_1  	: -1
Nbr_outils 			: 0
time_correction_op	: 0

ori_1 : 0
ori_2 : 0
ori_3 : 0
ori_4 : 0
ori_5 : 0
ori_6 : 0
ori_7 : 0
ori_8 : 0
ori_9 : 0	

degage_ap_out 	: 1
rot_tlchg_zero  : 0
old_t 			: -9999

# Variables, grande vitesse - CYCLE832
cycle832_from_miscval 	: 0  	# mi9$ CYCLE832 tolérance et valeur technologique de Misc Values ? 0=Non (valeurs calculées par Pst), 1=Oui
									# 0 = Utiliser les valeurs par défaut pour les paramètres de tolérance et de technologie CYCLE832
									# 1 = Utilisez les valeurs de tolérance et de technologie CYCLE832 définies dans les valeurs diverses (mi10$, mr9$ et mr10$)	
cycle832_tol          	: 0  	# 1er paramètre sur la ligne de sortie CYCLE832. Tolérance = "tolérance utilisée pour linéariser les splines lors de la génération du parcours d'outil"
cycle832_tech         	: 0  	# 2ème paramètre sur la ligne de sortie CYCLE832 Surface avancée. Technologie : 0=Désélection, 1=Finition, 2=Semi-finition, 3=Ebauche
cycle832_top_tech     	: 0  	# 2ème paramètre sur la ligne de sortie CYCLE832 Top Surface. Utilisé pour le sélecteur de chaîne et calculé à partir du cycle832_tech et du lissage
cycle832_active       	: 0  	# Indicateur pour indiquer l’état du CYCLE832. 0=off, 1=on (ou no$=off, oui$=on)
deselect_cycle832     	: 0  	# Indicateur pour indiquer que les commandes de désélection du cycle832 doivent être émises
smoothing             	: 0  	# Lissage avec CYCLE832 Top Surface. 0=éteint, 1=activé
sav_cycle832_format   	: 0  	# Stocker le paramètre original cycle832_format
old_cycle832_tech		: 0
lissage_3d_actif 		: 0 	# passe à 1 si on l'a activé une fois
affiche_com_cycle832	: -1

#region TYPE de categories d'OPERATIONS
#Définir les opérations à inclure dans les qualités de finition technique du CYCLE832 - Ebauche
fmt	4	OP_Surface_ebauche
fmt	4	OP_Surface_finition
fmt	4	OP_percage

hs_surf_style : 0    #High-speed Surface Toolpaths, Style
OP_Surface_ebauche =				# 0 ou 1
      (
      tool_op$ = 5   |  # Multisurface rough parallel
      tool_op$ = 6   |  # Multisurface rough radial
      tool_op$ = 7   |  # Multisurface rough project
      tool_op$ = 8   |  # Multisurface rough flowline
      tool_op$ = 9   |  # Multisurface rough contour
      tool_op$ = 10  |  # Multisurface rough pocket
      tool_op$ = 44  |  # Multisurface rough plunge
      tool_op$ = 107 |  # Multi-surface rough restmill
      tool_op$ = 110 |  # Multi-surface 5axis, rough
      tool_op$ = 131 |  # Multi-surface rough pocket, light
      (tool_op$ = 132 & hs_surf_style = 0) |  # High-speed surface toolpaths - Roughing, Area Roughing
      (tool_op$ = 132 & hs_surf_style = 1) |  # High-speed surface toolpaths - Roughing, Dynamic OptiRough
      tool_op$ = 305 |  # Router surface rough pocket (obsolete)
      tool_op$ = 446    # Advanced multiaxis—roughing
      )

#Définir les opérations à inclure dans les qualités de finition technique du CYCLE832 - Finition
OP_Surface_finition =				# 0 ou 1
      (
      tool_op$ = 11  |  # Multisurface finish parallel
      tool_op$ = 12  |  # Multisurface finish radial
      tool_op$ = 13  |  # Multisurface finish project
      tool_op$ = 14  |  # Multisurface finish flowline
      tool_op$ = 15  |  # Multisurface finish contour
      tool_op$ = 39  |  # Multisurface finish pencil trace
      tool_op$ = 40  |  # Multisurface finish leftover stock
      tool_op$ = 41  |  # Multisurface finish steep
      tool_op$ = 42  |  # Multisurface finish shallow
      tool_op$ = 43  |  # Multisurface finish constant scallop
      tool_op$ = 45  |  # Multisurface finish 5-axis flowline
      tool_op$ = 46  |  # Multisurface finish 4-axis
      tool_op$ = 109 |  # Multi-surface finish blend
      (tool_op$ = 132 & hs_surf_style = 2)  |  # High-speed surface toolpaths - Finishing, Waterline
      (tool_op$ = 132 & hs_surf_style = 3)  |  # High-speed surface toolpaths - Finishing, Scallop
      (tool_op$ = 132 & hs_surf_style = 4)  |  # High-speed surface toolpaths - Finishing, Horizonal Area
      (tool_op$ = 132 & hs_surf_style = 5)  |  # High-speed surface toolpaths - Finishing, Raster
      (tool_op$ = 132 & hs_surf_style = 6)  |  # High-speed surface toolpaths - Finishing, Pencil
      (tool_op$ = 132 & hs_surf_style = 7)  |  # High-speed surface toolpaths - Finishing, Hybrid
      (tool_op$ = 132 & hs_surf_style = 9)  |  # High-speed surface toolpaths - Finishing, Spiral
      (tool_op$ = 132 & hs_surf_style = 10) |  # High-speed surface toolpaths - Finishing, Radial
      (tool_op$ = 132 & hs_surf_style = 15) |  # High-speed surface toolpaths - Finishing, Project
	  (tool_op$ = 132 & hs_surf_style = 16)    # High-speed surface toolpaths - Finishing, crête constante
      )

#Définir les opérations à inclure dans la catégorie Perçage
OP_percage =				# 0 ou 1
      (
      tool_op$ = 2   |  # Drill
      tool_op$ = 28  |  # 5-axis drilling
      tool_op$ = 37  |  # Non-associative drilling
      tool_op$ = 104 |  # Solid drill control operation
      tool_op$ = 136 |  # FBM drill control operation
      tool_op$ = 306    # Block drill
      )
#endregion

#endregion

#region strings
#------------------------------- STRINGS ------------------------------------
s_com_open				: ";"     	# STRING de debut de commentaire
s_com_close   			: ""     	# STRING de fin de commentaire
sdcom_MSG				: "MSG("    # STRING de debut de commentaire
sfcom_MSG   			: ")"     	# STRING de fin de commentaire
sguillemet      		: ""      
sinfo_origine   		: ""       	
Sold_snom_RUD   		: ""       
snom_RUD        		: ""
snomgroupe_op 			: ""   		# STRING du nom du groupe d'opération
snomgroupe_op_old 		: ""   		# STRING de l'ancien nom du groupe d'opération
s_nom_machine_entete	: ""   		# STRING du nom de la machine ****VALEUR DANS MC****
spalette 				: "PALETTE"	# STRING du nom palette
s_axe_rot_label 		: ""     	# Nom de l'axe rotatif (ABC)
s_axe_rot_A     		: "A"
#s_axe_rot_A     		: "A=DC("
s_axe_rot_B     		: "B"
#s_axe_rot_B     		: "B=DC("
scomentsprog    		: ""		# STRING du commentaire pour le titre du sous prog
snumsubprog     		: ""
s_mortais       		: "MORTAIS." #mortaisage sans erreur S=0
s_old_spost_arg_2		: ""
s_old_sinfo_origine 	: ""
s_nom_ORDI				: ""
s_nom_ORDI2				: ""
s_nom_programmeur		: ""
s_slash					: "\"
sdef_real				: "DEF REAL"
sdef_x_home 			: "_X_HOME"
sdef_y_home 			: "_Y_HOME"
sdef_z_home 			: "_Z_HOME"
s_x_home 				: "X=_X_HOME"
s_Y_home 				: "Y=_Y_HOME"
s_z_home 				: "Z=_Z_HOME"
sdef_x_home_4x 			: "_X_HOME_4x"
sdef_y_home_4x 			: "_Y_HOME_4x"
sdef_z_home_4x 			: "_Z_HOME_4x"
s_x_home_4x 			: "X=_X_HOME_4x"
s_Y_home_4x 			: "Y=_Y_HOME_4x"
s_z_home_4x 			: "Z=_Z_HOME_4x"
s_type_pp_xxxx 			: ""
#endregion

#region tableaux
# erreurs
serr0   : "err0"
serr1   : "ERREUR - LA FONCTION Ecriture de l'information CN d'opération DOIT ETRE VALIDE DANS LA DEFINITION D'ARMOIRE"
serr2   : "ERREUR - CE POST PRO NE SUPPORTE Q'UN SEUL AXE ROTATIF - VERIFIER LA DEF MACHINE ET LA COMBINAISON D'AXE"
serr3   : "ERREUR - CE POST PRO NE SUPPORTE Q'UNE SEULE COMBINAISON D'AXE PAR PROGRAMME - VERIFIER LA COMBINAISON D'AXE DES OPERATIONS"
serreur : ""
fstrsel serr0 erreur serreur 4 -1
# --------------------------------------------------------------------------
# Buffer 5 - Min / Max
# --------------------------------------------------------------------------
b5_gcode : 0
b5_zmin  : 0
b5_zmax  : 0
rc5      : 2
wc5      : 1
size5    : 0
fbuf 5 0 3 0 0  #Min / Max
#-------------------------------------------------------
# Table de l'affichage du type de correction
stc0       	: "CORREC. AUCUNE "
stc1       	: "CORREC. ARMOIRE D. "
stc2       	: "CORREC. ARMOIRE G. "
stc3       	: "CORREC. ORDI. D. "
stc4       	: "CORREC. ORDI. G. "
stc5       	: "CORREC. USURE D. "
stc6       	: "CORREC. USURE G. "
stc7       	: "CORREC. USURE INVERSE D. "
stc8       	: "CORREC. USURE INVERSE G. "
stc9		: "CORREC. ORDI. 3D "		
stype_comp 	: ""
fstrsel  stc0 type_comp stype_comp 10 -1
#-------------------------------------------------------
#   Affectation de G0 A  G3 dans sgcode en fonction du GCODE
sg00    : "G0"
sg01    : "G1"
sg02    : "G2"
sg03    : "G3"
sg04    : "G4"       # tempo  G4 F (F=en secondes S= en nombre de tour de broche)
sgcode : ""

fstrsel  sg00 gcode$ sgcode 5 -1
#---plans-----------------------------------------------
spl00   : "G17"
spl01   : "G19"
spl02   : "G18"
spl03     : ""
splcode : ""

fstrsel  spl00 plane$ splcode 4 -1
# CR----------------------------------------
scc0    : ""
sg40    : "G40"
sg41    : "G41"
sg42    : "G42"
sg140   : "G40"
sccomp : ""

fstrsel  scc0 ccomp$ sccomp 5 -1
#-------------------------------------------------------
#Drill variables
#drlgsel     :  -1   #Drill Select Initialize
drillref    : 0     #Select drill reference
#peckacel$   : 0     #Fractional percent to reduce peck2 when usecan.. : no
#drlgcode    : 0     #Save Gcode in drill
#sav_dgcode  : 0     #Drill gcode saved
# Canned drill cycle string select
#sg81    G81         #drill      - no dwell
#sg81d   G82         #drill      - with dwell
#sg83    G83         #peck drill - no dwell
#sg83d   G83         #peck drill - with dwell
#sg73    G73         #chip break - no dwell
#sg73d   G73         #chip break - with dwell
#sg84    G84         #tap        - right hand
#sg84d   G74         #tap        - left hand
#sg85    G85         #bore #1    - no dwell
#sg85d   G89         #bore #1    - with dwell
#sg86    G86         #bore #2    - no dwell
#sg86d   G86         #bore #2    - with dwell
#sgm1    G76         #misc #1    - no dwell
#sgm1d   G76         #misc #1    - with dwell
#sgm2    G81         #misc #2    - no dwell
#sgm2d   G82         #misc #2    - with dwell
#sgdrill             #Target for string

#fstrsel sg81 drlgsel sgdrill 16 -1
#-------------------------------------------------------
# Reference dEpart de perCages
sg98    : "G98"     # Reference INIT/SECU
sg99    : "G99"     # Reference DEPART
sgdrlref : ""

fstrsel sg98 drillref sgdrlref 2 -1
#-------------------------------------------------------
sinc00  : "G90"		# absolu
sinc01  : "G91"		# relatif
sinc02 	: ""
sinc_abs : ""
fstrsel sinc00 incremental sinc_abs 3 -1
#-------------------------------------------------------
#Brut
stck00 : "BOX"
stck01 : "CYLINDER"
stck_type : ""
fstrsel stck00 stock_shape  stck_type 2 -1
# --------------------------------------------------------------------------
# CYCLE832 Advanced Surface Technology value as a string
# cycle832_format = 2 
s832_adv_tech0     : "_OFF"     #Deselect / Off
s832_adv_tech1     : "_FINISH"  #Finish
s832_adv_tech2     : "_SEMIFIN" #Semi-Finish
s832_adv_tech3     : "_ROUGH"   #Rough
scycle832_adv_tech : ""         #Target string

fstrsel s832_adv_tech0 cycle832_tech scycle832_adv_tech 4 -1
# --------------------------------------------------------------------------
# CYCLE832 Advanced Surface Technology value as a string
# cycle832_format = 3 
s832_num_tech0     : "1000000"  #"2000000"	Deselect / Off	
s832_num_tech1     : "1000001"  #"2000001"	Finish
s832_num_tech2     : "1000002" 	#"2000002"	Semi-Finish
s832_num_tech3     : "1000003"  #"2000003"	Rough
scycle832_num_tech : ""         #Target string

fstrsel s832_num_tech0 cycle832_tech scycle832_num_tech 4 -1
# --------------------------------------------------------------------------
# CYCLE832 Advanced Surface Technology value as a string
# cycle832_format = 32 
s832_num2_tech0     : "2000000"  #"2000000"	Deselect / Off	
s832_num2_tech1     : "2000001"  #"2000001"	Finish
s832_num2_tech2     : "2000002" 	#"2000002"	Semi-Finish
s832_num2_tech3     : "2000003"  #"2000003"	Rough
scycle832_num2_tech : ""         #Target string

fstrsel s832_num2_tech0 cycle832_tech scycle832_num2_tech 4 -1
# --------------------------------------------------------------------------
# CYCLE832 Advanced Surface Technology value as a string
# cycle832_format = 4 
s832_top_tech0     : "_OFF"                             #Deselect / Off, smoothing off
s832_top_tech0s    : "_OFF"                             #Deselect / Off, smoothing on
s832_top_tech1     : "_TOP_SURFACE_SMOOTH_OFF+_FINISH"  #Finish, smoothing off
s832_top_tech1s    : "_TOP_SURFACE_SMOOTH_ON+_FINISH"   #Finish, smoothing on
s832_top_tech2     : "_TOP_SURFACE_SMOOTH_OFF+_SEMIFIN" #Semi-Finish, smoothing off
s832_top_tech2s    : "_TOP_SURFACE_SMOOTH_ON+_SEMIFIN"  #Semi-Finish, smoothing on
s832_top_tech3     : "_TOP_SURFACE_SMOOTH_OFF+_ROUGH"   #Rough, smoothing off
s832_top_tech3s    : "_TOP_SURFACE_SMOOTH_ON+_ROUGH"    #Rough, smoothing on
scycle832_top_tech : ""                                 #Target string

fstrsel s832_top_tech0 cycle832_top_tech scycle832_top_tech 8 -1
#-----------------------------------------------------
s_cycle832_utilise : ""
#-----------------------------------------------------
# Define the CYCLE832 default Metric tolerance
flktbl  4       4       #Lookup table definition - table no. - no. entries
        #Tolerance | Mode selector value
        0       0       #Off
        0.001   0.03    #Finish (Metric)
        0.04    0.1     #Semi-Finish (Metric)
        0.011   0.99    #Rough (Metric)
# POUR INFO --> appelé avec 	tolerance_usinage_3D = flook (4, tolerance) 
#...flook --> de à
#...frange --> si ss$ = alors
#...finc --> pour les outils, si num outil = alors ... voir "Intro_MP.pdf"
#-----------------------------------------------------
#   Tables des parametres
# POUR GERER CES PARAMETRES EN VX IL FAUT VALIDER L ECRITURE DANS LA DEF ARMOIRE
# DANS FICHIERS - ECRITURE DE L'INFO CN D'OPERATION
# --------------------------------------------------------------------------
fprmtbl 1   4  # lecture des parametres de surep pour contour et 3D
    10010   surep_XY_2D
    10068   surep_Z_2D
    12665	surep_XY_3D
    12666   surep_Z_3D
	#12068   surep_Z_surf_2D     

fprmtbl 19000   2    #Table Number, Size
    19133   stock_shape     #0=RECTANG. 1=CYLIND. 2=SOLIDE 3=FICHIER STL
    19135   stock_cyl_axis  #Stock cylinder axis 0=X,1=Y,2=Z
#endregion

#region Calculs_dans_la_marge
#-------------CALCULS DIVERS --------------

#endregion

#region commentaires
sm0 		: "M0"
fmt	4 affiche_m0
affiche_m0 : -1

pcomment$   # pour gcode = 1005-1008
    pcomment2

pcomment_end$  # post traitement des commentaires
    #if entete = 1, comm_cnt$ = old_comm_cnt

pcomment2
    scomm$ = ucase(scomm$)
	if debut = 1 & groupe_descripteur > 0, pcomment3
    if entete_ = 0, [
        if gcode$ = 1005, n$, s_com_open, scomm$, e$ 						# Usinage commentaire - en commentaire
        if gcode$ = 1006, [													# Usinage commentaire - FONCTION CN AVEC NUM. BLOC       
			if scomm$ = sm0 | scomm$ = sm00 & affiche_m0 = 1, 
				[
				n$, scomm$, e$ 
				n$, *spdlon, *ssa, e$
    			old_lubrif = -1
				n$, *scoolantx, e$
				affiche_m0 = 0
				]
			else, n$, scomm$, e$
			]
		if gcode$ = 1007, s_com_open, scomm$   								# dans la ligne de dEplacement
        #if gcode$ = 1008, scomentsprog = scomm$                 			# Nom du sous-prog.
		if gcode$ = 1008, n$, s_com_open, scomm$, s_com_close, e$  			#Operation comment using MSG("") *op_number, 
        if gcode$ = 1026, scomm$											# Entrée manuelle - code avec mouvement - pas de "e$"
        ]
    if entete_ = 1 & gcode$ = 1006 & scomm$ <> svide, ptextentete      		# pour informer l'entete prog.

pcomment3   # Affichage des commentaires d'entete de prog /GROUPES/DESCRIPTEUR
    scomm$ = ucase (scomm$)
    if gcode$ = 1051 & (groupe_descripteur = 1 | groupe_descripteur = 5), n$, s_com_open, "MACHINE : ", scomm$, s_com_close, e$     # Nom Machine
    if gcode$ = 1052 & (groupe_descripteur = 2 | groupe_descripteur = 5), n$, s_com_open, scomm$, s_com_close, e$      				# Commentaire de groupe Machine
    if gcode$ = 1053 & (groupe_descripteur = 3 | groupe_descripteur = 5), n$, s_com_open, "GROUPE : ", scomm$, s_com_close, e$      # Nom du Groupe PRINCIPAL Machine
    if gcode$ = 1054 & (groupe_descripteur = 4 | groupe_descripteur = 5), n$, s_com_open, scomm$, s_com_close, e$     				# Descripteur de fichier                            
    old_comm_cnt = comm_cnt$ 									
	
pnomgroupe  # Affichage du nom du groupe d'operation
    if affiche_groupe = 1,    [
        if snomgroupe_op <> svide & snomgroupe_op <> snomgroupe_op_old,
            [                                        
            n$, s_com_open, "*", snomgroupe_op, "*", s_com_close, e$       # nom du groupe d'operation
            snomgroupe_op_old = snomgroupe_op             
            ]
        ]
#endregion

#region restrictions
#strings
s_coordonnees           : "VEUILLEZ CONTACTER LA SOCIETE FICAM M. Dauvilliers Eric, e.dauvilliers@ficam.com, +33 (0)2 37 26 28 10"
s_erreur_version_MC     : "Ce POST-PROCESSEUR NE PEUT ETRE UTILISE AVEC CETTE VERSION DE MASTERCAM "
s_limite_utilisation    : "ATTENTION **CE POST-PRO n'est valide que jusqu'au :"
s_erreur_num_clee       : "VOTRE NUMERO DE CLEE NE PERMET PAS D'UTILISER CE POST-PROCESSEUR, VEUILLEZ CONTACTER "
s_annEe                 : ""

#pour calculs
Val_annEe_limite        : 0
Val_mois_limite         : 0
Val_Jour_limite         : 0
Val_year_               : 0
Val_month_              : 0
Val_day_                : 0

#formats
fmt         4    restric_version_MC     # 0/1
fmt         4    restric_num_clEe       # 0/1
fmt         4    restric_durEe          # 0/1
fmt "-"     4    jour_                  # jour limite
fmt "-"     4    mois_                  # mois limite
fmt "-"     4    annEe_                 # annEe limite
fmt         4    num_clEe_client

p_restriction_PP
    if sim_no$ <> num_clEe_DEALER,   # CLEE autorisEe
        [
        #restriction VERSION MASTERCAM
        if restric_version_MC = 1, [    #pour info 21 = version MC2019
            if vers_no$ <> restric_version_num, [
                result = mprint(vers_no$)
                result = mprint(restric_version_num)
                result = mprint(s_erreur_version_MC)
                result = mprint(s_coordonnees)
                exitpost$
                ]
            ]
        #restriction en durEe
        #year$ --> 20= 2020
        if restric_durEe = 1,    [
            # "VOIR: ", *year$, *annEe_, *month$, *mois_, *day$, *jour_, e$
            # calcul en jours "du jour ACTUEL"
            Val_year_ = year$ * 100
            Val_month_ = month$ * 30
            Val_day_ = Val_year_ + Val_month_ + day$ # totaux en jours du jour actuel
            # calcul en jours "du jour LIMITE"
            Val_annEe_limite = annEe_    * 100
            Val_mois_limite    = mois_ * 30
            Val_Jour_limite = Val_annEe_limite + Val_mois_limite + jour_

            if Val_day_ > Val_Jour_limite, [
                result = mprint(s_limite_utilisation)
                result = mprint(jour_)
                result = mprint(mois_)
                annEe_ = annEe_ + 2000
                result = mprint(annEe_)
                result = mprint(s_coordonnees)
                exitpost$
                ]
            ]
        #restriction en numero de clEe
        #sim_type$
        if sim_no$ = num_clEe_DEALER, ex$   # CLEE autorisEe
        if sim_no$ <> num_clEe_client & restric_num_clEe = 1, [
            result = mprint(s_erreur_num_clee)
            result = mprint(s_coordonnees)
            exitpost$
            ]
        ]
#endregion

#region pprep_ lecture def armoire et traitememt au debut
pprep$      # affectation des variables avant debut traitememt post pro en remplacement de la def armoire
    #seqmax$ = seqmax$ - 200        # se reserver les 200 dernier numero de ligne pour faire les sous prog
    #debsousprog = seqmax$          # memo du num de premier sous prog
    rd_mch_ent_no$ = -1             # forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    rd_cd$                          # lecture de la definition armoire
    rd_md$                          # lecture de la definition machine
    rd_tlpathgrp$                   # Lecture des éléments dans "param. outils- BRUT"
    if write_ops = 0, erreur = 1    # Write NC Operation information MUST be enabled in CD
      !erreur
      !serreur
    if erreur <> 0, [
        result = mprint(serreur, 2)
        exitpost$
        ]
    # bloc init post-pro en remplacement de la def armoire
    #pdebug
	if lire_def_machine = 0, p_force_config_pp, p_cycles_valides 
	smcpath$ = ucase (smcpath$)     # convertir en MAJUSCULES les noms
    smcname$ = ucase (smcname$)
    smcext$ = ucase(smcext$)
    snamepst$ = ucase (snamepst$)
    snamenc$ = ucase (snamenc$)
	#Blocs
    seqmax$         = 99999
    omitseq$        = yes$    # no$ = forcer la numerotation des blocs de 10 en 10    yes$ = pas de numérotation
	
p_cycles_valides	#pour réactivation après renvoie d'angle		
	#   UTILISER LES CYCLES MACHINE ou DECOMPOSITION en G1 G0
	# ATTENTION !!!!! PRENDS LE DESSSUS SUR LA DEFINITION DE L'ARMOIRE
	usecandrill$ = yes$   	# utiliser cycle percage lamage
	usecanpeck$  = yes$   	# utiliser cycle debourrage
	usecanchip$  = yes$   	# utiliser cycle brise copeaux
	usecantap$   = yes$   	# utiliser cycle taraudage
	usecanbore1$ = yes$   	# utiliser cycle alesage a l'alesoir
	usecanbore2$ = yes$   	# utiliser cycle alesage a la barre
	usecanmisc1$ = yes$		# utiliser cycle divers 1
	usecanmisc2$ = yes$    	# utiliser cycle divers 2

pdebug
    err_file$ = 4
    bug2$ = 60
    fastmode$ =0    #1 = Affiche les erreurs du pst dans un fichier .err

psynclath$      #Read NCI Axis-Combination (950) line
	#if lire_def_machine = 1, p_lire_axes    # axes valeur de la def_machine
	p_lire_axes   #Set rotary switches by reading machine def parameters
	#Rotaxtyp$ = 1 sets initial matrix to top
	#Rotaxtyp$ = -2 sets initial matrix to front
	#rotaxtyp$ = 4 donne les valeurs XYZ par rapport au RUD utilisé QUEL QUE SOIT LE PLAN
	#                    XYZ A plat
	#                    XZY EN FACE...
	#if vmc, rotaxtyp$ = one
	#else, rotaxtyp$ = -2

p_force_config_pp
    #REGLAGE ARCS
    # The following three initializations are used for full arc and helix arc output when the CD
    # is set to output R or signed R for arcs
    # 2 = IJ(DELTA DEPART-->Centre du Cercle) ou 5 = R(Rayon du Cercle)
    arctype$        = 2    #Arc center type XY plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé
    arctypexz$      = 2    #Arc center type XZ plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé
    arctypeyz$      = 2    #Arc center type YZ plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé

    breakarcs$      = 1    # Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
    do_full_arc$    = 0    # Allow full circle output? 0=no, 1=yes; 1 POUR LE FILETAGE A LA FRAISE (SUR 360DEG)
    helix_arc$      = 1    # Support helix arc output, 0=no, 1=all planes, 2=XY plane only
    arccheck$       = 1

ppost$       # traitement aprEs post pro pour effacer le fichier OPS et renommer le fichier NC
    if change_nom = 0, ex$           			# pour 0 = pas de changement sur le fichier
    snouv_nom = ucase(snouv_nom)
    sfileops = spathnci$ + snamenci$ + sops     #non du fichier ops
    result = remove (sfileops)                  #Efface le fichier ops (si existant, en fonction de la question 1524 du PST
                                                #ou d'aprA¨s la config MC, fichier utile pour les params surep...
    result = remove (snouv_nom)                 #efface fichier en nom numero
    result = rename (snom_nc, snouv_nom)        #renomer fichier NC en nom numero
    snouv_nom = sguillemet + snouv_nom + sguillemet 
    result = launch (seditor, snouv_nom)        #lancer le blocnote
#endregion

#region lubrifications
sav_coolant     : 0 # Coolant saved
sav_coolant_on  : 0 # XCoolant saved
# --------------------------------------------------------------------------
# Define coolant binary value for X style coolant
flktbl  2       20      #Lookup table definition - table no. - no. entries
        1       50      #Coolant 1 on value
        2       51      #Coolant 1 off value
        4       52      #Coolant 2 on value
        8       53      #Coolant 2 off value
        16      54      #Coolant 3 on value
        32      55      #Coolant 3 off value
        64      56      #Coolant 4 on value
        128     57      #Coolant 4 off value
        256     58      #Coolant 5 on value
        512     59      #Coolant 5 off value
        1024    60      #Coolant 6 on value
        2048    61      #Coolant 6 off value
        4096    62      #Coolant 7 on value
        8192    63      #Coolant 7 off value
        16384   64      #Coolant 8 on value
        32768   65      #Coolant 8 off value
        65536   66      #Coolant 9 on value
        131072  67      #Coolant 9 off value
        262144  68      #Coolant 10 on value
        524288  69      #Coolant 10 off value

#Lubrification Classique et VX
#   Gestion lubrif -0 arret -1 axe outil -2 buse -3 les deux separés du M3 M4
p_lubrif_ON
    lubrif = coolant$
    if v9_coolant & tool_op$ <> 114,     [
        if lubrif > 0,    [
            #if old_lubrif = 0, "M8"
            if lubrif = 1 & old_lubrif <> 1, coolantx = 0, *scoolantx
            if lubrif = 2 & old_lubrif <> 2, coolantx = 2, *scoolantx
            if lubrif = 3 & old_lubrif <> 3, coolantx = 4, *scoolantx
            old_lubrif = lubrif
            ]
        else, if old_lubrif = -1, scool50, lubrif = 1, old_lubrif = 1  #FORCE M08 si pas de lubrif d'actif
        ]
    if v9_coolant = 0, pcan1_cool #X style coolant

pinsp_cool_on   # LUBRIFICATION APRES l' "INSPECTION OUTIL"
      coolant_on = sav_coolant_on
      if v9_coolant, [coolant$ = sav_coolant], e$
      if coolant_on,
        [
        local_int = zero
        coolantx = zero
        while local_int < 20 & coolant_on > 0,
          [
          coolantx = and(2^local_int, coolant_on)
          local_int = local_int + one
          if coolantx > zero,
            [
            coolantx = local_int - one
            p_bloc_O, n$, *scoolantx, e$ #X style coolant on after tool inspection
            ]
          coolantx = zero
          ]
        ]

p_lubrif_OFF
    #if lubrif_complex_on = 1 | tool_op$ = 114, p_lubrif_OFF_VX   # on arrete tout les arrosages
    if v9_coolant & tool_op$ <> 114,     [
        if old_lubrif = 1, coolantx = 1, n$, scoolantx, e$
        if old_lubrif = 2, coolantx = 3, n$, scoolantx, e$
        if old_lubrif = 3, coolantx = 5, n$, scoolantx, e$
        old_lubrif = 0
        ]
    if v9_coolant = 0, pcool_off

pcool_off  #All Coolant off
      sav_coolant = coolant$ #Save V9 coolant
      sav_coolant_on = coolant_on #Save X coolant
      coolant$ = zero
#      if nextop$ = 1003, #Uncomment this line to leave coolant on until eof unless
        [                 #  explicitely turned off through a canned text edit
        if all_cool_off, [
          #all coolant off with a single off code here
          if coolant_on, p_bloc_O, n$, sall_cool_off, e$
          coolant_on = zero
          ]
        else, [
          local_int = zero
          coolantx = zero
          while local_int < 20 & coolant_on > 0, [
            coolantx = and(2^local_int, coolant_on)
            local_int = local_int + one
            if coolantx > zero, [
              coolantx = local_int
              p_bloc_O, n$, scoolantx, e$
              ]
            coolantx = zero
            ]
          coolant_on = zero
          ]
        ]
#endregion

#region Blocs optionnels
# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
bloc_O         : 0         #Block delete active

p_bloc_O                #Canned text - bloc OPTIONNEL
      if bloc_O, '/'

p_f_bloc_O               #Force - le bloc OPTIONNEL
      "/"
#endregion

#region Textes_et_arrosages
#Define Constants
m_one        = -1
zero         = 0
one          = 1
two          = 2
three        = 3
four         = 4
five         = 5
c9k          = 9999

#Coolant variables for X style coolant
cant_pos     : 0     #Read from current canned text (cant_pos1 - cant_pos20)
coolant_bin  : 0     #Binary value for current coolant command
coolant_on   : 0     #Binary value holding the sum of all coolants currently on
coolantx     : 0     #Selector variable for coolant string selector
local_int    : 0     #Local variable for output of coolant off commands
result2      : 0     #Return value for functions
suppress     : 0     #Flag used to suppress redundant coolant on commands
all_cool_off : 0     #SET_BY_MD - First coolant off command shuts off ALL coolant options
v9_coolant   : 0     #SET_BY_MD - Use V9 coolant options - read from General Machine Parameters

# --------------------------------------------------------------------------
#String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Address string definitions
strm         : "M"
strn         : "N"
stro         : "O"
strp         : "P"
srad         : "R"
srminus      : "R-"
sblank       : ""

#Cantext string definitions (spaces must be padded here)
sm00         : "M00"
sm01         : "M01"
strtextno    : ""
strcantext   : ""

# --------------------------------------------------------------------------
# Insertion des Textes / ARROSAGES
# --------------------------------------------------------------------------
pcan            #Insertion des Textes - LIGNE D'AVANT
      strcantext = sblank
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "PCAN : ", *cant_no$, e$
        if cant_pos1$ = zero | cant_pos1$ = three, pcant_1
        if cant_pos2$ = zero | cant_pos2$ = three, pcant_2
        if cant_pos3$ = zero | cant_pos3$ = three, pcant_3
        if cant_pos4$ = zero | cant_pos4$ = three, pcant_4
        if cant_pos5$ = zero | cant_pos5$ = three, pcant_5
        if cant_pos6$ = zero | cant_pos6$ = three, pcant_6
        if cant_pos7$ = zero | cant_pos7$ = three, pcant_7
        if cant_pos8$ = zero | cant_pos8$ = three, pcant_8
        if cant_pos9$ = zero | cant_pos9$ = three, pcant_9
        if cant_pos10$ = zero | cant_pos10$ = three, pcant_10
        if cant_pos11$ = zero | cant_pos11$ = three, pcant_11
        if cant_pos12$ = zero | cant_pos12$ = three, pcant_12
        if cant_pos13$ = zero | cant_pos13$ = three, pcant_13
        if cant_pos14$ = zero | cant_pos14$ = three, pcant_14
        if cant_pos15$ = zero | cant_pos15$ = three, pcant_15
        if cant_pos16$ = zero | cant_pos16$ = three, pcant_16
        if cant_pos17$ = zero | cant_pos17$ = three, pcant_17
        if cant_pos18$ = zero | cant_pos18$ = three, pcant_18
        if cant_pos19$ = zero | cant_pos19$ = three, pcant_19
        if cant_pos20$ = zero | cant_pos20$ = three, pcant_20
        if strcantext <> sblank, p_bloc_O, n$, strcantext, e$
        strcantext = sblank
        ]

pcan1           #Insertion des Textes - AVEC LA LIGNE
      strcantext = sblank
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "PCAN1 1: " *cant_no$, ": ",
        if cant_pos1$  = one, pcant_1
        if cant_pos2$  = one, pcant_2
        if cant_pos3$  = one, pcant_3
        if cant_pos4$  = one, pcant_4
        if cant_pos5$  = one, pcant_5
        if cant_pos6$  = one, pcant_6
        if cant_pos7$  = one, pcant_7
        if cant_pos8$  = one, pcant_8
        if cant_pos9$  = one, pcant_9
        if cant_pos10$ = one, pcant_10
        if cant_pos11$ = one, pcant_11
        if cant_pos12$ = one, pcant_12
        if cant_pos13$ = one, pcant_13
        if cant_pos14$ = one, pcant_14
        if cant_pos15$ = one, pcant_15
        if cant_pos16$ = one, pcant_16
        if cant_pos17$ = one, pcant_17
        if cant_pos18$ = one, pcant_18
        if cant_pos19$ = one, pcant_19
        if cant_pos20$ = one, pcant_20
        ]
      if cstop$, strcantext = strcantext + sm00
      if cgstop$, strcantext = strcantext + sm01
      #Output of strcantext occurs at the end of the output line

pcan1_cool      #Insertion des Textes AVEC l'ARROSAGE - ***SUR LA LIGNE***
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "pcan1_cool : ", *cant_no$, *cant_pos1$, "--", *cantext$, *tool_op$,
        if cant_pos1$  = four, pcant_1
        if cant_pos2$  = four, pcant_2
        if cant_pos3$  = four, pcant_3
        if cant_pos4$  = four, pcant_4
        if cant_pos5$  = four, pcant_5
        if cant_pos6$  = four, pcant_6
        if cant_pos7$  = four, pcant_7
        if cant_pos8$  = four, pcant_8
        if cant_pos9$  = four, pcant_9
        if cant_pos10$ = four, pcant_10
        if cant_pos11$ = four, pcant_11
        if cant_pos12$ = four, pcant_12
        if cant_pos13$ = four, pcant_13
        if cant_pos14$ = four, pcant_14
        if cant_pos15$ = four, pcant_15
        if cant_pos16$ = four, pcant_16
        if cant_pos17$ = four, pcant_17
        if cant_pos18$ = four, pcant_18
        if cant_pos19$ = four, pcant_19
        if cant_pos20$ = four, pcant_20
        ]

pcan2           #Insertion des Textes - APRES LA LIGNE
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two | cant_pos1$ = five, pcant_1
        if cant_pos2$ = two | cant_pos2$ = five, pcant_2
        if cant_pos3$ = two | cant_pos3$ = five, pcant_3
        if cant_pos4$ = two | cant_pos4$ = five, pcant_4
        if cant_pos5$ = two | cant_pos5$ = five, pcant_5
        if cant_pos6$ = two | cant_pos6$ = five, pcant_6
        if cant_pos7$ = two | cant_pos7$ = five, pcant_7
        if cant_pos8$ = two | cant_pos8$ = five, pcant_8
        if cant_pos9$ = two | cant_pos9$ = five, pcant_9
        if cant_pos10$ = two | cant_pos10$ = five, pcant_10
        if cant_pos11$ = two | cant_pos11$ = five, pcant_11
        if cant_pos12$ = two | cant_pos12$ = five, pcant_12
        if cant_pos13$ = two | cant_pos13$ = five, pcant_13
        if cant_pos14$ = two | cant_pos14$ = five, pcant_14
        if cant_pos15$ = two | cant_pos15$ = five, pcant_15
        if cant_pos16$ = two | cant_pos16$ = five, pcant_16
        if cant_pos17$ = two | cant_pos17$ = five, pcant_17
        if cant_pos18$ = two | cant_pos18$ = five, pcant_18
        if cant_pos19$ = two | cant_pos19$ = five, pcant_19
        if cant_pos20$ = two | cant_pos20$ = five, pcant_20
        if Mode_reglage_PP = 0, "pcan2 ", *cant_no$, e$
        if strcantext <> sblank, p_bloc_O, n$, strcantext, e$
        strcantext = sblank
        ]

pcant_1         #Insertion du Texte
      cant_pos = cant_pos1$
      cantext$ = cant_val1$
      pcant_out

pcant_2         #Insertion du Texte
      cant_pos = cant_pos2$
      cantext$ = cant_val2$
      pcant_out

pcant_3         #Insertion du Texte
      cant_pos = cant_pos3$
      cantext$ = cant_val3$
      pcant_out

pcant_4         #Insertion du Texte
      cant_pos = cant_pos4$
      cantext$ = cant_val4$
      pcant_out

pcant_5         #Insertion du Texte
      cant_pos = cant_pos5$
      cantext$ = cant_val5$
      pcant_out

pcant_6         #Insertion du Texte
      cant_pos = cant_pos6$
      cantext$ = cant_val6$
      pcant_out

pcant_7         #Insertion du Texte
      cant_pos = cant_pos7$
      cantext$ = cant_val7$
      pcant_out

pcant_8         #Insertion du Texte
      cant_pos = cant_pos8$
      cantext$ = cant_val8$
      pcant_out

pcant_9         #Insertion du Texte
      cant_pos = cant_pos9$
      cantext$ = cant_val9$
      pcant_out

pcant_10        #Insertion du Texte
      cant_pos = cant_pos10$
      cantext$ = cant_val10$
      pcant_out

pcant_11        #Insertion du Texte
      cant_pos = cant_pos11$
      cantext$ = cant_val11$
      pcant_out

pcant_12        #Insertion du Texte
      cant_pos = cant_pos12$
      cantext$ = cant_val12$
      pcant_out

pcant_13        #Insertion du Texte
      cant_pos = cant_pos13$
      cantext$ = cant_val13$
      pcant_out

pcant_14        #Insertion du Texte
      cant_pos = cant_pos14$
      cantext$ = cant_val14$
      pcant_out

pcant_15        #Insertion du Texte
      cant_pos = cant_pos15$
      cantext$ = cant_val15$
      pcant_out

pcant_16        #Insertion du Texte
      cant_pos = cant_pos16$
      cantext$ = cant_val16$
      pcant_out

pcant_17        #Insertion du Texte
      cant_pos = cant_pos17$
      cantext$ = cant_val17$
      pcant_out

pcant_18        #Insertion du Texte
      cant_pos = cant_pos18$
      cantext$ = cant_val18$
      pcant_out

pcant_19        #Insertion du Texte
      cant_pos = cant_pos19$
      cantext$ = cant_val19$
      pcant_out

pcant_20        #Insertion du Texte
      cant_pos = cant_pos20$
      cantext$ = cant_val20$
      pcant_out

pcant_out       #Canned text - build the string for output
    #Assign string select type outputs
    if Mode_reglage_PP = 0, "cantext 1 : ", *cantext$, " : ", *cant_pos, e$
    if cant_pos < three, #cant_pos indicates canned text output
        [
        if cantext$ = three, bloc_O = one
        if cantext$ = four, bloc_O = zero
        #Build the cantext string
        if cantext$ = one, strcantext = strcantext + sm00
        if cantext$ = two, strcantext = strcantext + sm01
        if cantext$ > four, [								#-----------LISTE DE TEXTES 
		  strtextno = no2str(cantext$)	  
          #strcantext = strcantext + strm + strtextno 	 
		  liste_textes = cantext$ #strtextno	  
		  strcantext = s_liste_textes #LISTE DE TEXTES
		  #strcantext
		  #*cant_pos, "XXXX",
		  if cant_pos = 1, s_liste_textes										#AVEC
		  if cant_pos = 0 | cant_pos = 2, n$, s_liste_textes, s_com_close, e$	#AVANT et APRES
          ]
        ]
    else, #cant_pos indicates coolant output --> ARROSAGES SI cant_pos > 2
        [
        #"ici1 ", e$
        coolant_bin = flook (two, cantext$) #Create binary value for each coolant using lookup table
        if frac(cantext$/two),  # ARROSAGES **OFF**
            [
            if all_cool_off, [
                if coolant_on, p_bloc_O, n$, sall_cool_off, e$
                coolant_on = zero
                ]
            else, [
                #"ici2 ", e$
                if coolant_on > 0, [
                      #"ici3 ", e$
                      coolant_on = coolant_on - coolant_bin/2 #Odd = off command, subtract appropriate binary value.
                      coolantx = cantext$ - 50                #Create a coolantx value for string select
                      p_bloc_O, n$, *scoolantx, e$
                      ]
                ]
            ]
        else, [                    # ARROSAGES **ON**         #Even = on command
            #Determine if this coolant is already on
            local_int = zero
            coolantx = zero
            suppress = zero
            while local_int < 20 & coolant_on > 0, [
                result2 = and(2^local_int, coolant_on)
                local_int = local_int + one
                if result2 = coolant_bin, suppress = one
                ]
            if suppress <> 1, [ #Don't output an on code for a coolant that is already on
                if Mode_reglage_PP = 0, "cantext 2: ", *cantext$, e$
                #"ici4 ", e$
                coolant_on = coolant_on + coolant_bin     #Maintain binary sum of all coolants currently on
                coolantx = cantext$ - 50                  #Create a coolantx value for string select
                if cant_pos = four, *scoolantx            #Coolant "AVEC"
                else, p_bloc_O, n$, *scoolantx, e$        #Coolant "AVANT" ou "APRES"
                ]
            ]
        ]
#endregion

#region Temps
p_temps_affectation
	Types_Temps_DLL_1 = plcval (s_Types_Temps_DLL, info_temps) 
	if Types_Temps_DLL_1 = 1, Types_Temps_DLL = info_temps	# pour rester dans le format 654321

p_temps_dll		#temps DLL
    if Affiche_temps_dll = 1, [	#évite également les messages si pas de DLL
		sOpId = no2str(op_id$)
	    result = dll(sdllTimeOp,sOpId)
	    timeOp = rpar(spost_arg_1$,1)
	    #timeTT = timeTT + timeOp
	    strtool$ = ucase(strtool$)
		]

p_Convert_time_dll
    # pour info "timeTT" est en secondes
	# tlchg_time = temps de changement d'outil dans la def machine
	@Types_Temps_DLL
		
	if Types_Temps_DLL > 3, [
		# / OUTIL ne pas additionner juste avant l'affichage	
		if Types_Temps_DLL <> 5, Tot_time_Out = Tot_time_Out + timeOp			
		# / TOTAL FIN 
		if Types_Temps_DLL <> 5 & Types_Temps_DLL <> 6, time_total = time_total + timeOp
		]	
	
	# NON CORRIGE EN ENTETE
	if Types_Temps_DLL < 4, [
		
		]
	
	if Types_Temps_DLL = 3, Tot_time_op = timeTT 		# / TOTAL 
	if Types_Temps_DLL = 2, Tot_time_op = Tot_time_Out	# / par OUTIL 	
	if Types_Temps_DLL = 1, Tot_time_op = timeOp		# / par OPERATION
	#
	
	# CORRIGE DANS LE CORPS
	time_correction_op = (coefficient_G0/10) * nbr_correct_XY_G0_time	# nbr de G0
	time_correction_op = time_correction_op  + correc_dwell_time		# ajout des tempos 
	#"VOIR : " *time_correction_op, e$
	if Types_Temps_DLL = 4, [							# / OP
		Tot_time_op = timeOp
		Tot_time_op = Tot_time_op + time_correction_op
		#"VOIR OP en S: ", *timeOp, e$ 
		]	
	if Types_Temps_DLL = 5, [							# / OUTIL
		Tot_time_op = Tot_time_Out + Temps_chang_outil + time_correction_op
		Tot_time_Out = 0
		#"VOIR OUTIL en S: ", *Tot_time_op, *Tot_time_Out, *Temps_chang_outil, e$  
		]
	if Types_Temps_DLL = 6, [							# / FIN					
		Temps_chang_outil = Temps_chang_outil * Nbr_outils 
		Tot_time_op = (time_total + time_correction_op) + Temps_chang_outil
		#"VOIR : ", *time_total, " ", *Tot_time_op, "Nbr de passages :", *nbr_correct_XY_G0_time, *time_correction_op, " T CH out", *Temps_chang_outil, e$
		#"VOIR TOTAL en S: ", *Tot_time_op, e$ 
		]	
		
	Time_hrs = Tot_time_op / 3600	#xx.yy
	Time_min = Time_hrs 			# --> mem
	Time_hrs = int(Time_hrs)		#xx		H
	
	Time_min = frac(Time_min)		#0.xx	M
	Time_min = Time_min * 60		#xx.yy 	M
	Time_min = int(Time_min)		#xx		M	
	
	Time_sec = Tot_time_op / 60		#yy.xx 	S
	Time_sec = frac(Time_sec)		#0.xx 	S
	Time_sec = Time_sec * 60		#xx.yy	S
	Time_sec = int(Time_sec)		#xx		S
	    	
	Heure = Time_hrs
	Heure = int(Heure)
	min = Time_min
	min = int(min)
	sec = Time_sec
	sec = int(sec)
	
p_correc_time_G0
	if drillcyc$ < 0, nbr_correct_XY_G0_time = nbr_correct_XY_G0_time + 1
	if drillcyc$ >= 0, [
		prof_temps = drl_depth_z$ - drl_sel_ref$	# Z matière -->drl_sel_tos$	# Profondeur
		prof_temps = abs(prof_temps)
		if peck1$ > 0, div_prof_temps = int(prof_temps/peck1$) 
		if peck1$ > 0, nbr_correct_XY_G0_time = nbr_correct_XY_G0_time + int(prof_temps/peck1$) 
		if dwell$ <> 0, correc_dwell_time = correc_dwell_time + (dwell$ * div_prof_temps) 	# temps en plus par profondeur de débourrage/brise-copeaux tempo
		#"VOIR :", *prof_temps, " ", *nbr_correct_XY_G0_time, " ", *correc_dwell_time, " ", *dwell$, e$
		]	
		
#endregion

#region approches_degagements
p_degage_entete_variables
	 if type_deg = 5, [	# VARIABLES
		*e$
		n$, s_com_open, "Définition du point de dégagement en variables", s_com_close, e$
		if deg_debut >0, [
			n$, sdef_real,sdef_x_home,44,sdef_y_home,44,sdef_z_home, e$
			x_home = degageX
			y_home = degageY
			z_home = degageZ
			n$, *x_home, *y_home, *z_home, e$
			]
		if deg_4_axes >0 & rotation_A =1 | rotation_B =1, [
			n$, sdef_real,sdef_x_home_4x,44,sdef_y_home_4x,44,sdef_z_home_4x, e$
			x_home_4X  = degageX4
			y_home_4X  = degageY4
			z_home_4X  = degageZ4
			n$, *x_home_4X, *y_home_4X, *z_home_4X, e$
			]
		*e$ 
		]	

#   Gestion du degagement de la machine au debut de prog
p_degage_debut       #   Gestion du degagement de la machine au debut de prog
	if deg_debut <> 0, [
		gcode$ = 0              			# Degagement en Rapide
    	if deg_debut >= 1 & deg_debut < 6 & type_deg <> 5, n$, ptype_deg, *degageZ, s_fin_deg, e$   	# si degager en Z		# degager en Z
	    if deg_debut = 2 | deg_debut = 4 & type_deg <> 5, n$, ptype_deg, *degageX, e$  					# si degager en Z et X	# degager en X
	    if deg_debut = 3 | deg_debut = 4 & type_deg <> 5, n$, ptype_deg, *degageY, e$  					# si degager en Z et Y	# degager en Y
	    if deg_debut = 5 & type_deg <> 5, n$, ptype_deg, *degageX, *degageY, e$         				# si degager en Z et XY	# degager en X Y
        if deg_debut = 6 & type_deg <> 5, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$ 	# si Mode degagement uniquement en MACRO
		if type_deg <> 5, ptype_deg_Fin
		# Variables
		if deg_debut >= 1 & deg_debut < 6 & type_deg = 5, n$, ptype_deg, *s_z_home, s_fin_deg, e$   	# si degager en Z		# degager en Z
	    if deg_debut = 2 | deg_debut = 4 & type_deg = 5, n$, ptype_deg, *s_x_home, e$  					# si degager en Z et X	# degager en X
	    if deg_debut = 3 | deg_debut = 4 & type_deg = 5, n$, ptype_deg, *s_y_home, e$  					# si degager en Z et Y	# degager en Y
	    if deg_debut = 5 & type_deg = 5, n$, ptype_deg, *s_x_home, *s_y_home, e$ 
		]

#   Gestion du degagement de la machine avant appel outil
p_degage_ptlchg     #   Gestion du degagement de la machine avant appel outil
    if deg_outil <> 0, [
	    gcode$ = 0              			# Degagement en Rapide
	    if deg_outil >= 1 & deg_outil < 6 & type_deg <> 5, n$, ptype_deg, *degageZ, s_fin_deg, e$     	# si degager en Z		# degager en Z
	    if deg_outil = 2 | deg_outil = 4 & type_deg <> 5, n$, ptype_deg, *degageX, e$ 					# si degager en Z et X	# degager en X
	    if deg_outil = 3 | deg_outil = 4 & type_deg <> 5, n$, ptype_deg, *degageY, e$ 					# si degager en Z et Y	# degager en Y
	    if deg_outil = 5 & type_deg <> 5, n$, ptype_deg, *degageX, *degageY, e$             			# si degager en Z et XY	# degager en X Y
        if deg_outil = 6 & type_deg <> 5, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$ 	# si Mode degagement uniquement en MACRO       
		if type_deg <> 5, ptype_deg_Fin
		# Variables
		if deg_outil >= 1 & deg_outil < 6 & type_deg = 5, n$, ptype_deg, *s_z_home, s_fin_deg, e$   	# si degager en Z		# degager en Z
	    if deg_outil = 2 | deg_outil = 4 & type_deg = 5, n$, ptype_deg, *s_x_home, e$  					# si degager en Z et X	# degager en X
	    if deg_outil = 3 | deg_outil = 4 & type_deg = 5, n$, ptype_deg, *s_y_home, e$  					# si degager en Z et Y	# degager en Y
	    if deg_outil = 5 & type_deg = 5, n$, ptype_deg, *s_x_home, *s_y_home, e$ 
		]

#   Gestion du degagement de la machine fin de prog
p_degage_fin #   Gestion du degagement de la machine fin de prog
   	if deg_fin <> 0, [
		gcode$ = 0              			# Degagement en Rapide
	    if deg_fin >= 1 & deg_fin < 6 & type_deg <> 5, n$, ptype_deg, *degageZ_fin, s_fin_deg, e$  		# si degager en Z		# degager en Z
	    if deg_fin = 2 | deg_fin = 4 & type_deg <> 5, n$, ptype_deg, *degageX_fin, e$    				# si degager en Z et X	# degager en X
	    if deg_fin = 3 | deg_fin = 4 & type_deg <> 5, n$, ptype_deg, *degageY_fin, e$  					# si degager en Z et Y 	# degager en Y
	    if deg_fin = 5 & type_deg <> 5, n$, ptype_deg, *degageX_fin, *degageY_fin, e$              		# si degager en Z et XY # degager en X Y
        if deg_fin = 6 & type_deg <> 5, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$ 	# si Mode degagement uniquement en MACRO
		if type_deg <> 5, ptype_deg_Fin
		# Variables
		if deg_fin >= 1 & deg_fin < 6 & type_deg = 5, n$, ptype_deg, *s_z_home, s_fin_deg, e$   		# si degager en Z		# degager en Z
	    if deg_fin = 2 | deg_fin = 4 & type_deg = 5, n$, ptype_deg, *s_x_home, e$  						# si degager en Z et X	# degager en X
	    if deg_fin = 3 | deg_fin = 4 & type_deg = 5, n$, ptype_deg, *s_y_home, e$  						# si degager en Z et Y	# degager en Y
	    if deg_fin = 5 & type_deg = 5, n$, ptype_deg, *s_x_home, *s_y_home, e$ 
		]

#   Gestion du degagement de la machine avant rotation plateau
p_degage_4_axes        #   Gestion du degagement de la machine avant rotation plateau
	if deg_4_axes <> 0, [
	    gcode$ = 0              	# Degagement en Rapide
		if mi2$ = 0, [				# Si différent de "0" alors pas de passage suivant config PP --> utilise UNIQUEMENT le Z sécu de l'op	             
		    #p_casse_modalite       # casser la modalite pour rappel des XYZ
		    if deg_4_axes >= 1 & deg_4_axes < 6 & type_deg <> 5, n$, ptype_deg, *degageZ4, s_fin_deg, e$ 	# si degager en Z		# degager en Z
		    if deg_4_axes = 2 | deg_4_axes = 4 & type_deg <> 5, n$, ptype_deg, *degageX4, e$  				# si degager en Z et X 	# degager en X
		    if deg_4_axes = 3 | deg_4_axes = 4 & type_deg <> 5, n$, ptype_deg, *degageY4, e$  				# si degager en Z et Y	# degager en Y
		    if deg_4_axes = 5 & type_deg <> 5, n$, ptype_deg, *degageX4, *degageY4, e$          			# si degager en Z et XY	# degager en X Y
		    if deg_4_axes = 6 & type_deg <> 5, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$ 	# si Mode degagement uniquement en MACRO
			if type_deg <> 5, ptype_deg_Fin
			# Variables
			if deg_4_axes >= 1 & deg_4_axes < 6 & type_deg = 5, n$, ptype_deg, *s_z_home, s_fin_deg, e$   	# si degager en Z		# degager en Z
		    if deg_4_axes = 2 | deg_4_axes = 4 & type_deg = 5, n$, ptype_deg, *s_x_home, e$  				# si degager en Z et X	# degager en X
		    if deg_4_axes = 3 | deg_4_axes = 4 & type_deg = 5, n$, ptype_deg, *s_y_home, e$  				# si degager en Z et Y	# degager en Y
		    if deg_4_axes = 5 & type_deg = 5, n$, ptype_deg, *s_x_home, *s_y_home, e$ 
			]
		#if mi2$ = 1, n$, *sgcode, *zr$, strcantext, e$				# FORCE le Z sécu de l'op si la config est remonter en Z HAUT 
		]
	#else, gcode$ = 0, n$, *sgcode, *zr$, strcantext, e$			# Sinon valeur de sécu de la valeur de l'opération MC

#   Gestion du degagement de l'outil lors de l'inspection de l'état de la plaquette 
pdeg_inspection_plaquette
	gcode$ = 0              			# Degagement en Rapide
	if deg_inspection_plaq <> 0, [    
	    #p_casse_modalite            	# casser la modalite pour rappel des XYZ
	    if deg_inspection_plaq = 1 & type_deg <> 5, n$, ptype_deg, *deg_insp_Z, e$             					# si degager en Z		# degager en Z
	    if deg_inspection_plaq = 2 | deg_inspection_plaq = 4 & type_deg <> 5, n$, ptype_deg, *deg_insp_X, e$	# si degager en Z et X 	# degager en X
	    if deg_inspection_plaq = 3 | deg_inspection_plaq = 4 & type_deg <> 5, n$, ptype_deg, *deg_insp_Y, e$  	# si degager en Z et Y	# degager en Y
	    if deg_inspection_plaq = 5 & type_deg <> 5, n$, ptype_deg, *deg_insp_X, *deg_insp_Y, e$          		# si degager en Z et XY	# degager en X Y
	    if deg_inspection_plaq = 6 & type_deg <> 5, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$
		if type_deg <> 5, ptype_deg_Fin
		# Variables
		if deg_inspection_plaq >= 1 & deg_inspection_plaq  < 6 & type_deg = 5, n$, ptype_deg, *s_z_home, s_fin_deg, e$   	# si degager en Z		# degager en Z
	    if deg_inspection_plaq = 2 | deg_inspection_plaq = 4 & type_deg = 5, n$, ptype_deg, *s_x_home, e$  					# si degager en Z et X	# degager en X
	    if deg_inspection_plaq = 3 | deg_inspection_plaq = 4 & type_deg = 5, n$, ptype_deg, *s_y_home, e$  					# si degager en Z et Y	# degager en Y
	    if deg_inspection_plaq = 5 & type_deg = 5, n$, ptype_deg, *s_x_home, *s_y_home, e$ 
		]
	else, n$, *sgcode, *zr$, strcantext, e$	#Sinon valeur de sécu dans l'opération MC
	
ptype_deg
    @type_deg
	if type_deg = 1, "G0 G53"
    if type_deg = 2, "G0 G153"
	if type_deg = 3, "SUPA G0"
	if type_deg = 4, "G0 G75"
	if type_deg = 5, "G0 G90 G500"

ptype_deg_Fin
    @type_deg
	if type_deg = 1, n$, "G90", e$
    if type_deg = 6, n$, "G90 ;A VALIDER", e$
#endregion

#region decallages_origines
# Gestion des G54 A G59 et 505 A  599
s_erreur_num_origine : "ATTENTION ERREUR de numéro d'origine Exemple 1=54 2=55 ..."
fmt "G"    12 workofs_trans
fmt "G"    12 old_workofs_trans
workofs_trans : -999
old_workofs_trans : -999
p_ori_usi
	# OPERATIONS TRANSFORMATIONS 
		# MODE 1 "AUTO ORIGINES" PASSENT A 1
		# MODE 2 
		# MODE 3 "INCREMENTAL" --> ok avec workofs$ 
	@workofs_,@old_workofs
	if workofs_ > 53, result = mprint(s_erreur_num_origine)
	if Mode_reglage_PP = 0, [
	    n$, "p_ori_usi", e$
		n$, "gw", *g_wcs, e$
	    n$, "workofs_", *workofs_, e$
		n$, "workofs$", *workofs$, e$
	    n$, "old_workofs", *old_workofs, e$
		n$, "op_transformation :", *xform_op_id$, " ", *op_id$, "dec transf:", *workofs_dec, e$	 
		n$, *workofs_trans, " ", *old_workofs_trans, e$
		# xform_op_id$ & op_id$ même numéro = pas de transformation
		]
    spaces$ = 1
    # OPERATIONS TRANSFORMEES 
	if xform_op_id$ <> op_id$ & workofs$ <> old_workofs_trans, [	# & workofs_dec > 1
		!workofs_trans, !workofs$, !old_workofs_trans 
		workofs_trans = workofs$	
		if workofs$ <> prv_workofs$ | debut_out = 1, [
			g_wcs = workofs_trans + 54
			if g_wcs <= 54, n$, *g_wcs, e$
	        if g_wcs > 59 & g_wcs < 151, g_wcs = g_wcs + 445, n$, *g_wcs, e$
			]
		old_workofs_trans = workofs_trans
		]	

	if workofs_ > 0 & workofs_ <> old_workofs, [
        g_wcs = workofs_ + 54
		if g_wcs <= 54, n$, *g_wcs, e$
        if g_wcs > 59 & g_wcs < 151, g_wcs = g_wcs + 445, n$, *g_wcs, e$
		else, n$, *g_wcs, e$
		old_workofs = workofs_
        ]

	if workofs_ <= 0 & workofs_ <> old_workofs & old_workofs_trans < 0, [
		g_wcs = 54
		n$, *g_wcs, e$
		old_workofs = workofs_
		]
	
	if tox4$ <> 0 | toy4$ <> 0 | toz4$ <> 0, [
		if tox4$ <> old_tox4 | toy4$ <> old_toy4 | toz4$ <> old_toz4, n$, s_com_open, "TRANS", *tox4$, *toy4$, *toz4$, s_com_close, e$	
		old_tox4 = tox4$
		old_toy4 = toy4$ 
		old_toz4 = toz4$  
		] 
	if (old_tox4 <> 0 & tox4$ = 0) | (old_toy4 <> 0 & toy4$ = 0) | (old_toz4 <> 0 & toz4$ = 0), [
		n$, s_com_open, "TRANS X0 Y0 Z0", s_com_close, e$
		old_tox4 = tox4$
		old_toy4 = toy4$ 
		old_toz4 = toz4$
		]			
    if old_workofs <> workofs_,	[
        if palpeur = 1, n$, s_com_open, "prise en compte aprEs un palpage", s_com_close, e$, old_workofs = workofs_
        ]
	if sinfo_origine <> svide2 & sinfo_origine <> s_old_sinfo_origine,	[
        n$, s_com_open, "INFO DECALAGE :", *sinfo_origine, s_com_close, e$
		s_old_sinfo_origine = sinfo_origine 
        ]	

# Force l'affichage de l'origine Gestion des G54 A G57 (pour la prise en compte aprEs un palpage)
p_ori_usi_force
    #@workofs_,@old_workofs
    if palpeur = 1, workofs_ = dwell$   # pour afficher le bon dEcallage
    p_ori_usi
#endregion

#region avances_parametrees
#---------------------------- avance variable -----------------------------------
fmt  "F= R" 4 frQ
fmt  "R50=" 2 varq50   #AVANCE PLONGEE
fmt  "R51=" 2 varq51   #AVANCE TRAVAIL
fmt  "oldQ" 2 old_q50
fmt  "oldQ" 2 old_q51
fmt  "oldQ" 2 old_q52
fmt  "PRVZ" 2 prvz
fmt     	4 debut_out
fmt     	4 old_frq 
fmt     	7   F_variables 
fmt  "F" 	14  F_plongee
fmt  "F" 	3   F_micro_remontee 
fmt  "F" 	3   F_G1_ugv_3D  
fmt  "F" 	3   F_G1_ugv_2D 
fmt  "F" 	3   F_retract 

pfr  
    #motst$ ="type de mouvement" 1=X 2=Y 3=X&Y 4=Z 5=X&Z 6=Y&Z 7=XY&Z
    #tool_op <> 2 pas au perçage
    #tool_op$ <> 102 pas au surfaçage
    #F_variables = 0 POUR LES QUESTIONS "fq1"
    #fr$ = -1 lorsque la valeur n'est pas différente
	@frQ
	if rotaxis$ <> 0 | nextop$ = 11, p_avances_avec_rot_A_B # SUBSTITUTION D'AXES --> EN DEGRES
	else, [
	    #"  ", *F_variables, *fr$, *nextop$, *mi4$, *tool_op$
	    if (F_variables = 1) & (nextop$ <> 11) & (mi4$ = 0) & (OP_percage <> 1) & (tool_op$ <> 102), [       
	        if fr$ <> -1, [	                        
				if fr_pos$ = F_plongee, frQ = 50, *frQ
				if (fr_pos$ = F_USI_prmcode) & (F_USI_prmcode <> F_plongee), frQ = 51, *frQ	
				if fr_pos$ <> F_plongee & fr_pos$ <> F_USI_prmcode, *fr_pos$ 
				#if fr_pos$ = F_G1_ugv_3D, F_G1_ugv_3D
				#if fr_pos$ = F_G1_ugv_2D, F_G1_ugv_2D
				#if fr_pos$ = F_retract, F_retract
				#if (fr_pos$ = F_micro_remontee) & ((F_G1_ugv_3D <> F_micro_remontee) | (F_G1_ugv_2D <> F_micro_remontee)), F_micro_remontee
	            ]
	        ]
	    if F_variables = 1 & tool_op$ = 102 & fr$ <> -1 & (mi4$ = 0), fr$ = 51, frQ = fr$, *frQ	# surfaçage
	    if fr_pos$ >= 0 & (nextop$ = 11 | mi4$ <> 0), fr_pos$  					# pas de F= -- OP 5 AXES
	    if F_variables = 0 & fr_pos$ <> -1, [									# pas de F=	
			if debut_out = 1, *fr_pos$ 											# force apres l'appel de l'outil              				
			fr_pos$
			]   			
	    debut_out = 0
		]   
    p_erreur_avanceS    
    # gestion de l'avance entre 2 passes en surfaçage prmcode = 10116 avec tool_op = 102

pfrvar   # ecriture des avances variables
	if F_variables = 1 & nextop$ <> 11 & mi4$ = 0 & (OP_percage <> 1) & rotaxis$ = 0, [
        varq51 = fr$
        if opcode$ = 4 | opcode$ = 13 | opcode$ = 14, varq50 = F_plongee, else, varq50 = varq51  #fr$/sqrt(tldia$*2) OPs de poches = avance MC
        @varq50,@varq51,@old_q50,@old_q51
		varq50 = F_plongee
        if debut_out = 1, [
			n$, *varq50, s_com_open, "AVANCE PLONGEE", s_com_close, e$
            n$, *varq51, s_com_open, "AVANCE TRAVAIL", s_com_close, e$
            ]
         if debut_out = 0, [       
			if old_q50 <> varq50, n$, *varq50, s_com_open, "AVANCE PLONGEE", s_com_close, e$
            if old_q51 <> varq51, n$, *varq51, s_com_open, "AVANCE TRAVAIL", s_com_close, e$
            ]
        old_q50 = varq50
        old_q51 = varq51
        ]
#endregion

#region Avances en "DEG/Minutes"
fmt "D"     2 deltaXYZ
fmt "Dx"    2 Delta_F_X
fmt "Dy"    2 Delta_F_Y
fmt "Dz"    2 Delta_F_Z
fmt         2 old_F_X
fmt         2 old_F_Y
fmt         2 old_F_Z
fmt "F"     2 fr_deg_inv
fmt         4 old_fr
fmt "DA"    2 Delta_Angle
fmt "A"     2 delta_A_sub
fmt ""      2 circum
fmt         2 ldelta
fmt         2 cldelta
fmt         2 cdelta
#Feedrate calculation variables
frdelta      : 0     #Calculation for deg/min
frinv        : 0     #Feedrate inverse time
frdeg        : 0     #Feedrate deg/min actual
prvfrdeg     : 0     #Feedrate deg/min actual
ldelta       : 0     #Calculation for deg/min, linear
cldelta      : 0     #Calculation for deg/min, linear and rotary

p_avances_avec_rot_A_B
    # calculs en "DEG/Minutes"
    spaces$ = 1
    if rotaxis$ <> 0,    # SUBSTITUTION X/Y
        [
        #"1111", *memo_AB_subs, *epsi, *old_axeA, "delta_A_sub", *delta_A_sub, e$
		Delta_Angle = delta_A_sub
		#circum = sqrt(Delta_F_X) * 2 * pi$
        circum = zabs * 2 * pi$			# Calcul du périmètre
        if circum = 0, circum = 9999
		ldelta = sqrt((xabs-prv_xabs)^2+(yabs-prv_yabs)^2+(zabs-prv_zabs)^2)
        cdelta = Delta_Angle
        if ldelta = 0, cldelta = cdelta
        else, cldelta = sqrt(cdelta^2 + ldelta^2)
        if cldelta = 0, cldelta = 9999
        Delta_F_Z = 0			
        if rotaxis$ = -2 | rotaxis$ = 2,    # ROTATION SUR X SUBSTITUTION DE Y
            [          
            Delta_F_X = x$ - old_F_X
            Delta_F_Y = ((2*pi$*zabs)/360) * Delta_Angle
            if Delta_F_X > 0, deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y)
            else, deltaXYZ = Delta_F_Y 
            old_F_X = x$
            ]
        if rotaxis$ = -1 | rotaxis$ = 1,    # ROTATION SUR Y SUBSTITUTION DE X
            [			
            Delta_F_Y = y$ - old_F_Y
            Delta_F_X = ((2*pi$*zabs)/360) * Delta_Angle
            if Delta_F_Y > 0, deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y)
            else, deltaXYZ = Delta_F_X          		
            old_F_Y = y$
            ]
		#"uuu", *ldelta, *deltaXYZ, *Delta_Angle
              #Delta_Angle = ((abs(cabs - prvcabs))/360)*circum
        ]
    if nextop$ = 11,                       # si  4 axes avec fonction 5 axes
        [
        #"2222", *epsi, *old_axeA, *delta_axeA1
        Delta_Angle = abs(epsi)
        Delta_F_X = y$ - old_F_X
        Delta_F_Y = y$ - old_F_Y
        Delta_F_Z = y$ - old_F_Z
        deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y + Delta_F_Z * Delta_F_Z)
        Delta_Angle = sqrt(Delta_Angle^2 + deltaXYZ^2)
        circum = sqrt(deltaXYZ) * 2 * pi$
        old_F_X = x$
        old_F_Y = y$
        old_F_Z = z$
        ]
    #"Delta_Angle", *Delta_Angle, " deltaXYZ:", *ldelta, *deltaXYZ, "lcircum", *circum
	@Delta_Angle
    if Delta_Angle > 0 | (nextop$ = 11 & epsi > 0),
        [
        #" ", *Delta_F_Y, *zabs, *rotaxis$, e$
        #deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y + Delta_F_Z * Delta_F_Z)
        ##fr_deg_inv = abs(cdelta/cldelta) * abs(fr_pos$ * (360/circum))
        fr_deg_inv = abs(Delta_Angle/deltaXYZ) * abs(fr_pos$ * (360/circum))
        if abs(fr_deg_inv - prvfrdeg) > 10, prvfrdeg = fr_deg_inv
        if fmtrnd(fr_deg_inv) = 0, fr_deg_inv = fr_pos$
        if fr_deg_inv > 2000, fr_deg_inv = 2000
        if fr_deg_inv < 50, fr_deg_inv = 50
        fr_deg_inv = round(fr_deg_inv)
        #if inversefeed$, [  #Feedrate in seconds --> DEPUIS DEF MACHINE (valeurs très petites)
            #fr_deg_inv = (fr_pos$*(1/60))/cldelta
            #]
        ]
	# Avance sans rotation --> pas de calculs
	if Delta_Angle = 0, avance = fr_pos$, *avance  
    if rotaxis$ <> 0 & Delta_Angle > 0, [
        #if Delta_Angle > 0 & (Delta_F_X > 0 | Delta_F_Y > 0 | Delta_F_Z > 0) & fr_deg_inv < 10000, fr_deg_inv
        #else, avance = fr_pos$, if avance <> old_fr, avance
        if Delta_Angle > 0 & (Delta_F_X > 0 | Delta_F_Y > 0 | Delta_F_Z > 0) & fr_deg_inv < 10000, if fr_deg_inv <> prv_fr_deg_inv, *fr_deg_inv
        Delta_Angle = 0
        Delta_F_X = 0
        Delta_F_Y = 0
        Delta_F_Z = 0
        ]
    if nextop$ = 11,                       # si  4 axes avec fonction 5 axes
        [
        #"3333", *Delta_Angle, *epsi, *Delta_F_X, *Delta_F_Y, *Delta_F_Z, *old_fr#*fr_deg_inv
        if epsi = 0, avance = fr_pos$, avance
        if epsi > 0 & fr_deg_inv < 10000, fr_deg_inv, old_fr = -9999        # & (Delta_F_X <> 0 | Delta_F_Y <> 0 | Delta_F_Z <> 0)
		]
#endregion

#region sous_programmes
p_info_sous_prog
	if Mode_reglage_PP = 0, [
		#n$, "appel sous prog en Z", e$
        n$, "num du sous-prog. : ", *main_prg_no$, e$
		n$, "NOM du sous-prog. : ", *sub_prg_no$, e$ 
		n$, "ID du sous-prog. : ", *sub_trns_id$, e$ 
		n$, "num de la chaine : ", *sub_chn_no$, e$ 
		n$, "Absolu ou relatif : ", *sub_inc$, e$
        n$, "(PASSE ", *sub_sec_no$, "SUR ", *sub_totl_no$, ")", e$
        "Subprogram number :", *sub_op_id$, e$
        "Actual operation ID :", *sub_grp_id$, e$
        "Transform/non-transform indicator :", *sub_ref_id$, e$
        "Iteration counter :", *sub_sec_no$, e$
        "Total number of instances :", sub_totl_no$, e$
        "0=mirror, 1=rotate, 2=scale, 3=translate :", *sub_trnstyp$, e$
        "(mirror) - 0=X axis, 1=Y axis, 2=line :", *sub_trnmthd$, e$
        "(rotate) - 0=tplane, 1=tplane origin only, 2=coordinates :", *sub_trnmthd$, e$
        *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, *sub_nxt_t$, *sub_nxt_h$, *sub_nxt_tid$, *sub_mny_t$, e$
        *wdum3$, "----", *rcc_flg$, *sub_prg_no$, *subout$, *sub_level$, *absinc$, e$
        ]

psub_call_s$     # appel sous prog en Z
	!sub_op_id$  #!sub_prg_no               # mise a jour du numero interne de sous prog en Z
    #subprognum = progno + progname         # affectation du numero de sous prog en Z
    numsubprog = sub_prg_no$                # affectation du numero de sous prog en Z
    subprognum = progno$ + sub_op_id$       # sub_prg_no = num prog principal
    snamenc$ = ucase (snamenc$)             # Nom du fichier CN
    spaces$ = 0
    if sous_prog_int_ext = 1,   # sous-programme INTER
        [
		if sub_sec_no$ = 1, n$, s_com_open, "PASSES EN Z", s_com_close, e$
		n$, s_com_open, "PASSE ", sub_sec_no$, " SUR ", sub_totl_no$, " EN Z", s_com_close, e$
		n$, "REPEAT DEBUT", subprognum, " FIN", subprognum, e$
        ]
    if sous_prog_int_ext = 2,   # sous-programme EXTER
        [
        n$, "EXTCALL ", 34, "SP", subprognum, snamenc$, 34, e$
        nprincipalz = n$     				# memo du numero de ligne du prog principal
        ]
    spaces$ = 1

psub_st_s$    #ecriture de l'entete de sous prog en Z
    !sub_prg_no$                            # mise a jour du numero interne de sous prog en Z
    numsubprog = sub_prg_no$                # affectation du numero de sous prog en Z
    #nomsubprog = numsubprog                # affectation du nom de sous prog en Z
    snamenc$ = ucase (snamenc$)             # Nom du fichier CN
    #numsubprog = progno + progname         #+ sub_prg_no
    memo_incremental = incremental          # memorisation du mode ABS INC Actuel
    incremental = sub_inc$                  # Sous prog en incremental ou absolue
    !sub_prg_no$
    numsubprog = progno$ + sub_prg_no$
    #"%", e$
	if incremental = 1, p_casse_modalite    # casser la modalité xyz pour les sous prog en relatif
    p_casse_modalite_avance                 # casser la modalité le l'avance pour les sous prog
    spaces$ = 0
    if sous_prog_int_ext = 2,	[			# sous-programme EXTER
        n$ = 10                 			# numero de ligne de sous prog
        "%_N_", "SP", numsubprog, snamenc$, "_SPF", e$
		if affiche_chemin = 1, [
	        pchemin
	        ";$PATH=/_N_WKS_DIR/_N_", schemincn, "_WPD", e$
			]
        ]
    if sous_prog_int_ext = 1,   [		# sous-programme INTER
        n$, "DEBUT", subprognum, ":", e$
        ]
	spaces$ = 1
	n$, "; SOUS-PROGRAMME EN -Z-", e$
	n$, ";", *sprogname$, e$
	if scomentsprog <> svide & texte = 1, n$, ";", scomentsprog, e$
	if scomentsprog <> svide & texte <> 1, n$, ";", scomentsprog, e$   
    n$, ";", strtool$, smanu, e$
    n$, *sinc_abs, e$                   	# ecrire si sous prog en ABS ou INC
	gcode$ = 5                          	# pour forcer l'ecriture de code G du premier bloc du sous prog
    !gcode$

psub_end_s$    							# fin sous prog en Z
    incremental = memo_incremental      	# rappel du mode INC ABS precedent
    n$, *sinc_abs, e$
    if sous_prog_int_ext = 1,   [			# sous-programme INTER
        n$, "FIN", no_spc$, subprognum, no_spc$, ":", e$
        ]
    if sous_prog_int_ext = 2,   [			# sous-programme EXTER
        n$, "RET", e$
        n$ = nprincipalz             		# recuperation du numero de ligne pour prog principal
        ]
    *e$

#-------------------------BLOCS DE TRAITEMENT DES SOUS-PROG EN TRANSFORMMATION---------------------------
#-----------------------------------------------------------
# sous prog. de translation:    TRANS X-200 Y100    #idem G58 - par rapport A  l' origine "EN ABSOLU"
# sous prog. de translation:    ATRANS X-200 Y100    #idem G59 - par rapport AU DERNIER ORIGINE "EN RELATIF"
# sous prog. de rotation    ROT Z30    # rotation autour de Z par rapport A  l' origine "EN ABSOLU"
# sous prog. de rotation    AROT Z30    # rotation autour de Z par rapport AU DERNIER ORIGINE "EN RELATIF"
#       TRANS           # VIDE = annulation
#       ROT             # VIDE = annulation
#---------------------------------------------------------------------------

ptranslation    # pour usinage transformE en translation
    if sub_trnsx$ = 0 & sub_trnsy$ = 0 & sub_trnsz$ = 0,	[
        # 										si pas de decalage, ne rien faire
        #n$ "; SANS TRANSLATION ADDITIVE", e$
        ]
    else,   [                                   # si decalage, ecriture du G52
        memo_incremental = incremental
        incremental = 0
        #if sinc_abs = "G90",	[
            #*e$
                #n$, sinc_abs, e$
                #n$, "TRANS", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$   # ecriture des valeur de decalage d'origine
            #n$, *sgcode, *sinc_abs, *xr$, *yr$, e$ # Ajout pour avoir le pt X Y de DEPART
            #]
        #if sinc_abs = "G91",
            #[
            *e$
                #n$, sinc_abs, e$
                #n$, "ATRANS", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$   # ecriture des valeur de decalage d'origine
            n$, *sgcode, *sinc_abs, *xr$, *yr$, e$ # Ajout pour avoir le pt X Y de DEPART
            #]
        decalage = 1                            # memo de mise en place de decalage pour l'annuler
        incremental = memo_incremental
        n$, sinc_abs, e$
        ]

psub_mirror     #Mirror start code, user
	#Mirror Y axis
	#if sub_trnmthd$, n$, *sgabsinc, strns_mir_on, *sub_trnsx$, e$
	#Mirror X axis
	#else, n$, *sgabsinc, strns_mir_on, *sub_trnsy$, e$
	n$, " A CREER -SOUS PROG MIRROIR-", e$
	n$, "MIRROR X.. Y.. Z.. Fonction miroir absolue", e$

psub_rotate     #Rotate start code, user
    #n$, *sgcode, *sinc_abs, *sub_trnsx$, *sub_trnsy$,
    #[absinc$ = one], *sgabsinc, e$
    memo_incremental = incremental
    incremental = 0
    *e$
    n$, *sgcode, *sinc_abs, *xr$, *yr$, e$
    #n$, "(FAIRE UN DECALGE G52)", e$
    #n$, sinc_abs, "G52", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$   # ecriture des valeur de decalage d'origine
    decalage = 1                            # memo de mise en place de decalage pour l'annuler
    incremental= memo_incremental
    n$, sinc_abs, e$

s_sous_p_en_ABSOLU_HS	: "ATTENTION ! Les sous-programmes doivent être en RELATIF autrement il va y avoir des parcours en trop ! PASSEZ EN mode RELATIF"
p_type_sous_prog
    appel_S_P_trans = 1
	if sub_trnstyp$ <> old_sub_trnstyp, [   	
		n$, s_com_open, "APPEL SOUS-PROGRAMME ", s_com_close, e$
		if sub_trnstyp$ = 0, n$, s_com_open, "TRANSFORMATION PAR MIRROIR ", s_com_close, e$
		if sub_trnstyp$ = 1, n$, s_com_open, "TRANSFORMATION PAR ROTATION ", s_com_close, e$
		if sub_trnstyp$ = 2, n$, s_com_open, "TRANSFORMATION PAR ECHELLE ", s_com_close, e$
		if sub_trnstyp$ = 3, n$, s_com_open, "TRANSFORMATION PAR TRANSLATION ", s_com_close, e$
		]
	if sub_inc$ = 0, result = mprint(s_sous_p_en_ABSOLU_HS)

psub_call_mm$     # appel sous prog en transformation pour OPERATIONS AVEC "outils multiples"
	p_info_sous_prog
	#"appel sous prog en transformation pour outils multiples", e$
	!main_prg_no$                                   # mise a jour du numero interne de sous prog en transformation pour outils multiples
	subprognum = debsousprog + main_prg_no$ +100    # affectation du numero de sous prog
	if sub_trnstyp$ = 3, ptranslation              	# si on fait de la translation aller avant dans bloc ecriture decalage origine
	if sub_trnstyp$ = 2, psub_mirror
	if sub_trnstyp$ = 1, psub_rotate
	nprincipal = n$ + seqinc$                      	# memo du numero de ligne pour le rappel dans le sous-programme
	#*nprincipal, e$                                # affecation du parametre CN pour memo du numEro de ligne
	spaces$ = 1
	p_type_sous_prog
	if sub_trnstyp$ <> old_sub_trnstyp, n$, "; AVEC OUTILS MULTIPLES ", e$
	n$, "EXTCALL ", 34, "SP", subprognum, 34, e$    # snamenc$,
	#spaces$ = 1
	nprincipal = n$                                 # memo du numero de ligne pour le prog principal
	old_sub_trnstyp = sub_trnstyp$  
	
psub_call_m$   # appel sous prog en transformation pour OPERATIONS AVEC "outil unique"
    p_info_sous_prog
	#"appel sous prog en transformation", e$
    !main_prg_no$                                   # mise a jour du numero interne de sous prog en transformation pour outils multiples
    subprognum = debsousprog + main_prg_no$ +100    # affectation du numero de sous prog
    if sub_trnstyp$ = 3, ptranslation               # si on fait de la translation aller avant dans bloc ecriture decalage orignie
    if sub_trnstyp$ = 2, psub_mirror
    if sub_trnstyp$ = 1, psub_rotate
    nprincipal = n$ + seqinc$                       # memo du numero de ligne pour le rappel dans le sous-programme
    #*nprincipal, e$                                # affecation du parametre CN pour memo du numEro de ligne
    spaces$ = 1
    #n$, "; ", e$
    p_type_sous_prog
    if sub_trnstyp$ <> old_sub_trnstyp, n$, "; AVEC UN SEUL OUTIL ", e$
    n$, "EXTCALL ", 34, "SP", subprognum, 34, e$    # snamenc$,
    #spaces$ = 1
    nprincipal = n$                                 # memo du numero de ligne pour le prog principal
	old_sub_trnstyp = sub_trnstyp$  
	
psub_end_m_r$    # bloc system non explique dans doc des PST (a voir)
	#NESTING
    #n$, "; TEST - psub_end_m_r$", e$

psub_st_m$    # entete sous prog en transformation
    !main_prg_no$                                   # mise a jour du numero interne de sous prog en Z
    numsubprog = main_prg_no$                       # affectation du numero de sous prog en Z
    numsubprog = debsousprog + main_prg_no$ +100    # affectation du numero de sous prog
    #nomsubprog = numsubprog                        # affectation du nom de sous prog en Z
    snamenc$ = ucase (snamenc$)                     # Nom du fichier CN
    memo_incremental = incremental                  # memorisation du mode ABS INC Actuel
    # **** VOLONTAIREMENT PAS DE DEPLACEMENTS EN MODE RELATIF **** UTILISE ET force en ABSOLU SUITE A un PROBLEME de REPETITION 
    #incremental = sub_inc$                  		# Sous prog en incremental ou absolue
	# ****
    if incremental = 1, p_casse_modalite           	# casser la modalitE pour les sous prog en relatif
    #p_casse_modalite_avance                        # casser la modalitE le l'avance pour les sous prog
    omitseq$ = 1                                    # pas du numero de ligne pour les sous prog
    spaces$ = 0
    if texte = 1,   [               				# entete avec commentaires
		if affiche_chemin = 1,
		    [
			"%_N_", "SP", numsubprog, "_SPF", e$
			pchemin
			";$PATH=/_N_WKS_DIR/_N_", snamenc$, "_WPD", e$ #schemincn
		    ]
		spaces$ = 1
		n$, s_com_open, *snamenc$, e$ #*sprogname$, e$
		n$, "; SOUS-PROGRAMME PAR -TRANSFORMATION-", e$
		if scomentsprog <> svide & texte = 1, n$, s_com_open, *scomentsprog, e$
		if scomentsprog <> svide & texte <> 1, n$, s_com_open, *scomentsprog, e$		
		]
    else, s_com_open, *sprogname$, e$
    n$, s_com_open, strtool$, smanu, e$
    n$, *sinc_abs, e$           					# ecrire si sous prog en ABS ou INC
    gcode$ = 5                  					# pour forcer l'ecriture de code G du premier bloc du sous prog
    !gcode$

psub_end_m$   # fin sous prog en transformation
    incremental = memo_incremental      			# rappel du mode INC ABS precedent
    n$, *sinc_abs, e$
    n$, "RET", e$                       			# fermeture de sous prog
    *e$
    #omitseq$ = old_omitseq
    n$ = nprincipal                     			# recuperation du numero de ligne pour prog principal
#endregion

#region questions_NOUVEAU_ANCIEN
#region NOUVEAU
svide2 : ""
#----
s_question_1 : s_texte_question_1
s_question_2 : s_texte_question_2
s_question_3 : s_texte_question_3
s_question_4 : s_texte_question_4
s_question_5 : s_texte_question_5
s_question_6 : s_texte_question_6
s_question_7 : s_texte_question_7
s_question_8 : s_texte_question_8
s_question_9 : s_texte_question_9
s_question_10 : s_texte_question_10
s_question_11 : s_texte_question_11
s_question_12 : s_texte_question_12
s_question_13 : s_texte_question_13
s_question_14 : s_texte_question_14
s_question_15 : s_texte_question_15
s_question_16 : s_texte_question_16
s_question_17 : s_texte_question_17
s_question_18 : s_texte_question_18
s_question_19 : s_texte_question_19
s_question_20 : s_texte_question_20

#----
fq 1 s_question_1 "//s_texte_question_1//"
fq 2 s_question_2 "//s_texte_question_2//"
fq 3 s_question_3 "//s_texte_question_3//"
fq 4 s_question_4 "//s_texte_question_4//"
fq 5 s_question_5 "//s_texte_question_5//"
fq 6 s_question_6 "//s_texte_question_6//"
fq 7 s_question_7 "//s_texte_question_7//"
fq 8 s_question_8 "//s_texte_question_8//"
fq 9 s_question_9 "//s_texte_question_9//"
fq 10 s_question_10 "//s_texte_question_10//"
fq 11 s_question_11 "//s_texte_question_11//"
fq 12 s_question_12 "//s_texte_question_12//"
fq 13 s_question_13 "//s_texte_question_13//"
fq 14 s_question_14 "//s_texte_question_14//"
fq 15 s_question_15 "//s_texte_question_15//"
fq 16 s_question_16 "//s_texte_question_16//"
fq 17 s_question_17 "//s_texte_question_17//"
fq 18 s_question_18 "//s_texte_question_18//"
fq 19 s_question_19 "//s_texte_question_19//"
fq 20 Var_20_question "//s_texte_question_20//"
#
#fq 25 Var_20_question "Numero de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"
# Nombre de questions jusqu'a  25 maxi

# ICI Questions avec valeurs numériques
fmt 2 Var_1_question
#
fmt 4 Var_16_question
fmt 4 Var_17_question
fmt 2 Var_20_question
Var_1_question : -1
Var_20_question : 1
#...

p_questions_entete
    # A enrichir si besoin --> apres Q13
    if s_texte_question_1 <> svide2, q1
    if s_texte_question_2 <> svide2, q2
    if s_texte_question_3 <> svide2, q3
    if s_texte_question_4 <> svide2, q4
    if s_texte_question_5 <> svide2, q5
    if s_texte_question_6 <> svide2, q6
    if s_texte_question_7 <> svide2, q7
    if s_texte_question_8 <> svide2, q8
    if s_texte_question_9 <> svide2, q9
    if s_texte_question_10 <> svide2, q10
    if s_texte_question_11 <> svide2, q11
    if s_texte_question_12 <> svide2, q12
    if s_texte_question_13 <> svide2, q13
	#
	if palette = 1, if s_texte_question_16 <> svide2, q16
    if palette = 1, if s_texte_question_17 <> svide2, q17

    s_question_1 = ucase(s_question_1)
    s_question_2 = ucase(s_question_2)
    s_question_3 = ucase(s_question_3)
    s_question_4 = ucase(s_question_4)
    s_question_5 = ucase(s_question_5)
    s_question_6 = ucase(s_question_6)
    s_question_7 = ucase(s_question_7)
    s_question_8 = ucase(s_question_8)
    s_question_9 = ucase(s_question_9)
    s_question_10 = ucase(s_question_10)
    s_question_11 = ucase(s_question_11)
    s_question_12 = ucase(s_question_12)
    s_question_13 = ucase(s_question_13)
	#
	if palette = 1, s_question_16 = ucase(s_question_16)
    if palette = 1, s_question_17 = ucase(s_question_17)

    # Pour toute string a convertir en valeur numerique --> faire la meme chose pour d'autres si besoin
	#Var_1_question = rpar(s_question_19, 1)    # convertir la valeur texte en valeur numerique
    Var_20_question = rpar(s_question_20, 1)    # convertir la valeur texte en valeur numerique
	Var_16_question = rpar(s_question_16, 1)
	Var_17_question = rpar(s_question_17, 1)
    schange_nom_fichier = s_question_20    # dans le "Pbloc" --> "pnom_nc" peut-etre modifier le nom de la string --> test si fichier existant

    spathnc$ = ucase(spathnc$)
    stck_matl$ = ucase(stck_matl$)
    snamenc$ = ucase(snamenc$)

    spaces$ = 0
    #s_com_open, "DATE LE ", date$," A ", time$, s_com_close, e$
    #s_com_open, "DESSIN MASTERCAM - ", smcname$, s_com_close, e$
    #s_com_open, "NC FILE - ", *spathnc$, *snamenc$, *sextnc$, s_com_close, e$
    #s_com_open, "MATIERE - ", *stck_matl$, s_com_close, e$
    #s_com_open, "NOM DU PROGRAMME - ", sprogname$, s_com_close, e$
    #*e$
    spaces$ = 1
    if s_texte_question_1 <> s_question_1, n$, s_com_open, s_texte_question_1, "-", s_question_1, s_com_close, e$, longTexte = 1
    if s_texte_question_2 <> s_question_2, n$, s_com_open, s_texte_question_2, "-", s_question_2, s_com_close, e$, longTexte = 1
    if s_texte_question_3 <> s_question_3, n$, s_com_open, s_texte_question_3, "-", s_question_3, s_com_close, e$, longTexte = 1
    if s_texte_question_4 <> s_question_4, n$, s_com_open, s_texte_question_4, "-", s_question_4, s_com_close, e$, longTexte = 1
    if s_texte_question_5 <> s_question_5, n$, s_com_open, s_texte_question_5, "-", s_question_5, s_com_close, e$, longTexte = 1
    if s_texte_question_6 <> s_question_6, n$, s_com_open, s_texte_question_6, "-", s_question_6, s_com_close, e$, longTexte = 1
    if s_texte_question_7 <> s_question_7, n$, s_com_open, s_texte_question_7, "-", s_question_7, s_com_close, e$, longTexte = 1
    if s_texte_question_8 <> s_question_8, n$, s_com_open, s_texte_question_8, "-", s_question_8, s_com_close, e$, longTexte = 1
    if s_texte_question_9 <> s_question_9, n$, s_com_open, s_texte_question_9, "-", s_question_9, s_com_close, e$, longTexte = 1
    if s_texte_question_10 <> s_question_10, n$, s_com_open, s_texte_question_10, "-", s_question_10, s_com_close, e$, longTexte = 1
    if s_texte_question_11 <> s_question_11, n$, s_com_open, s_texte_question_11, "-", s_question_11, s_com_close, e$, longTexte = 1
    if s_texte_question_12 <> s_question_12, n$, s_com_open, s_texte_question_12, "-", s_question_12, s_com_close, e$, longTexte = 1
    if s_texte_question_13 <> s_question_13, n$, s_com_open, s_texte_question_13, "-", s_question_13, s_com_close, e$, longTexte = 1
    #n$, s_com_open, "*****************************", s_com_close, e$

#endregion
#region ANCIEN
#  ----------QUESTIONS------------------
sclient : ""
snumplan : ""
sindiceplan : ""
spiece : ""
sorx : ""
sory : ""
sorz : ""
sora : ""
sorc : ""
remplace : 1
#numerote : 0

fmt 2 remplace

sclient = ucase(sclient)
spiece = ucase(spiece)
snumplan = ucase(snumplan)
sindiceplan = ucase(sindiceplan)
sorx = ucase(sorx)
sory = ucase(sory)
sorz = ucase(sorz)
sora = ucase(sora)
sorc = ucase(sorc)

# question qui sert a dire qu'un plan d'usinage est mal orientE
#fq 1 
#fq 2 sclient "CLIENT"
#fq 3 snumplan "NUMERO DE PLAN"
#fq 4 spiece "PIECE"
#fq 5 sorx "Origine en X"
#fq 6 sory "Origine en Y"
#fq 7 sorz "Origine en Z"
#fq 8 sora "Origine en A"
#fq 9 sorc "Origine en C"
#fq 10 schange_nom_fichier "Numero de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"	# progno
##fq 10 numerote NUMEROTER LES LIGNES DU PROGRAMME ?            				0 pour NON - 1 pour OUI
#fq 11 remplace "Numero de programme //snouv_nom// existant, LE REMPLACER ?     0 pour NON - 1 pour OUI"
#fq 12 schemincn "ENTRER LE NOM DU REPERTOIRE DEFINITIF DU PROGRAMME ?"
#fq 13 sindiceplan "INDICE DU PLAN"
#fq 18 axeB "ATTENTION, ANGLE SUR A EN VERTICAL DOIT SE TROUVER ENTRE //mini_b// ET //maxi_b// EN //op_id$// LIGNE //n$//"

p_entete_questions_3
	q2, q4, q3, q13, q5, q6, q7, q8, q9
	n$, " ; PAR : xxx ", e$
	n$, " ; CLIENT  :", sclient, e$
	n$, " ; PIECE   :", spiece, e$
	n$, " ; NUMERO  :", snumplan, e$
	n$, " ; INDICE PLAN  :", sindiceplan, e$
	n$, " ; ORIGINE :", e$
	n$, " ; X :", sorx, e$
	n$, " ; Y :", sory, e$
	n$, " ; Z :", sorz, e$
	n$, " ; A :", sora, e$
	n$, " ; C :", sorc, e$
	n$, " ; ORIENTATION PIECE", e$
	n$, " ;                               ", e$
	n$, " ; *****************************", e$
	n$, " ;                               ", e$
#endregion
#endregion

#region block_form
p_block_form
	if stock_shape <> zero & stock_shape <> one, result = mprint(s_erreur_stock_shape)  #Only Rectangular and Cylindrical are supported
	if block_form & stock_shape = zero,	#RECTANGULAIRE
        [
        # Build & output the WORKPIECE line - "WORKPIECE(,"",,"BOX", par2, ztop, zbottom, -80, Xll, Yll, Xur, Yur)"
        # Absolute stock values in Siemens (all values in "Blank" settings are Absolute)
		if stck_crnr$ = 0,  # Top of stock, Center
          [
          stck_ll_x = stck_x$ - (stck_ht$ / two)
          stck_ll_y = stck_y$ - (stck_wdth$ / two)
          stck_ur_x = stck_x$ + (stck_ht$ / two)
          stck_ur_y = stck_y$ + (stck_wdth$ / two)
          topz = stck_z$
          bottomz = stck_z$ - stck_thck$
          ]
        if stck_crnr$ = 1,  # Top of stock, Upper Left corner
          [
          stck_ll_x = stck_x$
          stck_ll_y = stck_y$ - stck_wdth$
          stck_ur_x = stck_x$ + stck_ht$
          stck_ur_y = stck_y$
          topz = stck_z$
          bottomz = stck_z$ - stck_thck$
          ]
        if stck_crnr$ = 2,  # Bottom of stock, Upper Right corner
          [
          stck_ll_x = stck_x$ - stck_ht$
          stck_ll_y = stck_y$ - stck_wdth$
          stck_ur_x = stck_x$
          stck_ur_y = stck_y$
          topz = stck_z$
          bottomz = stck_z$ - stck_thck$
          ]
        if stck_crnr$ = 3,  # Top of stock, Lower Right corner
          [
          stck_ll_x = stck_x$ - stck_ht$
          stck_ll_y = stck_y$
          stck_ur_x = stck_x$
          stck_ur_y = stck_y$ + stck_wdth$
          topz = stck_z$
          bottomz = stck_z$ - stck_thck$
          ]
        if stck_crnr$ = 4,  # Top of stock, Lower Left corner
          [
          stck_ll_x = stck_x$
          stck_ll_y = stck_y$
          stck_ur_x = stck_x$ + stck_ht$
          stck_ur_y = stck_y$ + stck_wdth$
          topz = stck_z$
          bottomz = stck_z$ - stck_thck$
          ]
        if stck_crnr$ = 5,  # Bottom of stock, Upper Left corner
          [
          stck_ll_x = stck_x$
          stck_ll_y = stck_y$ - stck_wdth$
          stck_ur_x = stck_x$ + stck_ht$
          stck_ur_y = stck_y$
          topz = stck_z$ + stck_thck$
          bottomz = stck_z$
          ]
        if stck_crnr$ = 6,  # Bottom of stock, Upper Right corner
          [
          stck_ll_x = stck_x$ - stck_ht$
          stck_ll_y = stck_y$ - stck_wdth$
          stck_ur_x = stck_x$
          stck_ur_y = stck_y$
          topz = stck_z$ + stck_thck$
          bottomz = stck_z$
          ]
        if stck_crnr$ = 7,  # Bottom of stock, Lower Right corner
          [
          stck_ll_x = stck_x$ - stck_ht$
          stck_ll_y = stck_y$
          stck_ur_x = stck_x$
          stck_ur_y = stck_y$ + stck_wdth$
          topz = stck_z$ + stck_thck$
          bottomz = stck_z$
          ]
        if stck_crnr$ = 8,  # Bottom of stock, Lower Left corner
          [
          stck_ll_x = stck_x$
          stck_ll_y = stck_y$
          stck_ur_x = stck_x$ + stck_ht$
          stck_ur_y = stck_y$ + stck_wdth$
          topz = stck_z$ + stck_thck$
          bottomz = stck_z$
          ]
        # Output WORKPIECE line using values determined above / Define the stock for graphics - Block / Box
        if stck_ll_x = 0 & stck_ll_y = 0 & stck_ur_x = 0 & stck_ur_y = 0 & topz = 0 & bottomz = 0,
			n$, s_com_open, "BRUT NON DEFINI", s_com_close, e$
		else, [	
			n$, 'WORKPIECE(,', no_spc$, '"', no_spc$, srot_label, no_spc$, '"', no_spc$,
	          ',,"BOX",112,', no_spc$, *topz, no_spc$, ',', no_spc$, *bottomz, no_spc$, ',-80,', no_spc$, *stck_ll_x, no_spc$, ',', no_spc$,
	          *stck_ll_y, no_spc$, ',', no_spc$, *stck_ur_x, no_spc$, ',', no_spc$, *stck_ur_y, no_spc$, ')', e$
	        ]
		]
		
      if block_form & stock_shape = one,  # Cylinder
        [
		if stock_cyl_axis >= 0,  # Cylinder about Z or cylinder about same axis as rotary centerline
          [
          # Build & output the WORKPIECE line - "WORKPIECE(,"",,"CYLINDER", par2, ztop, zbottom, -80, diameter)"
          # Absolute stock length dim in Siemens
          if stock_cyl_axis = 0,  # Stock about X-axis
            [
            topz = stck_x$ + stck_wdth$  #Define X+ end of stock
            bottomz = stck_x$            #Define X- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          if stock_cyl_axis = 1,  # Stock about Y-axis
            [
            topz = stck_y$ + stck_wdth$  #Define Y+ end of stock
            bottomz = stck_y$            #Define Y- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          if stock_cyl_axis = 2,  # Stock about Z-axis
            [
            topz = stck_z$ + stck_wdth$  #Define Z+ end of stock
            bottomz = stck_z$            #Define Z- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          # Output WORKPIECE line using values determined above / Define the stock for graphics - Cylinder
		  #
		  #
		  #stck_cyl_dia = stck_cyl_dia / 2 # Ici valeur au rayon
		  #if stock_cyl_axis = 0, s_axe_brut_cyl = "X"
		  #if stock_cyl_axis = 1, s_axe_brut_cyl = "Y" 
		  #if stock_cyl_axis = 2, s_axe_brut_cyl = "Z" 
		  #p_bloc_O, n$, "BLK FORM CYLINDER", [if rot_on_x, s_axe_brut_cyl, else, '""'], *stck_cyl_dia, *topz, *bottomz, *stck_cyl_dia_inter, e$ # Z R50 L105 DIST+5 R110 = AXE DE BROCHE, RAYON, LONGUEUR, "DIST", RAYON INTER
          # 
		  # OK CYLINDRIQUE SUR AXE C
		  spaces$ = 0
		  stck_thck$ = stck_thck$ * -1
		  # BOX SUR PLATEAU CIRCULAIRE "C"
		  #64-->RELATIF 112-->ABSOLU
		  n$, "WORKPIECE(,", 34, "C", 34, ",,", 34, *stck_type, 34,",64,", *zmax,",", *stck_thck$, ",80,", *xmin, ",", *ymin, ",", *stck_ht$, ",", *stck_wdth$, ")", e$ # 0-->80
	      spaces$ = 1   
		  #ORIGINAL CNC
		  n$, 'WORKPIECE(,', no_spc$, '"', no_spc$, srot_label, no_spc$, '"', no_spc$, ',,"CYLINDER",64,',
            no_spc$, *topz, no_spc$, ',', no_spc$, *bottomz, no_spc$, ',-80,', no_spc$, *stck_cyl_dia, no_spc$, ')', e$
		  ]
        ]
	if block_form & stock_shape = two, n$, "; Brut solide-Maillage utilisé dans MasterCam", e$		# Solide-Maillage
    if block_form & stock_shape = three, n$, "; Brut depuis fichier STL utilisé dans MasterCam", e$	# Stl					
#endregion

#region corps_Pheader_a_Peof

#region pheader
p_Type_appel_outil
	if Type_appel_outil	= 1, [
		nom_outil = 0    		# Affiche le NOM de l'outil
		outils_param = 0    	# pour Valider / dévalider l'affichage des outils en parametres
		]
	if Type_appel_outil	= 2, [
		nom_outil = 1
		outils_param = 0
		]	
	if Type_appel_outil	= 3, [
		nom_outil = 0
		outils_param = 1
		]	
		
pheader$     # ENTETE DE PROGRAMME
	if Mode_reglage_PP = 0, [
		n$, *axis_label, *srot_label, *rot_zero, *rot_dir, *rot_index, *rot_angle, *rot_type, *min_speed, 
			*maxfrinv_m, *maxfrdeg, *maxfeedpm_m, *all_cool_off, *v9_coolant, e$
		]	
	spaces$ = 1
	sguillemet = no2asc(34) 
	debut = 1                                           # flag pour debut de prog
	entete_ = 1  
	p_affiche_infos_config_armoire 
	p_Type_appel_outil
	p_modif_tiret	# transforme le "-" en "_"
	if utilise_palette = 1 | utilise_palette = 11, palette = 1
	if change_nom = 1,  
	    [
	    pnom_nc
	    ptest_nom
	    snomprogentete = ucase (snomprogentete)
	    ]
	if affiche_chemin = 1,
	    [
	    if Mode_reglage_PP = 0,
	        [
	        "*********** ", e$
	        "affichage pour rEglage PP ", e$
	        n$, "snom_nc", snom_nc, e$ 
	        n$, "snouv_nom", snouv_nom, e$
	        n$, "spathnc", spathnc$, e$
	        n$, sdebut, e$
	        n$, snouvnom, e$
	        n$, smachine, e$
	        n$, spoint, e$
	        #n$, sextnc$, " posiTous_clients", *posiTous_clients, e$
	        n$, "xx ", *positiret, e$
	        n$, "222 ", stiretbas, *positiret2, e$
	        "*********** ", e$
	        ]
		if nom_repert = 1, "%_N_", snouvnom, "MPF", e$ 							#progname
		if nom_repert = 0 & change_nom = 1, ";%_N_", snouvnom, "MPF", e$    
		if nom_repert = 0 & change_nom = 0, "%_N_", snomprogentete, "MPF", e$  
		pchemin
		if nom_repert = 1, ";$PATH=/_N_WKS_DIR/_N_", schemincn, "WPD", e$ 
		if nom_repert = 0 & change_nom = 1, ";$PATH=/_N_WKS_DIR/_N_", snouvnom, ".WPD", e$  
		if nom_repert = 0 & change_nom = 0, ";$PATH=/_N_WKS_DIR/_N_", snomprogentete, ".WPD", e$  
		n$ " ; ", *snom_entete, e$
		]
	else, ";", snouvnom, e$   
	if type_pp_SIEMENS = 1 & Cycles_palpage_YN = 1, n$, " DEF INT V_SPEED=5000 ;POUR LES CYCLES DE PALPAGE", e$
	#n$, " EXTERN COR_D3_SUREP(REAL,REAL)", e$
	spaces$ = 1
	n$, s_com_open, "*************************************", s_com_close, e$
	s_nom_machine_entete = ucase (s_nom_machine_entete)
	n$, s_com_open, "MASTERCAM BY FICAM - POST V:", no_spc$, scustpost_revision, s_com_close, e$
	n$, s_com_open, "MACHINE:", s_nom_machine_entete, s_com_close, e$
	if rotation_A = 1 & diviseur = 1, n$, s_com_open, "EQUIPEE D UN AXE :", s_axe_rot_A, s_com_close, e$
	if rotation_B = 1 & diviseur = 2, n$, s_com_open, "EQUIPEE D UN AXE :", s_axe_rot_B, s_com_close, e$
	n$, s_com_open, "PROGRAMME CREE LE ", date$, " A ", time$, s_com_close, e$
	if nom_programmeur_PC <> 0, [
		s_nom_ORDI = sysinfo(result, 2)
		posi_nom_programmeur = strstr(s_slash, s_nom_ORDI)
		posi_nom_programmeur = posi_nom_programmeur + 1
		s_nom_programmeur = brksps(posi_nom_programmeur, s_nom_ORDI)
		posi_nom_programmeur = posi_nom_programmeur - 2
		s_nom_ORDI2 = brksps(posi_nom_programmeur, s_nom_ORDI)
		s_nom_ORDI = ucase (s_nom_ORDI)
		s_nom_programmeur = ucase (s_nom_programmeur)
		if nom_programmeur_PC <> 1, n$, s_com_open, "NOM DE L'ORDINATEUR :", *s_nom_ORDI, s_com_close, e$
		if nom_programmeur_PC <> 2, n$, s_com_open, "NOM DU PROGRAMMEUR :", *s_nom_programmeur, s_com_close, e$		
		]
	n$, s_com_open, "*************************************", s_com_close, e$
	n$, s_com_open, "FICHIER MC: ", *smcname$, no_spc$, *smcext$, s_com_close, e$
    n$, s_com_open, "FICHIER ISO: ", *snamenc$, no_spc$, *sextnc$, s_com_close, e$
	if entete_questions = 2, p_questions_entete 	# nouvelles questions d'entête
	if entete_questions = 3, p_entete_questions_3	# ANCIEN SYSTEME questions                  	
	if entete_questions = 1, 	[
		if entete_ = 1 & longTexte = 0, 	[
			n$, "( ***************************** )", e$
			n$, "( *****OP POUR MODIF***** )", e$
			]
		]  
	if tooltable$ <> 0, *e$, n$, "; *LISTE D OUTILS*",e$
	entete_ = 0 

#endregion

#region psof_debut
p_palette_debut
	if utilise_palette > 0, [	# PALETTES
	 	if useaxe = 1, [		# VALEURS UNIQUEMENT SI ON UTILISE L AXE A
			if deg_palette_deb_fin > 0, [
				old_degageX    	= degageX
				old_degageY    	= degageY
				old_degageZ    	= degageZ			
				degageX    		= degageX_pal
				degageY    		= degageY_pal
				degageZ    		= degageZ_pal
				deg_debut 		= deg_palette_deb_fin
				p_degage_debut
				degageX    		= old_degageX
				degageY    		= old_degageY
				degageZ    		= old_degageZ				
				]
			n$, "T0 M6", s_com_open, "DECHARGE DE L'OUTIL EN BROCHE", s_com_close, e$
			n$, s_com_open, "POUR ROTATION PALETTE AVEC L AXE -A-B-", s_com_close, e$
			]
		if Var_16_question > 0, n$, "M127", s_com_open, "ROTATION PALETTE A", s_com_close, e$
		if Var_17_question > 0, n$, "M128", s_com_open, "ROTATION PALETTE B", s_com_close, e$
		n$, "M44", s_com_open, "RIDEAUX EAU ON", s_com_close, e$
		n$, "G90 G17 G40 G0 G94", e$
		]		
		
psof0$       # DEBUT DE PROGRAMME pour T=0
	psof$

psof$        # DEBUT DE PROGRAMME T<>0
	p_restriction_PP
	P_f_val_origine_depart_idem 
	perreur_pas_fil  
	if rotation_axe = 2, result = mprint(serreur2)
    if Mode_reglage_PP = 0, [
        "--> A:", *rotation_A, " B:", *rotation_B, " rotation gEnErale", *rotation_axe, " div:" *diviseur, e$
        " syncax", *syncaxis$, " old_sync", *old_syncaxis, " nbr_combi", *nbr_combi, " compt_axes_rot", *compt_axes_rot, e$
		" M1", *m1$, " M5", *m5$, " M7", *m7$, " M8", *m8$, " M9", *m9$, e$
        ]
	if lire_def_machine = 0 , [     # affecter les valeurs suivant inclinaisons du programme
        if rotation_A = 1, [
            if diviseur = 2, p_erreur_choix_axe
            diviseur = 1, useaxe = 1
            ]
        if rotation_B = 1, [
            if diviseur = 1, p_erreur_choix_axe
            diviseur = 2, useaxe = 1
            ]
       ]
	if rotation_A =1 | rotation_B =1 & rotation_axe = 1, useaxe = 1
		else, useaxe = 0
	if lire_def_machine = 1, [
		if diviseur = 1 & rotation_B = 1, result = mprint(serreur3)	# erreur: rotation sur B avec du A
		if diviseur = 2 & rotation_A = 1, result = mprint(serreur4) # erreur: rotation sur A avec du B
		]
	if lire_def_machine = 0, [
		if rotation_A = 1, result = nwadrs(s_axe_rot_A, axeA)
		if rotation_B = 1, result = nwadrs(s_axe_rot_B, axeA)
		]	
	#*e$
	# TEMPS
	info_temps = 2, p_temps_affectation
	if Affiche_temps_dll = 1, [ 	# TEMPS DE L OUTIL			
		if Types_Temps_DLL = 2, [
			p_Convert_time_dll 
			n$, "  ", s_com_open, "TPS OUT. = ", *Heure, *min, *sec, s_com_close, e$
			]	
		]	
	info_temps = 3, p_temps_affectation
	if Affiche_temps_dll = 1 & Types_Temps_DLL = 3, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS BRUT TOTAL MC ", *Heure, *min, *sec, s_com_close, e$	
		]
	time_total = 0
	Tot_time_Out = 0
	#
	spaces$ = 1
	if affiche_ori_entete = 1, mergesub$							# ICI les origines utilisés par MC (depuis pwrtt$)
	if affiche_ori_entete = 11 & old_workofs <> 54, mergesub$		# ICI les origines utilisés par MC (depuis pwrtt$)	
	if affiche_ori_entete = 1 | affiche_ori_entete = 11, clearsub$	# Sup. des origines dans la mémoire
	if block_form, *e$, p_block_form
	# ICI descripteur si actif dans la machine et config PP
	comment$ 
	debut = 0
	#
	ptravel
	pwritbuf5
	if output_z = 1, n$, s_com_open, "TRAVAIL MAX PIECE ", *z_tmax, s_com_close, e$
    if output_z = 1, n$, s_com_open, "TRAVAIL MIN PIECE ", *z_tmin, s_com_close, e$
	if tool_op$ = 114, cant_no$ = 0 #tool_op$ 114 = perCage AVANCE 	# pour ne pas afficher un arrosage erroné au debut
	*e$
	gcode$ = 0
	plane$ = 3                  									# pour focer le rappel G17 G18 G19
    !plane$
	n$, "G90 G17 G40 G0 G94", e$
	if convoyeur = 1, n$, s_convoyeur_ON, e$
	p_affiche_options(1)
	avance = fr_pos$
	p_palette_debut # PALETTES
	p_vit_rot_max 
	if utilise_prog_reg_usi = 1, [
		if type_pp_SIEMENS = 1, n$, "R99==1 ; 1= PIECE DE REGLAGE", e$
		#if type_pp_SIEMENS = 2, n$, "(R99==1) ; 1= PIECE DE REGLAGE", e$
		n$, "; BLOCAGE DES G0 A 20 POUR CENT MAXI", e$
		if type_pp_SIEMENS = 1, n$, "IF R99==1", e$
		if type_pp_SIEMENS = 2, n$, "IF (R99==1)", e$
		n$, "REDUCTION_GO ; APPEL DU SOUS-PROG.", e$
		n$, "ENDIF", e$
		]
	p_affiche_options(2)
	*e$
	p_degage_entete_variables
	p_degage_debut
	comment$ 
	p_affiche_outil
	#temps DLL
	Tot_time_op = 0	#remise à 0 entre l'entete et OPs
	Types_Temps_DLL = plcval (s_Types_Temps_DLL, 4)
	p_temps_dll	# lecture du temps de l'OP dans la DLL
    #
	# pour la gestion d'outil FIN
	first_tool = t$
	s_first_stoolname = strtool$
	#
	if nextop$ = 11, p_ori_usi
	n$, "D1 ; Activation du bloc tranchant outil", e$
	if tool_op$ = 114, cant_no$ = 0 #tool_op$ 114 = perCage AVANCE #pour ne pas afficher un arrosage erroné au debut
	p_placement_apres_chang_outil                   		# AFFICHAGE DES MOUVEMENTS MACHINE
	if palpeur = 1 & nextop$ <> 11,	[
		gcode$ = 1
		n$, "DEF INT V_SPEED=5000", e$
	    n$, "M81 ; soufflage ON", e$
	    n$, *sgcode, "MEAS=1", *xr$, *yr$, "F=V_SPEED", e$
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
		n$, *sgcode, "MEAS=1", *zr$,  e$           
	    #n$, *sgcode, "MEAS=1", "Z", *refht$, e$    # *tosz$, refht$, *depth$
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    ]
	comment$
	# Z de départ perçage 5 axes
	if opcode$ = 16 & diviseur = 1, old_z = ynci$  
	if opcode$ = 16 & diviseur = 2, old_z = xnci$ 
	#if palpeur = 1, n$, "M80 ; soufflage OFF", e$ 
	p_test_arcs_tete_renvoi 
	if opcode$ = 16, drill_4_axes = 1  
	incremental = 0                 					# Travail en Absolue 
	old_op_id = op_id$
	old_ssa = ssa
	p_erreur_choix_axe_substitution
	c_mmlt$     # Multiple tool subprogram call
	c_msng$		# Single tool subprogram call
#endregion

#region ajout prEparation outils en NOM
# Tool Preselect variables
next_tlchg_gcode   	: 0
is_next_tlchg_phys 	: no$
sinvalid           	= "-99999"
s_first_stoolname 	: ""
read_counter 		: 0     #Used as a counter in pstagetool
first_op_id  		: 0     #op_id$ for first operation
#strings
stoolname    		: ""    #Return string for functions
#sblank       		: ""
s_plus_outil 		: "-99999"
first_tool 			: -1
stoolname_err      	: "ERREUR - Tool call format set to output tool name, and tool name is blank." + no2asc(13) + no2asc(13) +
                       "See tool_as_name in pst to set tool call format and tool definition in operation to set tool name."
#endregion

#region outil_suivant
pstagetool      #Pre-stage tools    # en plus pour afficher le NOM DE L'OUTIL SUIVANT 
      if bldnxtool$ = 1, [
        if nom_outil = 1,  #Tool call uses tool name
          [  
          if ttblend$,  #If this is the last toolchange of the program
            [
            if type_prep_outil = 1,  #stage first tool at last toolchange
              [
              first_op_id = streaminfo(1, 1)             #Get the operation ID for the first operation in the sequence
              stoolname = opinfo(10094, first_op_id, 1)  #Get the tool name for the first operation
              if stoolname = sblank, stoolname = "ERROR-BLANK_NAME"
			  spaces$ = 0
              n$, 'T="', stoolname, no_spc$, '"', e$  #Stage first tool
			  spaces$ = 1
              ]
            ]   
          #else,  #stage tool at every toolchange
            #[
            next_tlchg_gcode = opinfo(92, 1)
            if next_tlchg_gcode = 1002, stoolname = opinfo(10094, 1)
            else,
              [
            read_counter = 1
              is_next_tlchg_phys = no$
              while is_next_tlchg_phys = no$,
              [
              read_counter = read_counter + 1
                next_tlchg_gcode = opinfo(92, read_counter)
                if next_tlchg_gcode = 1000, is_next_tlchg_phys = no$
                else,
                  [
                  stoolname = opinfo(10094, read_counter)
                  is_next_tlchg_phys = yes$
                  ]
                ]
              ]
            if stoolname = sblank, stoolname = "ERREUR-NOM OUTIL VIDE"
			spaces$ = 0
            if stoolname <> s_plus_outil, n$, 'T="', stoolname, no_spc$, '"', ";PREP OUTIL SUIVANT", e$  #Stage first tool
			spaces$ = 1
            #]
          ]
        ]

p_info_outils
	strtool$ = ucase(strtool$)
	spaces$ = 1
	if Type_infos_outil	= 1, n$, sdcom_MSG, 34, strtool$, 34, sfcom_MSG, e$
	if Type_infos_outil	= 2, n$, sdcom_MSG, 34, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, 34, sfcom_MSG, e$ 
	if Type_infos_outil	= 3, n$, sdcom_MSG, 34, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, 34, sfcom_MSG, e$
	if Type_infos_outil	= 4, n$, sdcom_MSG, 34, strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, 34, sfcom_MSG, e$
    posi_MORTAIS = strstr(s_mortais, strtool$)  

p_dec_outil	# "D"
	if type_dec_outil = 1, dec_outil = 1, *dec_outil
	if type_dec_outil = 2, dec_outil = tloffno$, *tloffno$
	if type_dec_outil = 3, [
		if tloffno$ = t$, dec_outil = 1, *dec_outil
		if tloffno$ <> t$, dec_outil = tloffno$, *dec_outil
		]
		
p_affiche_outil    # ecriture de l'appel outil pour psof et ptlchg
    num = num + 1                           							# Nom du groupe d'operation
    P_f_val_origine_depart_idem 			
    p_erreur_dif_T_H_D 						
    perreur_pas_fil 						
	OLD_tolerance_usinage = -1
	if Test_bris_outils = 1 & (mi6$ = 1 | mi6$ = 3), p_test_bris_outil 
    if tool_typ$ = 5, ss$ = (abs(ss$))*-1   							# si taraud à gauche inverser le sens de broche
    ssa = abs(ss$)
	if ra_type$ = 1 & ra_block$ >0 & ssa > S_maxi_renvoi_angle, result = mprint(s_erreur_S_maxi_renvoi_angle), ssa = S_maxi_renvoi_angle
	if nextdc$ = 19, posi_p_prof = 1, p_rot_perc_profond  # ROT BROCHE POUR PERCAGE PROFOND	
	if program_stop = 1, pcan1, n$, sm00, e$
    if program_stop = 2, pcan1, n$, sm01, e$
	*e$
	pnomgroupe
	p_num_op_MC
	p_affiche_type_op_MC  						
	if sauve_ra_tc_type_ = 2 & sauve_ra_block_ = 2, n$, "M0", s_com_open, "VEUILLEZ RETIRER L'OUTIL MANUELLEMENT", s_com_close, e$, sauve_ra_block_ = -1		
	if nextdc$ >= 8 & nextdc$ < 18, palpeur = 1
	    else, palpeur = 0		
	comment$
	#pcan
    if Position_info_outil = 1, p_info_outils
    strtool$ = ucase (strtool$)             						# convertir en MAJUSCULES le nom outil                  
	if ra_tc_type$ <> 2, [	#pas de renvois d'angle et mode de changemnt automatique	
		if nom_outil = 1,	[
	        if strtool$ = sblank,    [
				result = mprint(stoolname_err)
				'T="', no_spc$, "ERREUR-NOM OUTIL VIDE", no_spc$, '"'
	            ]
	        spaces$ = 0
			if palpeur = 1, num, " T=",34,"PALPEUR_3D",34, "D1", e$
			if palpeur = 0, num, " T=",34, strtool$, 34, e$ 
			spaces$ = 1
			n$, "M6", e$
			if rpd_typ$ <> 7 & bldnxtool$ = 1, [	#pstagetool
				if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, pstagetool
				]
	        ]			
	    if outils_param = 0 & nom_outil = 0, [  # sans les parametres
			outil = t$
			outil_suivant = next_tool$
			if palpeur = 1, n$, *outil, [if type_pp_SIEMENS = 1, "D1"], "M6", e$
	    	if palpeur = 0, num, *outil, "M6", e$			
	    	if rpd_typ$ <> 7 & bldnxtool$ = 1, [ 
				#(ra_type$ = 0 & outil_suivant < 61 & outil_suivant > 63), n$, *outil_suivant, e$
				if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, n$, *outil_suivant, e$
				]	
	        ]
	    if outils_param = 1 & nom_outil = 0,  [ # avec les parametres
			outil_param = t$
		    outil_suiv_param = next_tool$
		    outil_param = outil_param + 500
		    outil_suiv_param = outil_suiv_param +500
			if palpeur = 1, num, "T=", no_spc$, *outil_param, "M6", "D1", e$
		    if palpeur = 0, num, "T=", no_spc$, *outil_param, "M6", e$
		    if rpd_typ$ <> 7 & bldnxtool$ = 1, [
				#(ra_type$ = 0 & next_tool$ < 61 & next_tool$ > 63), n$, "T", no_spc$, 35, *outil_suiv_param, e$
				if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, n$, "T", no_spc$, 35, *outil_suiv_param, e$
				]
            ]
		]
	if ra_tc_type$ = 2, [	#renvois d'angle à changement manuel
		n$, s_com_open, "OUTIL A RENVOIE D ANGLE A CHARGER MANUELLEMENT", s_com_close, e$
		n$, "M0", e$ 
		n$, s_com_open, "OUTIL NUMERO : ", *t$, s_com_close, e$
		]	
	if program_stop = 11, pcan1, n$, sm00, e$
    if program_stop = 22, pcan1, n$, sm01, e$
	p_debut_renvoi_angle
	if Position_info_outil = 2, p_info_outils
	if deg_apres_outil > 0, [
		old_type_deg = deg_outil		# Memo Valeur
		deg_outil = deg_apres_outil		# Affectation pour Valeur deg. apres outil
		p_degage_ptlchg					# Retour suivant Valeur deg. apres outil
		deg_apres_outil = old_type_deg	# Réaffectation de la valeur de base
		]
	p_Z_mini_maxi_OP
	spaces$ = 1
	pfrvar
	param_comp                        	# afficher le type de compensation
	param_surep                       	# afficher les surepaisseurs
	pcan
	if palpeur = 1, [                    								
		n$, "M5 M9", e$ 
	    palpage = 1
	    ]
	comment$                                 
	debut = 0
	gcode$ = 5
	!gcode$
	if nextdc$ < 8 | nextdc$ > 18, 
		n$, *ssa, *spdlon, e$ 	# ROT BROCHE SAUF BROSSE, PALPAGES & PERCAGE PROFOND
	if palpeur = 0, perreur_vit_broche
	if ssa = 0 & (mi3$ <> old_mi3),	[
	    n$, *mi3$, " ; Orientation broche en deg", e$   
	    old_mi3 = mi3$
	    ]
	p_affiche_options(3)
	#if Type_lissage = 3, p_affiche_options(12)	# au perçage 
	p_lissage
	if palpeur = 1,	[
	    n$, "M69 ;Validation du palpeur", e$
	    n$, "SPOS=0 ; Orientation du palpeur A 0 deg", e$
	   ]
	sauve_ra_tc_type_ = ra_tc_type$ 
	sauve_ra_block_ = ra_block$
	old_t = t$
#endregion

#region placement_apres_chang_outil
p_placement_apres_chang_outil   		# AFFICHAGE DES MOUVEMENTS MACHINE
	if Mode_reglage_PP = 0, "--> p_placement_apres_chang_outil", e$
    @rotaxis$                   		# mise a jour du type de substitution d'axe
    old_workofs = -999					# Force l'affichage du décallage après le changement d'outil
	if nextop$ = 11,    [       		# si 4 axes avec fonction 5 axes ET ****perçage 5 axes****
        gcode$ = 0              		# Force le gcode a 0 pour faire un G0 apres
        x$ = xr$
        y$ = yr$
        z$ = zr$ 
        axeA = 0
        axeA1_dep = 0
        old_axeA1 = 0
        debutpmx = 1            		# flag pour faire l'appel outil
        ]
    
	# en plus par rapport au pp Fanuc !!?? ---> ne passe pas dans le pmx$ ????
	if opcode$ = 16,    [       		# perçage 5 axes      
		#p_debut_pmx
        ]
	
	if nextop$ <> 11,   [   			# utilisation en positionné ou substitution
        gcode$ = 0                      # Force le gcode a 0 pour faire un G0 apres
        x$ = xr$                        # prise en compte de XYZ
        y$ = yr$
        z$ = zr$
        xabs = x$
        yabs = y$
        zabs = z$
		n$, p_lubrif_ON, e$ 
		if ra_block$ >0, p_calcul_xyz_tete_renvoie 					# RENVOIE D'ANGLE
        if rotaxis$ = 0,    [    # XYZ CLASIQUE       				# 3 axes + diviser en positionne
            p_calcul_rot_posit                                   	# calcul rotation plateau
            old_axeA = -99999                       				# pour forcer l'affichage
			p_ori_usi
            n$, *sgcode, *sinc_abs, "G17", *xabs, *yabs, e$ 
            p_rot_ptlchg                                   			# affichage de l'angle au chg outil
			n$, *sgcode, *zabs, e$ 
            ]
        if rotaxis$ <> 0,   [           							# utilisation en substitution
            p_calcul_rot_posit										#CALCUL PLAN A AJOUTER/ENLEVER
			#plinarc  
			p_calcul_AB_pos_Subs               
            if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0                  				# diviseur tourne autour de Y (X sbstitue)
            if rotaxis$ = -2 | rotaxis$ = 2, yabs = 0                  				# diviseur tourne autour de X (Y sbstitue)
			p_ori_usi
			if mi7$ = 1, bloque = 2, n$, sbloque, e$				# déblocage de l'axe A/B  
			n$, *sgcode, *axeAB_subs, e$
            if mi7$ = 1, bloque = 1, n$, sbloque, e$     			# bloquer l'axe A/B
			n$, *sinc_abs, *xabs, *yabs, e$ 						
            n$, *zabs, e$ 		
            ]
        p_modal  
		!x$, !y$, !z$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc, !axeA, !axeAi  # mise à jour des positions affichées
        ]
    if tool_op$ = 100, n$, s_com_open, "PAS DU FILETAGE = ", *pas_filetage, s_com_close, e$ 		# affichage de la valeur du vrai filetage
	perreur_vit_broche
    old_ssa = ss$               # memo de la vitesse de broche
    old_op_id = op_id$          # memo du numero d'operation
    old_rotaxis = rotaxis$      # memo du type de substitution
    old_x = xabs                # memo X Y Z
    old_y = yabs
    old_z = zabs
	#if drillcyc$ = 0 & debutpmx = 1, pmx$	# !!!!! comprend pas pourquoi l'obliger sur le G81/G82
#endregion

#region Ptlchg0
ptlchg0$    
	if Mode_reglage_PP = 0, "--> ptlchg0_ ", *opcode$, *nextop$, *op_id$, e$
	Perreur_nom_RUD  
	perreur_pas_fil  
	avance = fr_pos$
	p_vit_rot_max
	drill_4_axes = 0    
	if debut = 1 & nextop$ <> 11,	[
		cc$ = 140
		if old_cc = 41 |old_cc = 42, n$, pcorrecteur_D, e$
		]
	if Test_bris_outils = 1, [
		pcool_off 
		n$, "M5", e$
		p_test_bris_outil
		pcan1_cool
		#if coolant$ = 0 | coolant$ = 1 & lub_centre = 0, n$, "M8", e$
		#if coolant$ = 2 , "M88" ,e$
		n$, *spdlon, *ssa, e$
		] 
	if op_id$ <> old_op_id, [	
		#temps DLL
		info_temps = 4, p_temps_affectation
	    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
			p_Convert_time_dll
			n$, s_com_open, "TEMPS DE L OPE. = ", *Heure, *min, *sec, s_com_close, e$
			]
		p_temps_dll
		#   
	    pnomgroupe                                  # Nom du groupe d'operation
	    p_num_op_MC
		p_affiche_type_op_MC
		param_comp                        			# afficher le type de compensation
		param_surep
		]
	affiche_m0 = 1
	comment$ 
	pspindchng 
	if op_id$ <> old_op_id, p_ori_usi
	pfrvar
	if ra_type$ = 1 & ra_block$ >0, [				# Renvoi d'ANGLE
		Angle_PLAN_MC_renvoie_angle = atan2(-m8$,-m7$)
		if Angle_PLAN_MC_renvoie_angle <> old_Angle_PLAN_MC_renvoie_angle, [
			if ra_rot_head$ = 1, result = mprint(s_erreur_angle_renvoi_fixe) 
			p_degage_4_axes
			n$, "TRANS X0 Y0 Z0", e$
			p_dec_renvoi_angle     					# 1 =renvoie d'angle actif et NUM choix du multibroche
			]
		]	
	if nextop$ <> 11, [                     		# utilisation en positionné ou substitution
        gcode$ = 0                  				# Force le gcode a 0 pour faire un G0 apres
        xabs = x$                   				# prise en compte de XYZ
        yabs = y$
        zabs = z$
        if rotaxis$ = 0, [          				# 3 axes + diviseur en positionné
            p_calcul_rot_posit                      # calcul rotation plateau
            p_ori_usi  								# affichage de l'origine d'usinage
            p_rot_tlchg0                       		# affichage de l'angle
			#n$, sg43, "H", *correcteur_H, *zabs, e$
        	]
        if rotaxis$ <> 0,  [      					# si on passe de positionné à SUBSTITUTION	 & old_rotaxis = 0
            p_calcul_rot_posit 
			#plinarc                                     					# Convertir les G2 G3 en G1
            p_calcul_AB_pos_Subs                                      		# calcul de l'axe A en substitution
            p_Apos_affiche_subs                              				# affichage de l'angle au chg outil nul pour continue/substitution
            n$, sgcode, sinc_abs, p_ori_usi, xabs, yabs, !xinc, !yinc, e$
            n$, sgcode, sinc_abs, zabs, !zinc, e$   
            p_modal                                 						# affectation en format modal
            !x$, !y$, !z$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc, !axeA, !axeAi  # mise à jour des positions affichées
            ]
        ]  	
	if nextop$ = 11, [   # si 5 axes
        if op_id$ <> old_op_id, [
	        old_axeA1 = 0
	        axeA1_dep = 0
	        debut = 0
	        ]
    	]
	perreur_vit_broche
	if ssa = 0 & (mi3$ <> old_mi3),	[
		n$, *mi3$, " ; Orientation broche en deg", e$   
		old_mi3 = mi3$
		]
	if opcode$ = 16, drill_4_axes = 1 
	if nextop$ <> 11 | op_id$ <> old_op_id, debut = 0
	#old_op_id = op_id$
	if nextop$ <> 11 & palpeur = 1, p_palpages_tlchg0  
	if op_id$ <> old_op_id, p_affiche_options(3)
	if op_id$ <> old_op_id, p_lissage
	old_op_id = op_id$
	c_mmlt$     # Multiple tool subprogram call
	c_msng$		# Single tool subprogram call
#endregion

#region Ptlchg
pspindle        #Spindle speed calculations for RPM
	ssa = abs(ss$)
	@old_ssa 
	if ssa, [
		if ssa > maxss$, ssa = maxss$
		if ssa < min_speed, ssa = min_speed
		]
	spdlsel = fsg3(spdir$) 
	
pspindchng      #Spindle speed change
	if prv_spdlsel <> spdlsel & old_ssa <> zero, p_bloc_O, n$, *sm01, e$
	ssa = abs(ss$)	# en négatif suite op de transformation ?? --> positif
	if old_ssa <> ssa | prv_spdlsel <> spdlsel, [
		if ssa <> 0, [
	 		n$, ssa, e$
			]	
		if spdlsel <> 1, n$, *spdlon, e$
		old_ssa = ssa
		]
	if tool_op$ <> 114, perreur_vit_broche
	!ssa, !spdlsel

ptoolend$        #End of tool path, before reading new tool data
	!ssa, !spdlsel
	Test_bris_outils = mi6$

pmiscint$        #Capture the top level absinc for subprograms
	cycle832_from_miscval = mi9$
	  	
ptlchg$      # Chang T<>prv_tool
	increment_op_outil = 1 
	affichage_cycle = 1 
	old_workofs = -999
	old_workofs_trans = -999
	if palpeur = 1,	[
	    n$, "M82 ; soufflage OFF", e$
	    n$, "M71 ;Desactivation du palpeur", e$   
	    if drl_prm10$ = 1, n$, "CYCLE101 ;DESACTIVATION DU LISTAGE DES COTES", e$
	    drl_prm10 = 0
	    ]
	avance = fr_pos$
	p_vit_rot_max
	debut_out = 1
	gcode$ = 0
	p_affiche_options(20)
	p_lissage_off
	old_cc = 140
	n$, "G40", e$   # pcorrecteur_D
	n$, "M5", e$
	p_lubrif_OFF
	if Test_bris_outils = 1, p_test_bris_outil 
	if decalage = 1 | sauve_ra_block_ >0, [		# Annulation du décallage FIN du renvoie d'angle  
		p_annule_decalage     					# annuler les decalages d'origine
		usecandrill$ = old_usecandrill
	    usecanpeck$  = old_usecanpeck
	    usecanchip$  = old_usecanchip
	    usecantap$   = old_usecantap
	    usecanbore1$ = old_usecanbore1
	    usecanbore2$ = old_usecanbore2
	    usecanmisc1$ = old_usecanmisc1
	    usecanmisc2$ = old_usecanmisc2	
		#p_cycles_valides						# réactives les cycles utilisables après le Renvoie
		sauve_ra_block_ = 2
		]	
	p_degage_ptlchg
	spaces$ = 1
	p_mZERO
	#temps DLL
	info_temps = 4, p_temps_affectation	
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS DE L OPE. = ", *Heure, *min, *sec, s_com_close, e$
		]  
	info_temps = 5, p_temps_affectation
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 5, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS DE L OUTIL= ", *Heure, *min, *sec, s_com_close, e$
		Tot_time_op = 0
		Tot_time_Out = 0	
		]		
	#
	p_affiche_outil 
	#temps DLL
	Types_Temps_DLL = plcval (s_Types_Temps_DLL, 4)
	p_temps_dll	# lecture du temps de l'OP dans la DLL		
   	#
	if nextop$ = 11, p_ori_usi
	n$, p_dec_outil, "; Activation du bloc tranchant outil", e$
	p_placement_apres_chang_outil                   	# AFFICHAGE DES MOUVEMENTS MACHINE
	if palpeur = 0 & nextop$ <> 11, [
		n$, *xr$, *yr$, e$          
		n$, *zr$, p_lubrif_ON, e$ 
		]	
	if palpeur = 1 & nextop$ <> 11, [
	    gcode$ = 1
	    spaces$ = 1
	    n$, "DEF INT V_SPEED=5000", e$
	    n$, *sgcode, "MEAS=1", *xr$, *yr$, "F=V_SPEED", e$
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
		n$, "M81 ; soufflage BUSES ON", e$   
		n$, *sgcode, "MEAS=1", *zr$,  e$           
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    n$, "M81 ; soufflage BUSES ON", e$    
	    ]
	if opcode$ = 16, drill_4_axes = 1 
	# Z de départ perçage 5 axes
	if opcode$ = 16 & diviseur = 1, old_z = ynci$  
	if opcode$ = 16 & diviseur = 2, old_z = xnci$  
	perreur_pas_fil  
	perreur_num_outil   
	p_erreur_dif_T_H_D 
	p_test_arcs_tete_renvoi
	debut = 0
	old_op_id = op_id$          # memo du numero d'operation
	old_ssa = ssa
	p_erreur_choix_axe_substitution	
	c_mmlt$     # Multiple tool subprogram call
	c_msng$		# Single tool subprogram call
#endregion

#region deplacements
pdwl_spd$        #Call from NCI gcode 4	*** ROTATION BROCHE / TEMPO / ARROSAGES
	#"ICI : pdwl_spd$", e$
	pspindle
	comment$
	pspindchng	
	pcan
	if fmtrnd(dwell$), dwell = dwell$, pcan1, p_bloc_O, n$, *sg04, *dwell, e$ 
	else, pcan1, p_bloc_O, #n$, strcantext, e$
	pcan2
	
#------------------------------- CONTOURS -----------------------------------
prapid$      # Ligne rapide
	#"ICI : prapid$", e$
	p_correc_time_G0
	xabs = x$
    yabs = y$
    zabs = z$
	gcode$ = 0
	if ra_block$ > 0, [        #avec le renvoie d'angle
		pcan1, p_bloc_O, n$, sgcode, sinc_abs, pxyz, p_lubrif_ON, strcantext, e$
		]
    if ra_block$ = 0, [        #pas avec le renvoie d'angle
		if rot_tlchg_zero = 1,  [    
	        pcan1, p_bloc_O, n$, pcorrecteur_D, sgcode, sinc_abs, pxyz, p_lubrif_ON, strcantext, e$	
	        rot_tlchg_zero = 0
	        ]
	    else, pcan1, p_bloc_O, n$, pcorrecteur_D, sgcode, sinc_abs, pxyz, e$
		] 
	
pzrapid$     # Ligne Z rapide
	#"ICI : pZrapid$", e$
	p_correc_time_G0
	gcode$ = 0 
	xabs = x$
    yabs = y$
    zabs = z$
	gcode$ = 0 
	if ra_block$ = 0, [ #RENVOIE D'ANGLE
		if rot_tlchg_zero = 1, n$, sgcode, *zabs, e$
		if rot_tlchg_zero = 0, [                
	        n$, pcorrecteur_D, sgcode, sinc_abs, pxyz, p_lubrif_ON, strcantext, e$	
	        ]
		prvz = z$
		]	
	
plin$        # Ligne travail
	#"ICI : plin$ ", e$
	xabs = x$
	yabs = y$
	zabs = z$
	p_percages_decomposes
	gcode$ = 1
	if cc$ = 41 | cc$ = 42, n$, pcorrecteur_D, sgcode, sinc_abs, pxyz, pfr, p_lubrif_ON, strcantext, e$	
	else, n$, pcorrecteur_D, sgcode, sinc_abs, pxyz, pfr, p_lubrif_ON, strcantext, e$	
	if drillcyc$ >= 0 & dwell$ > 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1), n$, *sg04, *dwell, e$
	prvz = z$
	if rpd_typ$ = 7, ptool_insp      # inspection des plaquettes/outil
	
pz$      # z en avance TRAVAIL
    #"ICI : pz$", e$
    xabs = x$
    yabs = y$
    zabs = z$
	gcode$ = 1
    n$, sgcode, sinc_abs, pxyz, pfr, p_lubrif_ON, strcantext, e$
	prvz = z$
	
pcir0$   # verif des arcs --> conversion en lignes si besoin
	@plane$
	if sauve_ra_block_ <= 0, linarc$ = 0
	if rotaxis$ <> 0, linarc$ = 1	# Convertir les arcs en lignes si travail en substitution 
	#if plane$ <> 0, linarc$ = 1	# pas d'arcs si G18 ou G19
	if ra_block$ >0, if m8$ <> 1 & m8$ <> -1 & m7$ <> 1 & m7$ <> -1, linarc$ = 1

pcir$       # Circulaire
	#"ICI : pcir$ ", e$
    p_modal     #affectation en format modal
    xabs = x$
    yabs = y$
    zabs = z$
	#if type_pp_SIEMENS = 1, result = nwadrs(s_rayon_CR, rayon)	# R en "CR="
    if arctype$ >= 5, pcir_r, p_lubrif_ON, strcantext, e$	    # en R
    else, pcir_ij, p_lubrif_ON, strcantext, e$ # [if ra_block$ >0, rayon = arcrad$, s_com_open, no_spc$, *rayon, no_spc$, s_com_close ], e$    # en IJ
	
	#if arctype$ >= 5, n$, splcode, *sgcode, pxyz, *arcrad$, pfr, p_lubrif_ON, strcantext, e$
	prvz = z$
	
pcir_r      # Circulaire G2 G3 G17 G18 G19 en R
    if arctype$ = 5, rayon = arcrad$           				# pour Rayon
    if arctype$ = 6 & abs(sweep$) <= 180, rayon = arcrad$  	# pour Rayon signé
    if arctype$ = 6 & abs(sweep$) > 180, rayon = -arcrad$  	# pour Rayon signé
    if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
    if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
    if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z
	if ra_block$ >0, [
		if (m8$ = 1 | m8$ = -1), plane$ = 2
		if (m7$ = 1 | m7$ = -1), plane$ = 1
		]
	n$, splcode, sinc_abs, *sgcode, pxyz, rayon, pfr   # plan XY

pcir_ij     # Circulaire G2 G3 G17 G18 G19 en IJ
    rayon = arcrad$	# pour l'info de la valeur du Rayon
	if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
    if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
    if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z
	if ra_block$ >0, [
		if (m8$ = 1 | m8$ = -1), plane$ = 2
		if (m7$ = 1 | m7$ = -1), plane$ = 1
		]
	n$, splcode, sinc_abs, *sgcode, pxyz, pijk, pfr, [ if tool_op$ = 1, s_com_open, no_spc$, rayon, no_spc$, s_com_close ]
	
pijk        # ecriture des IJK pour G90 G91
    !i$, !j$, !k$
    if arctype$ = 1, [   # pour centre en absolue en G90
        iabs = i$
        jabs = j$
        kabs = k$
        iinc = i$ - prv_x$
        jinc = j$ - prv_y$
        kinc = k$ - prv_z$
        ]
    else,       [     # pour centre en relatif en G90
	    iabs = i$
	    jabs = j$
	    kabs = k$
	    iinc = i$
	    jinc = j$
	    kinc = k$
        ]
    if incremental = 0 & plane$ = 0, *iabs, *jabs, !iinc, !jinc, !kinc
    if incremental = 0 & plane$ = 2, *iabs, *kabs, !iinc, !jinc, !kinc
    if incremental = 0 & plane$ = 1, *jabs, *kabs, !iinc, !jinc, !kinc
    if incremental = 1 & plane$ = 0, !iabs, !jabs, *iinc, *jinc, !kinc
    if incremental = 1 & plane$ = 2, !iabs, !kabs, *iinc, !jinc, *kinc
    if incremental = 1 & plane$ = 1, !jabs, !kabs, !iinc, *jinc, *kinc		

p_modal     # affectation en format modal X Y Z A garde profondeur ABS ET INC
	#"p_modal"
    result = newfs (2, xabs)
    result = newfs (11, xinc)
    result = newfs (2, yabs)
    result = newfs (11, yinc)
    result = newfs (2, zabs)
    result = newfs (11, zinc)
    result = newfs (2, axeA)
    result = newfs (11, axeAi)
    #result = newfs (2, prof_abs)
    #result = newfs (2, prof_inc)
    #result = newfs (2, garde_abs)
    #result = newfs (2, garde_inc)

p_casse_modalite_avance # casser la modalité de l'avance
    result = newfs (26, avance)

p_casse_modalite    # pour casser la modalité de Xabs et Xinc Yabs et Yinc Zabs et Zinc
    #"p_casse_modalite"
    p_casse_modalite_X
    p_casse_modalite_Y
    p_casse_modalite_Z
    p_casse_modalite_A

p_casse_modalite_X  # pour casser la modalité de Xabs et Xinc
    result = newfs (3, xabs)
    result = newfs (11, xinc)

p_casse_modalite_Y  # pour casser la modalité de Yabs et Yinc
    result = newfs (3, yabs)
    result = newfs (11, yinc)

p_casse_modalite_Z  # pour casser la modalité de Zabs et Zinc
    result = newfs (3, zabs)
    result = newfs (11, zinc)

p_casse_modalite_A  # pour casser la modalité de Zabs et Zinc
    result = newfs (3, axeA)
    result = newfs (11, axeAi)

p_casse_modalite_perce  # pour casser la modalité de prof_abs et prof_i garde_abs garde_i
    #result = newfs (3, prof_abs)
    #result = newfs (3, prof_inc)
    #result = newfs (3, garde_abs)
    #result = newfs (3, garde_inc)
#endregion

#region mouvements pxyz et 4 axes
pxyz        # ecriture des x, y, z en abs ou incremental pour corp ISO
    pxyz_new
    p_modal     	# affectation en format modal
    !x$, !y$, !z$   # mise a jour xyz
    old_x = xabs    # memo des anciennes positions
    old_y = yabs
    old_z = zabs
	
#region calculs TETE A RENVOIE
pcalcul_plan    
	angle_autour_Y = asin (m3$)
    cos_angleY = cos (angle_autour_Y)
    angle_autour_Y = angle_autour_Y *-1
    if cos_angleY > 0.005 ,
    [
        #3 angle autour de X
        tr_x = m9$ / cos_angleY
        tr_y = -m6$ / cos_angleY
        angle_autour_X  = atan2 (tr_y,tr_x)
        if angle_autour_X > 180 , angle_autour_X = angle_autour_X - 360
        angle_autour_X = angle_autour_X * -1
        #4 angle autour de Z
        tr_x = m1$ / cos_angleY
        tr_y = -m2$ / cos_angleY
        angle_autour_Z  = atan2 (tr_y,tr_x)
        if angle_autour_Z > 180 , angle_autour_Z = angle_autour_Z - 360
        angle_autour_Z = angle_autour_Z * -1
    ]
    else,
    [
        # angle autour de X
        angle_autour_X  = 0
        # angle autour de Z
        angle_autour_Z  = atan2 (m4$,m5$)
        if angle_autour_Z > 180 , angle_autour_Z = angle_autour_Z - 360
        angle_autour_Z = angle_autour_Z * -1
    ]	
	
pcalcul_xyz_absolu
    !angle_autour_X, !angle_autour_Y, !angle_autour_Z
    angle_autour_X_2 = angle_autour_X * -1
    angle_autour_Z_2 = angle_autour_Z * -1
    angle_autour_Y_2 = angle_autour_Y * -1
	#"voir les angles tournés ", *angle_autour_X_2, *angle_autour_Z_2 , *angle_autour_Y_2 , e$
    #   tourne le point autour X
    y1 = zdep * sin(angle_autour_X_2) + ydep * cos(angle_autour_X_2)
    z1 = zdep * cos(angle_autour_X_2) - ydep * sin(angle_autour_X_2)
    #   tourne le point autour Y
    zabs = xdep * sin(angle_autour_Y_2) + z1  * cos(angle_autour_Y_2)
    x1 = xdep * cos(angle_autour_Y_2) - z1  * sin(angle_autour_Y_2)
    # tourne le point autour de Z
    xabs = y1  * sin(angle_autour_Z_2) + x1  * cos(angle_autour_Z_2)
    yabs = y1  * cos(angle_autour_Z_2) - x1  * sin(angle_autour_Z_2)
		
angle_autour_X_2 : 0
angle_autour_Z_2 : 0
angle_autour_Y_2 : 0
angle_autour_Z : 0
angle_autour_Y : 0 
angle_autour_X : 0
xplan_inter : 0
yplan_inter : 0
zplan_inter : 0	
tr_y : 0
tr_x : 0
cos_angleY : 0
x1 : 0
y1 : 0
z1 : 0
xplan : 0
yplan : 0
zplan : 0
xdep : 0
ydep : 0
zdep : 0
sauvX : 0
sauvY : 0
sauvZ : 0

p_calcul_xyz_tete_renvoie
	pcalcul_plan
	sauvX = x$
	sauvY = y$
	sauvZ = z$
	xdep = x$
	ydep = y$
	zdep = z$
	pcalcul_xyz_absolu
	x$ = xabs
	y$ = yabs
	z$ = zabs
	#AUTRE CEDRIC
 	#xabs = x$ * m1$ + y$ * m2$ + z$ * m3$
	#Yabs = x$ * m4$ + y$ * m5$ + z$ * m6$
	#Zabs = x$ * m7$ + y$ * m8$ + z$ * m9$

#endregion

pxyz_new    # ecriture des positions X Y Z et A pour XYZ CLASIQUE et substitution
	if ra_block$ >0, p_calcul_xyz_tete_renvoie #RENVOIE D'ANGLE	

    if rotaxis$ = 0, [    # XYZ CLASIQUE
        if incremental = 0,	[
            if cc$ = 41 | cc$ = 42 | cc$ = 140, *xabs, *yabs, zabs, !xinc, !yinc, !zinc 
            else, xabs, yabs, zabs, !xinc, !yinc, !zinc 
            ]
        else, !xabs, !yabs, !zabs, *xinc, *yinc, *zinc         #pour 1er déplacement
        ]
	
	#POUR SUBSTITUTION "incrémental" ?	
    #if incremental = 0, xabs, yabs, axeA, zabs, !xinc, !yinc, !axeAi, !zinc
    #else, !xabs, !yabs, !axeA, !zabs, xinc, yinc, axeAi, zinc

    if rotaxis$ = -2 | rotaxis$ = 2, [    # SUBSTITUTION Y par A (diviseur tourne autour de X)
        result = nwadrs(s_axe_rot_A, axeAB_subs)
		p_calcul_AB_pos_Subs		
		yabs = 0
		xabs = x$
        xabs, [if yabs <> old_y, yabs], zdev, axeAB_subs, !yabs, !zabs     #, !xinc, !yinc, !zinc, !A_posi, !zdevi
        axeA  = axeAB_subs
		old_y = 0
        old_axeA  = axeAB_subs
        nbrtour = int (axeA / 360)	
        ]
    if rotaxis$ = -1 | rotaxis$ = 1, [   # SUBSTITUTION X par A (diviseur tourne autour de Y)
		p_calcul_AB_pos_Subs
		xabs = 0
		yabs = y$
        [if xabs <> old_x, xabs], yabs, zdev, axeAB_subs, !xabs, !zabs     #, !xinc, !yinc, !zinc, !A_posi, !zdevi
        axeA = axeAB_subs
		old_x = 0
        old_axeA  = axeAB_subs
        nbrtour = int (axeA / 360)
        ]			
#endregion

#region peof_fin
p_palette_fin
	if utilise_palette > 0, [	# PALETTES
		if useaxe = 1, [
			n$, "T0 M6", s_com_open, "DECHARGE DE L'OUTIL EN BROCHE", s_com_close, e$
			n$, s_com_open, "POUR ROTATION PALETTE AVEC L AXE -A-", s_com_close, e$
			]
		n$, "M45", s_com_open, "RIDEAUX EAU OFF", s_com_close, e$	
		if useaxe = 1, [
			if deg_palette_deb_fin > 0, [
				old_degageX     = degageX
                old_degageY     = degageY
                old_degageZ     = degageZ
                degageX        	= degageX_pal
                degageY        	= degageY_pal
                degageZ        	= degageZ_pal
                deg_fin 		= deg_palette_deb_fin
                p_degage_fin
                degageX        	= old_degageX
                degageY        	= old_degageY
                degageZ        	= old_degageZ
				]
			]
		if Var_16_question > 0, n$, "M128", s_com_open, "RETOUR ROTATION PALETTE B", s_com_close, e$
		if Var_17_question > 0, n$, "M127", s_com_open, "RETOUR ROTATION PALETTE A", s_com_close, e$
		n$, "G0 G17 G49 G80 G90", e$
		# COMPTEURS FANUC PALETTES
		if Var_16_question > 0, n$, "#500=#500+", no_spc$, *Var_16_question, s_com_open, "COMPTEUR PALETTE A", s_com_close, e$
		if Var_17_question > 0, n$, "#500=#500+", no_spc$, *Var_17_question, s_com_open, "COMPTEUR PALETTE B", s_com_close, e$
		if Var_16_question > 0 & Var_17_question > 0, result = mprint(s_erreur_choix_palette)
		if Var_16_question < 1 & Var_17_question < 1, result = mprint(s_erreur_choix_palette)
		]
		
peof0$       # Fin T = 0
	peof$

peof$        # Fin T <> 0
	spaces$ = 1
	n$, "M05", e$
	if mi7$ = 1, bloque = 2, n$, sbloque, e$	# déblocage de l'axe A/B 
	p_lubrif_OFF
	p_affiche_options(30)
	p_lissage_off
	if decalage = 1 | sauve_ra_block_ >0, [		# Annulation du décallage FIN du renvoie d'angle  
		p_annule_decalage     					# annuler les decalages d'origine
		sauve_ra_block_ = -1 
		]	
	if Test_bris_outils = 1, p_test_bris_outil
	if palpeur = 1, [
	    n$, "M71 ;Desactivation du palpeur", e$    
	    if drl_prm10 = 1, n$, "CYCLE101 ;DESACTIVATION DU LISTAGE DES COTES", e$
	    ]
	if (old_tox4 <> 0 ) | (old_toy4 <> 0) | (old_toz4 <> 0), n$, "TRANS X0 Y0 Z0", e$
	p_degage_fin 
	if bldnxtool$ = 1 & type_prep_outil = 2,	[	
		if nom_outil = 1,  [ 							# Tool call uses tool name
			first_op_id = streaminfo(1, 1)             	# Get the operation ID for the first operation in the sequence
			stoolname = opinfo(20001, first_op_id, 1)  	# Get the tool name for the first operation
			if stoolname = sblank, stoolname = "ERREUR-NOM OUTIL VIDE"
			n$, 'T="', "(", stoolname, no_spc$, '"', ")", e$  #Stage first tool
			]
	    if outils_param = 0 & nom_outil = 0, n$, "T", next_tool$, "M6", e$ 						# sans les parametres
	    if outils_param = 1 & nom_outil = 0, n$, "T=", no_spc$, *outil_suiv_param, "M6", e$ 	# AVEC les parametres
        ]
	# Déchargement de l'outil en broche
	if bldnxtool$ <> 1 & type_prep_outil < 1 & decharge_outil_fin = 1,	[	
		if outils_param = 0 & nom_outil = 0, n$, "T0 M6", e$ 
	    if outils_param = 1 & nom_outil = 0, outil_suiv_param = 0, n$, "T=", no_spc$, *outil_suiv_param, "M6", e$                  	
		]	
	#n$, *first_tool$, e$	
	if useaxe <> 0 & old_axeA <> 0,  [      # Remise a 0 de l'axe A si pas a Zero
	    axeA = 0               
	    p_rot_ptlchg                   		# affichage de l'angle
	    ]
	p_affiche_options(9)
	if type_pp_SIEMENS = 1,	[
	    #n$, "T0", e$    
	    #n, "SPATHNC", spathnc$, e$    		# Affiche le chemin du prog.
	    ]
	if convoyeur = 1, n$, s_convoyeur_OFF, e$
	if compteur_pieces	= 1, n$, s_compteur_piece, e$ 
	p_palette_fin	# PALETTES
	#temps DLL
	info_temps = 4, p_temps_affectation
	p_temps_dll	
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS OPE. = ", *Heure, *min, *sec, s_com_close, e$
		]  
	info_temps = 5, p_temps_affectation
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 5, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS OUTIL = ", *Heure, *min, *sec, s_com_close, e$
		Tot_time_op = 0
		Tot_time_Out = 0	
		]	
	info_temps = 6, p_temps_affectation
	if Affiche_temps_dll = 1 & Types_Temps_DLL = 6, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS TOTAL CORRIGE ", *Heure, *min, *sec, s_com_close, e$
		]  
	# 
	if sous_prog_int_ext = 1,   # sous-programme INTER
	    [
	    if appel_S_P_trans = 1, [
			n$, "GOTOF FIN_PROG", e$
		    n$, ";SOUS-PROGRAMMES INTERNES", e$
		    *e$
			]    
	    ]
	else, [
		if fin_programme = 1, n$, "M30", e$     # Fin si l'outil à renvoie d'angle non défini en longueur
	    if fin_programme = 2, n$, "M02", e$
		if fin_programme = 3, n$, "M99", e$
		]      	    
	if sous_prog_int_ext = 1,   # sous-programme INTER
	    [
	    if appel_S_P_trans = 1, n$, "END_PROG:", e$
	    if fin_programme = 1, n$, "M30", e$     # Fin si l'outil à renvoie d'angle non défini en longueur
	    if fin_programme = 2, n$, "M02", e$
		if fin_programme = 3, n$, "M99", e$	    
	    ]
	*e$
	if Type_lissage = 3 & lissage_3d_actif = 1, p_affiche_cycle832_prismatique	# sans le cycle 832 --> en fonction des OPs d'usinage de SURFACES
	if Type_lissage = 3, p_lissage_general										# sans le cycle 832 --> autres OPs (2D)
	
	# Ajout pour les sous-programmes
    *e$                             		# Sauter une ligne
    subout$ = 0                             # Ecriture dan le NC
	
    mergesub$								# Ecriture du sous-prog "transformation"
	mergeext$
	mergeaux$								# SOus-programme interne /passes en Z ..
	clearsub$								# Effacer les fichiers ".sub"
	clearext$                               # Effacer les sous-prog
	clearaux$ 								# Effacer les fichiers ".AUX" /passes en Z ..
    #if affiche_ori_entete = 2, mergeext$   # dans un autre fichier ".AUX"
    #if affiche_ori_entete = 22 & workofs_pwrtt > 54, mergeext$    # dans un autre fichier ".AUX"
    if affiche_ori_entete = 1 | affiche_ori_entete = 11, clearsub$	# Effacer les fichiers "sub" ORIGINES
    "%", e$                                 # fin de fichier
#endregion
#endregion

#region CALCUL & AFFICHAGE EN POSITIONNE
prot0$
prot$

p_calcul_rot_posit   # calcul de l'axe A en positionné
    @old_axeA, @nbrtour
	if Mode_reglage_PP = 0, n$, "--> p_calcul_rot_posit VOIR", *m9$, *m8$, *m7$, e$
    if diviseur = 1, axeA = atan2(m8$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de X
    if diviseur = 2, axeA = atan2(m7$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de Y
	axeA = axeA * sens_A_B                                      # prise en compte du sens de rotation
    epsi = axeA - old_axeA                      				# variation angulaire
    sensA = 0
    if epsi > 0, sensA = 1                      				# sens de la variation
    if epsi < 0, sensA = -1
    if Mode_reglage_PP = 0, n$, "--> epsi", *epsi, " sensA", *sensA, " nbrtour", *nbrtour, e$
    epsi = abs(epsi)
    @epsi, @sensA                               				# mise a jour
    if epsi > 180,  [                           				# optimisation de l'angle
        axeA = axeA - (360 * sensA)
        epsi = axeA - old_axeA
        sensA = 0
        if epsi > 0, sensA = 1
        if epsi < 0, sensA = -1
        ]
    nbrtour = int (axeA / 360)                  				# Calcul du nombre de tour
    if axeA >90, axeA = axeA - 360 
	memo_AB_subs = axeA
    if Mode_reglage_PP = 0,  "--> p_calcul_rot_posit div:", *diviseur, "old:", *old_axeA, "axe:", *axeA, "epsi:", *epsi, "sens:", *sensA, "nbrTour:", *nbrtour, e$

p_rot_ptlchg    # affichage de l'angle au changemant d'outil
    if Mode_reglage_PP = 0, n$, "--> p_rot_ptlchg", e$
	#Perreur_origine_plan    		
    Perreur_nom_RUD         	
	if ra_type$ = 0, perreur_tranf_plan   						# pas de broche à RENVOIE d'ANGLE 
    #if diviseur = 1 & useaxe <> 0, n$, "; ROTATION SUR A:", axeA, "DEG", e$
    #if diviseur = 2 & useaxe <> 0, n$, "; ROTATION SUR B:", axeA, "DEG", e$
    if subout$ = 0, [       									# afficher les angles que dans le programme principal
       if useaxe <> 0, [
            @old_axeA, @axeA
            epsi = old_axeA - axeA
            epsi = abs(epsi)
			if Mode_reglage_PP = 0, n$, "--> p_rot_ptlchg", "old:", *old_axeA, "axe:", *axeA, "epsi:", *epsi, e$
            #if epsi <> 0,[
	            if mi7$ = 1, bloque = 2, n$, sbloque, e$			# déblocage de l'axe A/B 
				p_affiche_type_rot
				if Systeme_rot_plans = 1 | Systeme_rot_plans = 3, p_ori_usi
	            if mi7$ = 1, bloque = 1, n$, sbloque, e$		# blocage de l'axe A/B 
                #]
            ]
		old_axeA = axeA
		]

p_rot_tlchg0      			# affichage de l'angle au chg outil nul pour positionné
    #Perreur_origine_plan    		
    Perreur_nom_RUD         		
	if ra_type$ = 0, perreur_tranf_plan   # pas de broche à RENVOIE d'ANGLE 
    if subout$ = 0, [           	# afficher les angles que dans le prog principal
       if useaxe <> 0 | opcode$ = 16, [
            @old_axeA, @axeA
            epsi = old_axeA - axeA
            epsi = abs(epsi)
			if Mode_reglage_PP = 0, n$, "--> p_rot_tlchg0", "old:", *old_axeA, "axe:", *axeA, "epsi:", *epsi, e$
            if epsi <> 0, [
				rot_tlchg_zero = 1 
				xabs = nextx$   #pour les perçages    # reprendre les positions xyz avant le dégagement
            	yabs = nexty$	#pour les perçages 
            	zabs = zr$
                p_degage_4_axes
				#p_mZERO
                if mi7$ = 1, bloque = 2, n$, sbloque, e$		# déblocage de l'axe A/B 
				spaces$ = 1
				p_affiche_type_rot
                if mi7$ = 1, bloque = 1, n$, sbloque, e$		# blocage de l'axe A/B 
				gcode$ = 0	
	            if incremental = 0, [                           # Rappel des positions XYZ avant le dégagement         
					xabs = xr$
					yabs = yr$ 
					zabs = zr$ 
					if xabs <> prv_xabs | yabs <> prv_yabs, n$, *sgcode, sinc_abs, *xabs, *yabs, e$
					#if mi2$ = 1, n$, *sgcode, *zabs, strcantext, e$	# FORCE le Z sécu de l'op si la config est remonter en Z HAUT 		           
	                !x$, !y$, !z$
	                ]
                ]
            ]
        old_axeA = axeA
        ]

# POUR LE MODE DE ROTATION **5**
# ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M..."
s_M_ROT_PO_P1_1 : "M56 ; palette A"	# ROTATION POSITIVE PALETTE A(1)	type palette commandée "A"
s_M_ROT_PO_P1_2 : "M55 ; + 90DEG"	# ROTATION POSITIVE PALETTE A(1)	ROT en +
s_M_ROT_NE_P1_1 : "M56 ; palette A"	# ROTATION NEGATIVE PALETTE A(1)	type palette commandée "A"
s_M_ROT_NE_P1_2 : "M54 ; - 90DEG"	# ROTATION NEGATIVE PALETTE A(1)	ROT en -

# ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
s_M_ROT_PO_P2_1 : "M57 ; palette B"	# ROTATION POSITIVE PALETTE B(2)	type palette commandée "B"	
s_M_ROT_PO_P2_2 : "M55 ; + 90DEG"	# ROTATION POSITIVE PALETTE B(2)	ROT en +
s_M_ROT_NE_P2_1 : "M57 ; palette B"	# ROTATION NEGATIVE PALETTE B(2)	type palette commandée "B"
s_M_ROT_NE_P2_2 : "M54 ; - 90DEG"	# ROTATION NEGATIVE PALETTE B(2)	ROT en -

s_M_ROT_PO_1 : ""
s_M_ROT_PO_2 : ""
s_M_ROT_NE_1 : ""
s_M_ROT_NE_2 : ""	
	
p_affiche_type_rot
	gcode$ = 0	
	if Systeme_rot_plans = 0, [	#pas de calculs "TOUJOURS EN G54"
		if incremental = 0, n$, sgcode, sinc_abs, *axeA, !axeAi, e$	
    	else, n$, sgcode, sinc_abs, !axeA, *axeAi, e$	
		] 
	if Systeme_rot_plans = 1, [	#PLANS "CYCLE800..."
		"SYSTEME DE PLANS 1 A DEFINIR", e$
		n$, "TRAFOOF ; Annulation de toutes les transformations", e$ 
		if incremental = 0, n$, sgcode, sinc_abs, "G68", *axeA, !axeAi, e$
	    else, n$, sgcode, sinc_abs, !axeA, "G68", *axeAi, e$
		n$, p_ori_usi, e$
		] 
	if Systeme_rot_plans = 2, [	#SOUS-PROGRAMME de calcul --> usi en G55
		"SYSTEME DE PLANS 2 A DEFINIR", e$	
		if incremental = 0, n$, sgcode, sinc_abs, *axeA, !axeAi, e$
	    else, n$, sgcode, sinc_abs, !axeA, *axeAi, e$
		n$, "M98 P8000", e$
		n$, s_com_open, "G55 ACTIF",  s_com_close, e$
		] 
	if Systeme_rot_plans = 3, [	#1 ORIGINE PAR ANGLE
		"SYSTEME DE PLANS 3 A DEFINIR", e$
		if incremental = 0, n$, sgcode, sinc_abs, s_com_open, *axeA, s_com_close, !axeAi, e$
	    else, n$, sgcode, sinc_abs, !axeA, s_com_open, *axeAi, s_com_close, e$
		n$, p_ori_usi, e$	
		]
	if Systeme_rot_plans = 4, [	#MODULE DE ROTATION A PART "automate" --> FONCTION "M" -- 1 ORIGINE PAR ANGLE
		n$, "M21", s_com_open, , "ROTATION AXE A", s_com_close, e$
		if incremental = 0, n$, sgcode, sinc_abs, s_com_open, *axeA, s_com_close, !axeAi, e$
	    else, n$, sgcode, sinc_abs, !axeA, s_com_open, *axeAi, s_com_close, e$
		n$, "G4 X2.", e$
		]
	if Systeme_rot_plans = 5, [	# 5 = FONCTION "M" en RELATIF **chaque M=90°** module de rotation à part "capteu automate" (1 ORIGINE PAR ANGLE)
		if axeA = -270, axeA = -90
		if axeA = 270, axeA = -90
		if axeA = -180, axeA = 180
		if epsi <>0, n$, s_com_open, "ROTATION AXE :", *axeA, " ANCIEN :", *old_axeA , s_com_close, e$
		
		if Var_16_question > 0, [	# ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M"
			s_M_ROT_PO_1 = s_M_ROT_PO_P1_1
			s_M_ROT_PO_2 = s_M_ROT_PO_P1_2
			s_M_ROT_NE_1 = s_M_ROT_NE_P1_1
			s_M_ROT_NE_2 = s_M_ROT_NE_P1_2
			]
		if Var_17_question > 0, [	# ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
			s_M_ROT_PO_1 = s_M_ROT_PO_P2_1
			s_M_ROT_PO_2 = s_M_ROT_PO_P2_2
			s_M_ROT_NE_1 = s_M_ROT_NE_P2_1
			s_M_ROT_NE_2 = s_M_ROT_NE_P2_2
			]
		#ROTATION HORAIRE 	
		if old_axeA = 0 & axeA = 90, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$													#0 		--> 90
		if old_axeA = 0 & axeA = 180, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$	#0 		--> 180
		if old_axeA = 90 & axeA = 180, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$												#90		--> 180
		if old_axeA = 180 & axeA = -90, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$												#180	--> -90
		if old_axeA = 180 & axeA = 0, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$	#180	--> 0 
		if old_axeA = -90 & axeA = 0, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$												#-90 	--> 0
		
		#ROTATION ANTI-HORAIRE 		
		if old_axeA = 0 & axeA = -90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$												#0 		--> -90	
		if old_axeA = -90 & axeA = 180, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$												#-90	--> -180
		if old_axeA = 90 & axeA = 0, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$													#90		--> 0
		if old_axeA = 180 & axeA = 90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$												#180	--> 90	
		if old_axeA = -90 & axeA = 90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$	#-90	--> 90		
		if old_axeA <> axeA, n$, "G04", "P1000", e$
		old_axeA = axeA
		]
#endregion

#region calculs_et_affichage_rotations_en_CONTINU_et_substitution	
p_calcul_AB_pos_Subs  # calcul de l'axe A/B en substitution
    @x$, @y$
    if diviseur = 1, axeAB_subs = (y$ * 360 / (pi$ * rotdia$)) * sens_A_B   	# pour 4eme axe autour de X (substituer Y)
    if diviseur = 2, axeAB_subs = (x$ * 360 / (pi$ * rotdia$)) * sens_A_B   	# pour 4eme axe autour de Y (substituer X)			
    if diviseur = 1, result = nwadrs(s_axe_rot_A, axeAB_subs)
	if diviseur = 2, result = nwadrs(s_axe_rot_B, axeAB_subs)
	p_Z_dev
	
	# ---- pour Ajouter/Soustraire l angle du plan "en positionné"
	# ROTATION SUR X	& old_rotaxis <> 0, 
	if rotaxis$ = -2, axeAB_subs = ((axeAB_subs +180) - memo_AB_subs)* -1		#TYPE MC : SENS TRIGO sur X 
	if rotaxis$ = 2, axeAB_subs = axeAB_subs + memo_AB_subs						#TYPE MC : SENS HORAIRE sur X 
	# ROTATION SUR Y
	if rotaxis$ = -1, axeAB_subs = ((axeAB_subs +180) - memo_AB_subs)* -1		#TYPE MC : SENS TRIGO sur Y 
	if rotaxis$ = 1, axeAB_subs = axeAB_subs - memo_AB_subs						#TYPE MC : SENS HORAIRE sur Y 
	if rot_AB_un_sens = 1, while axeAB_subs < 0, axeAB_subs = axeAB_subs +360
	delta_A_sub = old_axeA - axeAB_subs
	delta_A_sub = abs(delta_A_sub)
	
	if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0           						# diviseur tourne autour de Y (X sbstitue)
    if rotaxis$ = -2 | rotaxis$ = 2, yabs = 0   								# diviseur tourne autour de X (Y sbstitue)
	
	if drillcyc$ >= 0, [
		# rotaxis$ = -2 OK avec les parcours --> les autres restent à définir
		if rotaxis$ = -1 | rotaxis$ = 1, axeAB_subs = (axeAB_subs + 360) * -1   # diviseur tourne autour de Y (X sbstitue)
		if rotaxis$ = -2, axeAB_subs = (axeAB_subs + 360) 						# diviseur tourne autour de X (Y sbstitue) ANTI-HORAIRE OK
		if rotaxis$ = 2, n$, "PROBLEME VEUILLEZ METTRE LE SENS EN ANTI-HORAIRE", e$
		]
	
p_Z_dev  # calcul du Z en substitution
    @z$, @rotdia$
    zdev  = z$ +(rotdia$ /2)    # Z pour continu en substitution en ABS
    zabs = zdev

p_Apos_affiche_subs  # affichage de l'angle au chg outil nul 
    if useaxe <> 0, [
        @old_axeA, @axeA
        epsi = old_axeA - axeA
        epsi = abs(epsi)
           if epsi <> 0,    [
			p_degage_4_axes
            if mi7$ = 1 & bloque = 1, bloque = 2, n$, sbloque, e$		
            if incremental = 0, n$, sgcode, p_ori_usi, sinc_abs, *axeA, !axeAi, e$
            else, n$, sgcode, sinc_abs, p_ori_usi, !axeA, *axeAi, e$
            ]
        ]
    old_axeA = axeA
	
# continu -------------------------------------------------------
p_axeAB_pmx
    #*old_axeA1, *axeA1
    delta_axeA1 = axeA1 - old_axeA1
    if delta_axeA1 >  180, delta_axeA1 = delta_axeA1 - 360
    if delta_axeA1 <  -180,delta_axeA1 = delta_axeA1 + 360
    axeA1_dep = axeA1_dep + delta_axeA1
    old_axeA1 = axeA1
    axeA = axeA1_dep * sens_A_B
    old_axeA = axeA
    nbrtour = int (axeA / 360) * sens_A_B
    if incremental = 0, if debutpmx = 1, *axeA, !axeAi, else, axeA, !axeAi
    if incremental = 1, if debutpmx = 1, !axeA, *axeAi, else, !axeA, axeAi

p_calcul_rot_pmx      # Calculer les angles en 5 axes  
    #"VOIR", *x$, *y$, *z$, *u$, *v$, *w$, e$
	vx = u$ - x$
    vy = v$ - y$
    vz = w$ - z$
    if diviseur = 1, axeA1 = atan2(vy,vz) # on tourne autour de x
    if diviseur = 2, axeA1 = atan2(vx,vz) # on tourne autour de Y
    if axeA1 >  180, axeA2 = 360 - axeA1
    if axeA1 <= 180, axeA2 = axeA1 * -1
    if diviseur = 1, [          # on tourne autour de x
        new_x = x$
        new_y = z$*sin(axeA2) + y$*cos(axeA2)
        new_z = z$*cos(axeA2) - y$*sin(axeA2)
        ]
    if diviseur = 2, [          # on tourne autour de Y
        new_x = z$*sin(axeA2) + x$*cos(axeA2)
        new_y = y$
        new_z = z$*cos(axeA2) - x$*sin(axeA2)
        ]
    xabs = new_x
    yabs = new_y
    zabs = new_z
	epsi = old_axeA - axeA1  	# regarder si on tourne
    epsi = abs(epsi)
	old_axeA = axeA1
		
#endregion

#region pmx_
pmx$        # Gestion 4 axes continue avec fonction 5 axes
    if Mode_reglage_PP = 0, n$, "--> pmx$", *x$, *y$, *z$, *zr$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$, 
		*m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
		
	# ***** ATTENTION ! LE perçage 5 axes en 4AXES NE PASSE PAS ICI********
	# ***** PAS de gestion complète du perçage 5 axes ICI
	#		- pmx$ 
	# 		- p_drill_5axes pour le début XY/A/HZ/A ..
	# 		- p_drill_5axes_2 suivants	 
		
	if debutpmx = 1 & opcode$ <> 16, p_debut_pmx, ex$ 
	# 5 AXES classique
    if debutpmx = 0 & opcode$ <> 16,	[	# pas pour le perçage 5 axes
		if Mode_reglage_PP = 0, "pmx_ CONTOURS: ", e$
        p_calcul_rot_pmx
		if m1$ <> 1 & m5$ <> 1, p_erreur_inclinaison_OP_5axes 	# TEST si mauvaise inclinaison
        if fr$ = -2, gcode$ = 0
        else, gcode$ = 1
        if gcode$ = 1,	[
            @xabs, @yabs, @old_x, @old_y
            #if xabs <> old_x | yabs <> old_y, n$, sinc_abs, sgcode, xabs, yabs, zabs, p_axeAB_pmx, pfr, e$ 
            #else, n$, sinc_abs, sgcode, xabs, yabs, zabs, p_axeAB_pmx, pfr, e$	
			n$, sinc_abs, sgcode,
				if cc$ = 41 | cc$ = 42 & cc$ <> old_cc & motst$ <> 6, pcorrecteur_D
				xabs, yabs, zabs, p_axeAB_pmx, pfr, e$
            ]
        else, n$, sinc_abs, sgcode, xabs, yabs, zabs, p_axeAB_pmx, e$
		!x$, !y$, !z$, !xr$, !yr$, !zr$
        ] 
    #
	# Uniquement perçage 5 axes
	#if debutpmx = 0 & opcode$ = 16 & gcode$ = 11 & nextop$ = 11,	[  
		#if Mode_reglage_PP = 1, "pmx_ PERCAGES: ", e$        
		#p_calcul_rot_pmx		
		#if mi7$ = 1 & bloque <> 2, bloque = 2, n$, *sbloque, e$		# deblocage de l'axe A
		#if fr$ = -2, gcode$ = 0, else, gcode$ = 1
		#avance = F_G1_rot_5x
		#n$, [if avance <> olf_fr_5axes, *sgcode], xabs, yabs, zabs, p_axeAB_pmx, [if avance <> olf_fr_5axes & fr$ <> -2, *avance], e$
		#old_op_id = op_id$
		#old_op = 11			#pour forcer le "A/B" après le pmx$
		#olf_fr_5axes = F_G1_rot_5x
		#]
	#if debutpmx = 0 & opcode$ = 16 & gcode$ = 11 & nextop$ = 1003, #FIN DE PERCAGES --> Z HAUT SECU
		#[
		#p_calcul_rot_pmx
		#gcode$ = 0
		#n$, *sgcode, *zabs,	e$ 
		#]
	old_x = xabs
    old_y = yabs
    old_z = zabs

p_debut_pmx
    if Mode_reglage_PP = 0, n$, "p_debut_pmx : ", e$
	@new_z
    p_calcul_rot_pmx
	if mi7$ = 1, bloque = 2, n$, sbloque, e$		# déblocage de l'axe A/B 
    gcode$ = 0
	old_axeA = -99999
    if opcode$ <> 16, n$, *sinc_abs, *sgcode, p_axeAB_pmx, e$	
		
    if diviseur = 1, new_y = nextz$*sin(axeA2) + nexty$*cos(axeA2)
	if diviseur = 2, new_x = nextz$*sin(axeA2) + nextx$*cos(axeA2)
	
	if diviseur = 1, n$, *sgcode, "G17", *xabs, *new_y, ssa, spdlon, e$ 	
	if diviseur = 2, n$, *sgcode, "G17", *new_x, *yabs, ssa, spdlon, e$	
	if cc$ = 41 | cc$ = 42, p_correct_r_5x_c
	zr_ = zr$		
	if opcode$ <> 16, n$, *zabs, p_lubrif_ON, e$
	if opcode$ = 16, new_z = old_z, n$, *zr_, p_lubrif_ON, e$ 	# *new_z, p_lubrif_ON, e$
    !x$, !y$, !z$, !xr$, !yr$, !zr$
    old_x = xabs
    old_y = yabs
    old_z = zabs
    debutpmx = 0
	
pmx_end$	#FIN de chaque BLOC pmx$
	if Mode_reglage_PP = 0, "pmx_end_: ", e$
					if old_cc = 41 | old_cc = 42 & cc$ = 140, "G40", old_cc = cc$  
	

p_correct_r_5x_c        
    n$, "; --------------", e$
    n$, "; indique le type d'outil pour la correction", e$
    n$, "; de rayon en 5 axes continus", e$
	#n$, "; ATTENTION à bien définir le BON type d'outil sur la CN", e$
    n$, "; A ne pas modifier", e$
	r_bout_out = paramT6
	A_bout_out = paramT8
    spaces$ = 0
    if paramT2 = 11, [		
        r_bout_out = paramT6
        n$, " ", 36, "TC_DP1 [", 36, "P_TOOLNO,1] = 110 ; FR BOULE", e$
        n$, " ", 36, "TC_DP6 [", 36, "P_TOOLNO,1] = ", *r_bout_out, " ; RAYON", e$
        n$, " CUT3DF ; correction normale a la surface", e$
        ]
    if paramT2 = 27, [
        n$, " ", 36, "TC_DP1 [", 36, "P_TOOLNO,1] = 111 ; FR A BOUT ROND-LENTILLE", e$
        n$, " ", 36, "TC_DP6 [", 36, "P_TOOLNO,1] = ", *r_bout_out, " ;  RAYON", e$
        n$, " CUT3DF ; correction normale a la surface", e$
        ]
    if paramT2 = 10, [	#paramT8 = 180	--> Problème sur la 2026 ANGLE DROIT = 45° !!!!!!
        n$, " ", 36, "TC_DP1 [", 36, "P_TOOLNO,1] = 120 ; ou 130 FR DROITE", e$
        n$, " CUT3DC ; correction peripherique", e$
        ]
    if paramT2 = 19, [	
        n$, " ", 36, "TC_DP1 [", 36, "P_TOOLNO,1] = 121 ; ou 131 FR TORIQUE", e$
        n$, " ", 36, "TC_DP6 [", 36, "P_TOOLNO,1] = ", *r_bout_out, " ; RAYON", e$
        n$, " CUT3DC ; correction peripherique", e$
        ]
    if paramT2 = 17 & r_bout_out = 0, [			
        n$, " ", 36, "TC_DP1 [", 36, "P_TOOLNO,1] = 155 ; FR CONIQUE TRONQUEE", e$
        n$, " ", 36, "TC_DP11 [", 36, "P_TOOLNO,1] = ", *A_bout_out, " ; ANGLE", e$
        n$, " CUT3DC ; correction peripherique", e$
        ]
    if paramT2 = 17 & r_bout_out > 0 & paramT5 <> (r_bout_out*2), [	
		n$, " ", 36, "TC_DP1 [", 36, "P_TOOLNO,1] = 156 ; FR CONIQUE-TORIQUE", e$
		n$, " ", 36, "TC_DP11 [", 36, "P_TOOLNO,1] = ", *A_bout_out, " ; ANGLE", e$
		n$, " ", 36, "TC_DP7 [", 36, "P_TOOLNO,1] = ", *r_bout_out, " ; RAYON", e$
		n$, " CUT3DC ; correction peripherique", e$
		]
	if paramT2 = 17 & r_bout_out > 0 & paramT5 = (r_bout_out*2), [	
		n$, " ", 36, "TC_DP1 [", 36, "P_TOOLNO,1] = 157 ; FR BOULE-CONIQUE", e$
		n$, " ", 36, "TC_DP11 [", 36, "P_TOOLNO,1] = ", *A_bout_out, " ; ANGLE", e$
		n$, " ", 36, "TC_DP6 [", 36, "P_TOOLNO,1] = ", *r_bout_out, " ; RAYON", e$
		n$, " CUT3DF ; correction normale a la surface", e$
		]
	spaces$ = 1
    n$, "; --------------", e$
#endregion 

#region Pbloc_appelEs
p_aff_infos_cycle832
	"OP_Surface_ebauche ", *OP_Surface_ebauche, e$
	"OP_Surface_finition ", *OP_Surface_finition, e$
	"cycle832_tech ", *cycle832_tech, e$
	"tool_op$ ", *tool_op$, e$
	"hs_surf_style ", *hs_surf_style, e$
	"cycle832_format ", *cycle832_format, e$ 
	"tolerance_usinage_3D ", *tolerance_usinage_3D, e$
	"tolerance_usinage_2D ", *tolerance_usinage_2D, e$
	"tolerance_usinage_REEL ", *tolerance_usinage_REEL, e$
	"tolerance_usinage_MAX_% ", *tolerance_usinage_max_pcent, e$
	"OLD_tolerance_usinage ", *OLD_tolerance_usinage, e$
	"OP_percage ", *OP_percage, e$
	"p_affiche_options ", *posi_options, e$
	"cycle832_from_miscval ", *cycle832_from_miscval, e$
	#*prv_mr7$, *prv_mr8$, *prv_mr9$, *prv_mr10$, e$
	#*mi9$, *mr7$, *mr8$, *mr9$, *mr10$, e$  	

p_affiche_options(posi_options)
	if Mode_reglage_PP = 0, p_aff_infos_cycle832
		
	if type_pp_SIEMENS = 1, s_type_pp_xxxx = s_Options_840D
	if type_pp_SIEMENS = 2, s_type_pp_xxxx = s_Options_840D_SL
	if type_pp_SIEMENS = 3, s_type_pp_xxxx = s_Options_828D
	if type_pp_SIEMENS = 4, s_type_pp_xxxx = s_Options_810D
	
	type_CN = plcval (s_type_pp_xxxx, 1)
	posi_CN_1 = type_CN
	type_CN = plcval (s_type_pp_xxxx, 2)
	posi_CN_2 = type_CN 
	type_CN = plcval (s_type_pp_xxxx, 3)
	posi_CN_3 = type_CN  
	type_CN = plcval (s_type_pp_xxxx, 4)
	posi_CN_4 = type_CN 
	type_CN = plcval (s_type_pp_xxxx, 5)
	posi_CN_5 = type_CN
	type_CN = plcval (s_type_pp_xxxx, 6)
	posi_CN_6 = type_CN
	type_CN = plcval (s_type_pp_xxxx, 7)
	posi_CN_7 = type_CN 
	type_CN = plcval (s_type_pp_xxxx, 8)
	posi_CN_8 = type_CN  
	type_CN = plcval (s_type_pp_xxxx, 9)
	posi_CN_9 = type_CN 
	type_CN = plcval (s_type_pp_xxxx, 10)
	posi_CN_10 = type_CN
	type_CN = plcval (s_type_pp_xxxx, 11)
	posi_CN_11 = type_CN 
	type_CN = plcval (s_type_pp_xxxx, 12)
	posi_CN_12 = type_CN 

	if posi_options = 1, [
		if posi_CN_1 = 1, if rotation_A = 1, n$, "FGROUP(X,Y,Z,", no_spc$, s_axe_rot_label, no_spc$, ")", e$
		if posi_CN_1 = 1, if rotation_B = 1, n$, "FGROUP(X,Y,Z,", no_spc$, s_axe_rot_label, no_spc$, ")", e$
		if posi_CN_1 = 1, if rotation_A <> 1 & rotation_B <> 1, n$, "FGROUP(X,Y,Z)", e$
		posi_options = -1
		] 	
	if posi_options = 2, [
		if posi_CN_12 = 1, n$, "CHRONO(1,,); Activation du chronometre", e$   		# Lignes pour activation du chrono
	    if posi_CN_11 = 1, n$, "CONVO(60,10); Activation du convoyeur", e$    		# Lignes pour activer le convoyeur
	    if posi_CN_10 = 1, n$, "$A_OUTA[5]=50 ; Valeur pression M7", e$
		if posi_CN_5  = 1, n$, "M50 ; activation compensation de dilatation", e$
		posi_options = -1
		]			
	if posi_options = 3, [# & OP_Surface_finition > 0 & OP_Surface_finition > 0, [
		if drillcyc$ <= 0 & Type_lissage = 3,	[	#pas aux perCages  OP_percage = 0
			n$, "REPEAT LISSAGE_GENERAL", e$
			posi_options = -1	
		    ]		
		]	
	if posi_options = 20 & old_cycle832_tech > 0, [	#20 pour l'annulation
		if drillcyc$ <= 0 & Type_lissage = 3,	[	#pas aux perCages  OP_percage = 0
			n$, "REPEAT ANNUL_LISSAGE_3D", e$
			old_cycle832_tech = 0
			posi_options = -1	
		    ]		
		]
	if posi_options = 30 & OP_Surface_ebauche = 0 & OP_Surface_finition = 0, [	#30 pour l'annulation
		if drillcyc$ <= 0 & Type_lissage = 3,	[	#pas aux perCages  OP_percage = 0
			n$, "REPEAT ANNUL_LISSAGE_2D", e$
			posi_options = -1	
		    ]		
		]	
	if posi_options = 9, if posi_CN_12 = 1, n$, "CHRONO(0,2,Cycle complet); Arret du chronometre", e$, posi_options = -1	
	#if posi_options = 12 & OP_percage = 1 & posi_CN_2 = 1, n$, "JERK_OFF ; pas de lissage", e$, posi_options = -1		

#region lissage et cycle 832	

# AFFICHAGES UNIQUEMENT A LA FIN DU PROGRAMME 
p_lissage_general	# sans le cycle 832 --> OPs UNIQUEMENT 2D
	*e$
	n$, s_com_open, "LISSAGE OPERATIONS 2D, VALEURS FIXES", s_com_close, e$
	n$, "LISSAGE_GENERAL:", e$
    if posi_CN_9 = 1, n$, "FFWON ; activation de l'anticipation", e$
    if posi_CN_8 = 1, n$, "SOFT ; gestion des accouts", e$
    if posi_CN_7 = 1, n$, "CFTCP ; coupe constante point de contact outil", e$
    if posi_CN_6 = 1, n$, "G642 ; vitesse de contournage constante avec ", e$
    if posi_CN_6 = 1, n$, "; /compresseur/ = lecture des blocs A l'avance", e$		    
    if posi_CN_4 = 1, n$, "COMPCAD ; activation du compactage Type BSpline", e$   		
    if posi_CN_3 = 1, n$, "TOL(0.035) ; Tolerance d'usinage", e$                  		
    if posi_CN_2 = 1, n$, "JERK_ON(100) ; Lissage acceleration de 25 A 150 pour 100", e$
	n$, "ENDLABEL:", e$
	*e$
	n$, "ANNUL_LISSAGE_2D:", e$
	if posi_CN_9 = 1, n$, "FFWOF ; désactiv. de l'anticipation", e$
	if posi_CN_8 = 1, n$, "SOFT ; gestion des accouts", e$
	n$, "G64 ; mode arrondi des coins, normal", e$
	n$, "DYNNORM ; PASSE EN MODE NORMAL", e$
	n$, "ENDLABEL:", e$	
		
p_affiche_cycle832_prismatique	# sans le cycle 832 --> OPs UNIQUEMENT 3D
	n$, s_com_open, "LISSAGE OPERATIONS 3D, VALEURS FIXES", s_com_close, e$ 
	n$, "ANNUL_DU_LISSAGE_3D:", e$
	n$, "SOFT ; gestion des accouts", e$
	n$, "FFWOF ; désactiv. de l'anticipation", e$
	n$, "G64 ; mode arrondi des coins, normal", e$
	n$, "DYNNORM ; PASSE EN MODE NORMAL", e$
	n$, "ENDLABEL:", e$
	*e$
	n$, "LISSAGE_DE_FINITION_3D:", e$
	n$, "SOFT ; gestion des accouts", e$
	n$, "FFWON ; activ. de l'anticipation", e$
	n$, "FIFOCTRL ; activ. du controle de la mémoire", e$
	n$, "G60 ; activ. le passage par le point", e$
	n$, "COMPOF ; desactiv. la fonction compresseur", e$ 
	linarc$ = zero  		# Avec compressor off (COMPOF), réalisation d arcs
	n$, "DYNFINISH ; stratégie de FINITION", e$
	n$, "ENDLABEL:", e$
	*e$
	n$, "LISSAGE_DEMI_FINITION_3D:", e$
	n$, "SOFT ; gestion des accouts", e$
	n$, "FFWON ; activ. de l'anticipation", e$
	n$, "FIFOCTRL ; activ. du controle de la mémoire", e$
	n$, "G645 ; vitesse de contournage constante", e$
	n$, "COMPCAD ; activ. du compactage Type BSpline", e$
	n$, "DYNSEMIFIN ; stratégie de DEMI-FINITION", e$
	n$, "CTOL=0.05 ; tolérance d'usinage", e$ 
	n$, "ENDLABEL:", e$ 
	*e$
	n$, "LISSAGE_D_EBAUCHE_3D:", e$
	n$, "BRISK ; déplacements avec accélération maximale", e$
	n$, "FFWON ; activ. de l'anticipation", e$
	n$, "FIFOCTRL ; activ. du controle de la mémoire", e$
	n$, "G64 ; mode arrondi des coins, ébauche", e$
	n$, "COMPCAD ; activ. du compactage Type BSpline", e$
	n$, "DYNROUGH ; stratégie D'EBAUCHE", e$
	n$, "CTOL=0.1 ; tolérance d'usinage", e$
	n$, "ENDLABEL:", e$

#-------------------------------------------------------------
#fmt       2 tollisang
fmt     2 lissage
fmt     2 tolerance_usinage_3D
fmt     2 OLD_tolerance_usinage_3D
fmt     2 tolerance_usinage_2D
fmt     2 OLD_tolerance_usinage_2D
fmt     2 tolerance_usinage_5x
fmt     2 tolerance_usinage_REEL 
fmt     2 tolerance_usinage_max_pcent 
fmt     2 OLD_tolerance_usinage
fmt     4 Type_lissage
fmt     2 tol_tab_Cycle832
fmt     2 tol_tab_Cycle832_aff
fmt  "" 4 cycle832_format
p_lissage	
	if Mode_reglage_PP = 0, p_aff_infos_cycle832
	
	# INFOS CYCLE 832
	#
	#2eme valeur peut Etre A 
	# 3 AXES
    #    _OFF
    #    _FINISH
    #    _SEMIFIN
    #    _ROUGH
	# 4/5 AXES
    #    _ORI_FINISH
    #    _ORI_SEMIFIN
    #    _ORI_ROUGH
	# 3/4/5 axes usinage de SURFACES, balayage
    #    _TOP_SURFACE_SMOOTH_OFF
    #    _TOP_SURFACE_SMOOTH_ON	
	
	!Type_lissage,!OP_Surface_ebauche,!OP_Surface_finition,!hs_surf_style
	!cycle832_format,!tolerance_usinage_3D,!tolerance_usinage_max_pcent,!OLD_tolerance_usinage,!OP_percage
	
    if tolerance_usinage_5x <> 0, tolerance_usinage_3D = tolerance_usinage_5x
    if Type_lissage = 1 & OP_percage = 0,	[
        if affiche_com_cycle832 <> 1, [
			*e$
	        n$, "; 1er VAL.= tolerance d'usinage suivant la valeur de l'OP dans MasterCam", e$
	        n$, ";     < A 0.025 = finit. <=0.1 = demi-finit. >0.1 = ebauche", e$
	        n$, "; 2eme VAL.= TYPE d USINAGE", e$
	        n$, "; 3eme VAL.= Tolerance d'orientation en DEGRES", e$
			affiche_com_cycle832 = 1
			]
		spaces$ = 0
        if mi9$ = 1 & mr7$ > 0 & mr9$ > 0 & mr10$ > 0 & (prv_mr7$ <> mr7$ | prv_mr8$ <> mr8$ | prv_mr9$ <> mr9$ | prv_mr10$ <> mr10$ ),	[
            n$, "; ATTENTION valeurs de tolérances forcées", e$
            if mr9$ = 1, n$, "CYCLE832(", *mr7$, ",_FINISH,", *mr8$ ")", e$
			if mr9$ = 2, n$, "CYCLE832(", *mr7$, ",_SEMIFIN,", *mr8$ ")", e$
			if mr9$ = 3, n$, "CYCLE832(", *mr7$, ",_ROUGH,", *mr8$ ")", e$	
			OLD_tolerance_usinage_2D = mr7$	
			OLD_tolerance_usinage_3D = mr7$		
            ]
        else,	[	# OPs 3D
            if (OP_Surface_ebauche = 1 | OP_Surface_finition = 1) & (tolerance_usinage_3D <> OLD_tolerance_usinage_3D), [
				n$, "; Lissage OPs 3D", e$
				if tolerance_usinage_max_pcent > tolerance_usinage_3D, tolerance_usinage_3D = tolerance_usinage_max_pcent
				if tolerance_usinage_3D <= 0.025, n$, "CYCLE832(", *tolerance_usinage_3D, ",_FINISH,1)", e$									#",_ORI_FINISH,",
	            if tolerance_usinage_3D > 0.025 & tolerance_usinage_3D < 0.05, n$, " CYCLE832(", *tolerance_usinage_3D, ",_SEMIFIN,1)", e$	#",_ORI_SEMIFIN,0.1)",
	            if tolerance_usinage_3D >= 0.05, n$, "CYCLE832(", *tolerance_usinage_3D, ",_ROUGH,1)", e$									#",_ORI_ROUGH,0.8)",
	            #n$, "CYCLE832(", *tolerance_usinage_3D, ",_ORI_FINISH,", *tollisang, ")", e$
				OLD_tolerance_usinage_3D = tolerance_usinage_3D
				]
        	if (OP_Surface_ebauche <> 1 & OP_Surface_finition <> 1) 	# OPs 2D
				& ((tolerance_usinage_REEL <> OLD_tolerance_usinage_2D) | (tolerance_usinage_2D <> OLD_tolerance_usinage_2D)), [	
	            if tolerance_usinage_REEL > 0, tolerance_usinage_2D = tolerance_usinage_REEL # Si filtrage alors tol 2D = val de filtrage dans l'OP MC
				#,  & (tolerance_usinage_REEL <> OLD_tolerance_usinage)
				n$, "; Lissage OPs 2D", e$
				if tolerance_usinage_2D <= 0.025, n$, "CYCLE832(", *tolerance_usinage_2D, ",_FINISH,1)", e$
				if tolerance_usinage_2D > 0.025, n$, "CYCLE832(", *tolerance_usinage_2D, ",_SEMIFIN,1)", e$
				OLD_tolerance_usinage_2D = tolerance_usinage_2D									
            	]    	
			]
        lissage = 1
        #OLD_tolerance_usinage = tolerance_usinage_3D
		spaces$ = 0
        ]
	if Type_lissage = 11 & OP_percage = 0, [								# 11 = CYCLE832 ON avec prise en compte du type d'OPERATION
		lissage = 1
		!OP_Surface_ebauche, !OP_Surface_finition		
		if OP_Surface_ebauche = 1, cycle832_tech = 3, tol_tab_Cycle832_aff = 0.1	# EBAUCHE
		if OP_Surface_finition = 1 & (surep_XY_2D >0 | surep_Z_2D >0 | surep_XY_3D >0 | surep_Z_3D >0), cycle832_tech = 2, tol_tab_Cycle832_aff = 0.05	# SI SUREP FINITION --> DEMI-FINITION
		if cycle832_tech <> 2 & (OP_Surface_finition = 1 & (surep_XY_2D =0 | surep_Z_2D =0 | surep_XY_3D =0 | surep_Z_3D =0)), cycle832_tech = 1, tol_tab_Cycle832_aff = 0.01	# FINITION			
		
		#tol_tab_Cycle832_aff = flook (4, tolerance_usinage_3D)	??
		
		if cycle832_tech = 0 & OP_Surface_ebauche = 0 & OP_Surface_finition = 0, [	# force le mode finition pour les OPS 2D si rien de défini
			tol_tab_Cycle832_aff = tolerance_usinage_2D, cycle832_tech = 1			# tolérance de l'opération
			]
		
		if cycle832_format = 1, [	#(0, 1, 2, 3)
			n$, s_com_open, "EN DEVELOPPEMENT", s_com_close, e$
			]
		if cycle832_format = 2, [	#(_OFF, _FINISH, _SEMIFIN, _ROUGH)
			# FORCE 
			if cycle832_from_miscval = 1, cycle832_tech = mr9$, tol_tab_Cycle832_aff = mr10$
			# 			
			if cycle832_tech = 3, s_cycle832_utilise = s832_adv_tech3	#Rough
			if cycle832_tech = 2, s_cycle832_utilise = s832_adv_tech2	#Semi-Finish
			if cycle832_tech = 1, s_cycle832_utilise = s832_adv_tech1	#Finish	
			n$, "CYCLE832(", no_spc$, *tol_tab_Cycle832_aff, no_spc$, ",", no_spc$, *s_cycle832_utilise, no_spc$, ",1)", e$	
			]
		if cycle832_format = 3 | cycle832_format = 32, [	# "31" --> 1000000, 1000001, 1000002, 1000003 ou "32" --> 2000000, 2000001, 2000002, 2000003
			# CYCLE832(_TOL, _TOLM)
			#	_TOL 	-->tolérance
			#   _TOLM 	--> 7 6 5 4 3 2 1 0		*=par défaut	Configuration pouvant être différente suivant les constructeurs
			#				7 --> 0 non utilisé		1 SANS Smoothing	2 AVEC Smoothing
			#				6 --> 0 non utilisé
			#				5 --> 0=COMPOF*	1=COMPCAD 	2=COMPCURV	3=Spline B
			#				4 --> 0=FFWOF SOFT*	1=FFOWON SOFT	2=FFWOF BRISK
			#				3 --> 0=G64	1=G6412	2=G642* 
			#				2 --> 0=TRAFFOF*	1=TRAORI(1)	2=TRAORI(2)
			#				1 --> 0=//	1=//
			# 				0 --> 0=RIEN/OFF	1=FINITION*	2=SEMI-FINITION	3=EBAUCHE
			# FORCE 
			if cycle832_from_miscval = 1, cycle832_tech = mr9$, tol_tab_Cycle832_aff = mr10$
			# 			
			if cycle832_format = 3,	[
				if cycle832_tech = 3, s_cycle832_utilise = s832_num_tech3	#Rough
				if cycle832_tech = 2, s_cycle832_utilise = s832_num_tech2	#Semi-Finish
				if cycle832_tech = 1, s_cycle832_utilise = s832_num_tech1	#Finish	
				]
			if cycle832_format = 32, [
				if cycle832_tech = 3, s_cycle832_utilise = s832_num2_tech3	#Rough
				if cycle832_tech = 2, s_cycle832_utilise = s832_num2_tech2	#Semi-Finish
				if cycle832_tech = 1, s_cycle832_utilise = s832_num2_tech1	#Finish	
				]
			n$, "CYCLE832(", no_spc$, *tol_tab_Cycle832_aff, no_spc$, ",", no_spc$, *s_cycle832_utilise, no_spc$, ")", e$	
			]
		if cycle832_format = 4, [	#(_TOP_SURFACE_SMOOTH_OFF+_FINISH, _TOP_SURFACE_SMOOTH_ON+_FINISH, _TOP_SURFACE_SMOOTH_OFF+_ROUGH, etc.)
			# FORCE 
			if cycle832_from_miscval = 1, cycle832_tech = mr9$, tol_tab_Cycle832_aff = mr10$
			#
			if cycle832_tech = 3, cycle832_top_tech = 7, s_cycle832_utilise = s832_top_tech3s	#Rough
			if cycle832_tech = 2, cycle832_top_tech = 5, s_cycle832_utilise = s832_top_tech2s	#Semi-Finish
			if cycle832_tech = 1, cycle832_top_tech = 3, s_cycle832_utilise = s832_top_tech1s	#Finish
			#if cycle832_top_tech = 1, s_cycle832_utilise = s832_top_tech0s	#OFF
			n$, "CYCLE832(", no_spc$, *tol_tab_Cycle832_aff, no_spc$, ",", no_spc$, *s_cycle832_utilise, no_spc$, ",1)", e$
			]					
		]
	
	if Type_lissage = 2 & OP_percage = 0, n$, "CYCLE832(0,_OFF,1)", e$	# Toujours sur OFF
	if Type_lissage = 3 & OP_percage = 0, [		# 3 = EMULATION du CYCLE832 MODE PRISMATIQUE  --> MACHINES SANS L'OPTION CYCLE 832
		lissage = 1
		!OP_Surface_ebauche, !OP_Surface_finition
		if OP_Surface_ebauche = 1 | (surep_XY_3D > 0 | surep_Z_3D > 0), cycle832_tech = 3	# EBAUCHE
		if OP_Surface_finition = 1 & (surep_XY_2D > 0 | surep_Z_2D > 0 | surep_XY_3D > 0 | surep_Z_3D > 0), cycle832_tech = 2	# SI SUREP FINITION --> DEMI-FINITION
		if OP_Surface_finition = 1 & surep_XY_2D = 0 & surep_Z_2D = 0 & surep_XY_3D = 0 & surep_Z_3D = 0, cycle832_tech = 1	# FINITION			
		if cycle832_tech <> old_cycle832_tech, [
			if cycle832_tech = 1, n$, "REPEAT LISSAGE_DE_FINITION_3D", e$, lissage_3d_actif = 1  
			if cycle832_tech = 2, n$, "REPEAT LISSAGE_DEMI_FINITION_3D", e$, lissage_3d_actif = 1   
			if cycle832_tech = 3, n$, "REPEAT LISSAGE_D_EBAUCHE_3D", e$, lissage_3d_actif = 1 
			old_cycle832_tech = cycle832_tech
			]			
		]

p_lissage_off
	#"LISSAGE OFF", *Type_lissage, *lissage, *old_cycle832_tech, e$	
	if Type_lissage = 1 & lissage = 1,	[
	    n$, "CYCLE832(0,_OFF,1)", e$
	    ]
	if Type_lissage = 11 & lissage = 1,	[
		if cycle832_format = 2, s_cycle832_utilise = s832_adv_tech0, n$, "CYCLE832(0,", no_spc$, s_cycle832_utilise, no_spc$, ",1)", e$ 
		if cycle832_format = 3, s_cycle832_utilise = s832_num_tech0, n$, "CYCLE832(0,", no_spc$, s_cycle832_utilise, no_spc$, ")", e$ 
		if cycle832_format = 32, s_cycle832_utilise = s832_num2_tech0, n$, "CYCLE832(0,", no_spc$, s_cycle832_utilise, no_spc$, ")", e$ 
		if cycle832_format = 4, [
			if cycle832_tech = 3, cycle832_top_tech = 6, s_cycle832_utilise = s832_top_tech3	#Rough
			if cycle832_tech = 2, cycle832_top_tech = 4, s_cycle832_utilise = s832_top_tech2	#Semi-Finish
			if cycle832_tech = 1, cycle832_top_tech = 2, s_cycle832_utilise = s832_top_tech1	#Finish
			if cycle832_tech = 0, cycle832_top_tech = 0, s_cycle832_utilise = s832_top_tech0	#OFF
			n$, "CYCLE832(0,", no_spc$, s_cycle832_utilise, no_spc$, ",1)", e$
			]    
	    ]
	if Type_lissage = 3 & OP_percage = 0, [	# & lissage = 1
		@old_cycle832_tech
		if old_cycle832_tech > 0, n$, "REPEAT ANNUL_LISSAGE_2D", e$
		cycle832_tech = 0
		old_cycle832_tech = -1
		]
	lissage = 0
#endregion

p_debut_renvoi_angle
	if ra_type$ = 1 & ra_block$ >0, [	# 1 =renvoie d'angle actif et NUM choix du multibroche
		lg_port_out_outil_block = paramT49 + paramT22
		n$, "R599 =", *lg_port_out_outil_block,  s_com_open, "LONGUEUR TOTALE DU PORTE OUTIL ET OUTIL :RENVOI D ANGLE ", s_com_close, e$
		n$, s_com_open, "DEPUIS L AXE BROCHE AU BOUT D OUTIL", s_com_close, e$
		n$, s_com_open, "POUR INFO, LONG. DE SORTIE OUTIL SOUS LA PINCE:", *paramT22, s_com_close, e$
		n$, s_com_open, "COTE DEPUIS L AXE Z A LA FACE DU PORTE OUTIL:", *paramT49, s_com_close, e$
		p_dec_renvoi_angle 
		]
	
#region renvoie_d'angle
p_dec_renvoi_angle
	#20001
	#135.00 / 90.00 - Numéro porte-outil	#valeurs suivant ANGLES-DROIT 1-Horizontal et 2-Vertical 90= à plat
	#135.00 / 30.00 - Numéro porte-outil	#valeurs suivant ANGLES-CIRCULAIRE 1-Horizontal et 2-Vertical "5 AXES"
	#20008
	#0. 0. 1. 0 0. 0. 0 0. 29.99	29.99--> longueur de L'AXE Z à la FACE du PORTE PINCE (TOUT ANGLES)
	#1028
	#1 1 0.8660254 -0.5 0. -0.70710678 0.70710678 0. 222 0 0 0	
	#1029
	#0. 0. 0. 0. 0. 0. 1.999 2.999 3.999 0 0 	decalage renvoie X1.999 Y2.999 Z3.999	val-->11	0=fixe 1=rotatif
	#20007
	#0. 13. 41.99 27. 8. 50. 25. 0 100. 100. 1 41.99 25.	41.99 longueur sortie outil
	# PRMCODE --> # Nci 1029 val 11	0=fixe 1=rotatif 15813 à 15829
	#rotaxtyp$ = 4	#POINTS depuis la vue de dessus NE FONCTIONNE PAS EN V2023 !
	if m8$ = 1, n$, "TRANS Y=R599", e$		# suivant G18 XZ
	if m8$ = -1, n$, "TRANS Y=-R599", e$	# suivant G18 XZ		
	if m7$ = 1, n$, "TRANS X=R599", e$		# suivant G19 YZ
	if m7$ = -1, n$, "TRANS X=-R599", e$	# suivant G19 YZ
	#if m7$ <> 0 & m8$ <> 0, [
	   	Angle_PLAN_MC_renvoie_angle = atan2(-m8$,-m7$)	
		decX = (cos(Angle_PLAN_MC_renvoie_angle)*50) * -1
		decY = (sin(Angle_PLAN_MC_renvoie_angle)*50) #* -1	
		if ra_rot_head$ = 1, n$, s_com_open, "RENVOIE D ANGLE -CIRCULAIRE-", s_com_close, e$
		if ra_rot_head$ = 0, n$, s_com_open, "RENVOIE D ANGLE -FIXE-", s_com_close, e$
		n$, "R510 = ", *Angle_PLAN_MC_renvoie_angle, s_com_open, "ANGLE A plat MasterCam", s_com_close, e$
		n$, "R511 = (cos(R510)*R599) * -1", e$
		n$, "R512 = (sin(R510)*R599) ", e$
		n$, "TRANS X=R511 Y=R512", e$
		n$, s_com_open, "DECALAGE CALCUL PP:", *decX, *decY, s_com_close, e$
		n$, s_com_open, "ANGLE DU PLAN= ", *Angle_PLAN_MC_renvoie_angle, "DEG", s_com_close, e$
		n$, s_com_open, "INFOS DU PORTE OUTIL :", s_com_close, e$
		ANGLE_XY_renvoie_angle = atan2(ra_svecx$,-ra_svecy$)-90
		n$, s_com_open, "ANGLE PHYSIQUE XY = ", *ANGLE_XY_renvoie_angle, s_com_close, e$
		if ra_svecz$ = 0, ANGLE_Z_renvoie_angle = 90
		n$, s_com_open, "ANGLE PHYSIQUE A PLAT=90D :", *ANGLE_Z_renvoie_angle, s_com_close, e$
		n$, s_com_open, "NUM. du RENVOI MC= ", *ra_block$, s_com_close, e$
		n$, s_com_open, "0=FIXE 1=ROTATIF MC=", *ra_rot_head$, s_com_close, e$	# Nci 1029 val 11	0=fixe 1=rotatif
		n$, s_com_open, "TYPE DE RENVOI MC= ", *ra_type$, s_com_close, e$		# 0=No special HEAD 1= Right-Angle 2=Compound 3=Block drill 4=UST
		*e$
		#]
	# Sauvegarde de la configuration avant de forcer la config avec le renvoie d'angle 
	old_usecandrill = usecandrill$    	# utiliser cycle percage lamage
    old_usecanpeck  = usecanpeck$    	# utiliser cycle debourrage
    old_usecanchip  = usecanchip$    	# utiliser cycle brise copeaux
    old_usecantap   = usecantap$    	# utiliser cycle taraudage
    old_usecanbore1 = usecanbore1$    	# utiliser cycle alesage a l'alesoir
    old_usecanbore2 = usecanbore2$    	# utiliser cycle alesage a la barre
    old_usecanmisc1 = usecanmisc1$    	# utiliser cycle divers 1
    old_usecanmisc2 = usecanmisc2$    	# utiliser cycle divers 2
	# Forcer cette configuration avec le renvoie d'angle
	usecandrill$ = 0   	# utiliser cycle percage lamage
	usecanpeck$  = 0   	# utiliser cycle debourrage
	usecanchip$  = 0   	# utiliser cycle brise copeaux
	usecantap$   = 0   	# utiliser cycle taraudage
	usecanbore1$ = 0   	# utiliser cycle alesage a l'alesoir
	usecanbore2$ = 0  	# utiliser cycle alesage a la barre
	usecanmisc1$ = 0	# utiliser cycle divers 1
	usecanmisc2$ = 0   	# utiliser cycle divers 2
	
	if ss$ > 2000, ss$ = S_maxi_renvoi_angle	
	sauve_ra_tc_type_ = ra_tc_type$ 
	sauve_ra_block_ = ra_block$
	p_erreur_num_block_renvoie_angle
	if ra_rot_head$ = 0, p_erreur_angles_renvoie_angle
	#if type_renvoie_angle = 2, p_erreur_angles_renvoie_angle_2 # SI CONTRAINTE ANGULAIRE exemple 4*90deg .... 
	old_Angle_PLAN_MC_renvoie_angle = Angle_PLAN_MC_renvoie_angle
	
p_test_arcs_tete_renvoi
	if ra_type$ = 1 & ra_block$ >0, [
		if m8$ <> 1 & m8$ <> -1 & m7$ <> 1 & m7$ <> -1 & m9$ <> 1, linarc$ = 1		# Casse les arcs en lignes si pas G17-G18-G19
		else, linarc$ = 0
		]

#endregion

#region correction_rayon
# -------------------------LECTURE DES PARAMETRES DE surep_XY_2D ET DE TYPE DE CORRECTION--------------------------------------------
param_comp   # Type de correction d'outil au changement d'operation	--- TEXTE
    if info_corr = 1, [
        if op_id$ <> old_op_id, [       
			#cc_comp 41 42 0
	        #cc_pos   1  2 0
	        @cc_computer$, @cc_pos$, @cc$                  		# rappel des variables
			#*cc$, *cc_pos$, *cc_computer$, *opcode$, *tool_op$, e$
	        if cc$ = 0 & cc_computer$ = 0, type_comp = 0    #AUCUNE
	        if cc$ = 42 & cc_computer$ = 0, type_comp = 1   #ARMOIRE DROITE
	        if cc$ = 41 & cc_computer$ = 0, type_comp = 2   #ARMOIRE GAUCHE
	        if cc$ = 0 & cc_computer$ = 42, type_comp = 3   #ORDINATEUR DROITE
	        if cc$ = 0 & cc_computer$ = 41, type_comp = 4   #ORDINATEUR GAUCHE
	        if cc$ = 42 & cc_computer$ = 42, type_comp = 5  #USURE DROITE
	        if cc$ = 41 & cc_computer$ = 41, type_comp = 6  #USURE GAUCHE
	        if cc$ = 41 & cc_computer$ = 42, type_comp = 7  #USURE INVERSE DROITE
	        if cc$ = 42 & cc_computer$ = 41, type_comp = 8  #USURE INVERSE GAUCHE	
			# filetages à la fraise --> bricollage
			if cc$ = 41 & cc_computer$ = 42 & tool_op$ = 100, type_comp = 6	#USURE GAUCHE
			#
			if cc$ = 0 & opcode$ >= 5 & opcode$ <> 19, type_comp = 9 	#CORREC. ORDI. 3D 	15346=0 15326=1
	        if opcode$ = 19, type_comp = 0           						# mis sur aucune a la place d'ordinateur
	        if opcode$ <> 3 & opcode$ <> 16, n$, s_com_open, *stype_comp, s_com_close, e$   # pour ne pas afficher si percage		
	        ]
    	]
#----------------------------------------------------------------
pcorrecteur_D   # Compensation outil ray.
	if cc$ = 41, *sccomp, old_cc = cc$
	if cc$ = 42, *sccomp, old_cc = cc$
	if cc$ = 140, "G40", old_cc = cc$

#endregion

#region Surepaisseurs
param_surep
    if info_surep = 1,	[
		# surep XY & Z OPs 2D 
		if opcode$ <> 3 & opcode$ < 5  & opcode$ <> 19,	[	
            if (surep_XY_2D <> old_surep_XY_2D) | (surep_Z_2D <> old_surep_Z_2D),	[
                n$, s_com_open, *surep_XY_2D, s_com_close, e$
                n$, s_com_open, *surep_Z_2D, s_com_close, e$
				old_surep_XY_2D = surep_XY_2D
	    		old_surep_Z_2D = surep_Z_2D
                ]
            ]
        # surep 3d
		if opcode$ <> 3 & opcode$ >= 5 & opcode$ <> 19, [
            if surep_XY_3D <> old_surep_XY_3D, n$, s_com_open, *surep_XY_3D, s_com_close, e$
            if surep_Z_3D <> 0, n$, s_com_open, *surep_Z_3D, s_com_close, e$
			old_surep_XY_3D = surep_XY_3D
			old_surep_Z_3D = surep_Z_3D
			]
        # surep pour surfaçage
		if opcode$ = 19, [
            if surep_Z_surf_2D <> old_surep_Z_2D, n$, s_com_open, *surep_Z_surf_2D, s_com_close, e$
            old_surep_Z_2D = surep_Z_surf_2D
			]         		
		]  
#endregion

p_Z_mini_maxi_OP
	if output_z = 1, [
		preadbuf5
		n$, s_com_open, "MAX OUTIL ", *max_depth, s_com_close, e$
    	n$, s_com_open, "MIN OUTIL ", *min_depth, s_com_close, e$	
		]
		
p_vit_rot_max     # vitesse max / gamme vit de rotation
	if ss$ > maxss$, ss$ = maxss$ 

p_rot_perc_profond  # ROT BROCHE POUR PERCAGE PROFOND	
	if posi_p_prof = 1, 	# hors matière
		[
		ssa = ssa * 0.1
		if ssa > 500, ssa = 500
		]
	if posi_p_prof = 2, ssa = ss$	# dans la matière

fmt  "OP. MC. :" 4 op_number  #Operation number as seen in the Operations Manager
p_num_op_MC	
	if affiche_num_op_MC = 1, [ 
		sOpId = no2str(op_id$)
		result = dll(sdllTimeOp,sOpId)
		if spost_arg_2$ <> s_old_spost_arg_2, n$, s_com_open, "OP. MC. :", spost_arg_2$, s_com_close, e$
		s_old_spost_arg_2 = spost_arg_2$
		]
	#if affiche_num_op_MC = 2, if comm_cnt$ = zero, n$, s_com_open, *op_number, scomm$, s_com_close, e$  #Comment using MSG("") - When no op comment was entered, output just the op number
	if affiche_num_op_MC = 2, n$, s_com_open, *op_number, s_com_close, e$  #Comment using MSG("") - When no op comment was entered, output just the op number

p_affiche_type_op_MC
	if affiche_type_op_MC = 1 & affiche_type_op_MC <> old_affiche_type_op_MC, 
		[
		if tool_op$ > 99 & tool_op$ < 109, tool_op$ = tool_op$ + 18
		if tool_op$ > 200 & tool_op$ < 240, tool_op$ = tool_op$ + 83
		if tool_op$ > 415 & tool_op$ < 462, tool_op$ = tool_op$ + 77
		n$, s_com_open, *s_too_lop, s_com_close, e$ 
		old_affiche_type_op_MC = affiche_type_op_MC	
		!tool_op$ 
		]
				   
p_annule_decalage   
    memo_incremental = incremental
    incremental = 0
    sub_trnsx$ = 0
    sub_trnsy$ = 0
    sub_trnsz$ = 0
    #n$, sinc_abs, "G52", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$
    n$, "TRANS", e$
    decalage = 0
    incremental = memo_incremental
	
#   Gestion des gammes de vitesse de broche
pgamme
    @ssa
    #if ssa < 1500, "M38"
    #else, "M39

#---------------------------------
P_f_val_origine_depart_idem 
	Old_Val_origine_Z = Val_origine_Z
	Old_Val_origine_Y = Val_origine_Y
	Old_Val_origine_X = Val_origine_X
	Sold_snom_RUD = snom_RUD    	
	
#region Minis_maxis_usinages
ptravel    # Tool travel limit calculation
	if x_min$ < x_tmin, x_tmin = x_min$
	if x_max$ > x_tmax, x_tmax = x_max$
	if y_min$ < y_tmin, y_tmin = y_min$
	if y_max$ > y_tmax, y_tmax = y_max$
	if z_min$ < z_tmin, z_tmin = z_min$
	if z_max$ > z_tmax, z_tmax = z_max$

# --------------------------------------------------------------------------
# Buffer 5  Read / Write Routines
# --------------------------------------------------------------------------
pwritbuf5   # Write Buffer 1
	b5_gcode = gcode$
	b5_zmin = z_min$
	b5_zmax = z_max$
	b5_gcode = wbuf(5, wc5)

preadbuf5   # Read Buffer 1
	size5 = rbuf(5,0)
	b5_gcode = 1000
	min_depth = 999
	max_depth = -999
	while rc5 <= size5 & b5_gcode = 1000,	[
		if rc5 <= size5, b5_gcode = rbuf(5,rc5)
		if b5_zmin < min_depth, min_depth = b5_zmin
		if b5_zmax > max_depth, max_depth = b5_zmax
		]

#endregion	   

#region Mzero
p_mZERO
    if utilise_prog_reg_usi = 1, [
		if type_pp_SIEMENS = 1, n$, "IF R99==1", e$
	    if type_pp_SIEMENS = 2, n$, "IF (R99==1)", e$
	    n$, "M0", e$
	    n$, "ENDIF", e$
		]
	else, n$, "M01", e$
#endregion

#region inspection_outil
ptool_insp      # inspection des plaquettes/outil
	n$, "SUPA G0 Z-1. D0", e$    #retour aux origines en Z
	if prmcode$ = 29999,    #seulement le commentaire dans le controle d'outil
	    [
	    sparameter$ = ucase(sparameter$)
	    n$, "M0 ;", sparameter$, e$
	    ]
	else, n$, "M0", e$
	n$, "; controle de l etat des plaquettes - outil", e$
	strtool$ = ucase(strtool$)
	smanu = ucase(smanu)
	n$, ";", strtool$, smanu, e$
	n$, p_dec_outil, e$
	n$, *spdlon, e$
	old_lubrif = -1
	n$, p_lubrif_ON, e$
#endregion

#region test_bris_outil
p_test_bris_outil                    # controle bris outil
	type_test_bris_outils = mi5$
	Test_bris_outils = mi6$ 
    if type_test_bris_outils <> 0, 	[
		if type_test_bris_outils = 1,	[
			n$, s_com_open, "CYCLE NUM. 1 DE BRIS D OUTIL A DEFINIR", s_com_close, e$ 
			n$, s_com_open, "TEST BRIS OUTIL FORET", s_com_close, e$ 
			#n$, sbris_outil1, e$
			]
		if type_test_bris_outils = 2,	[
			n$, s_com_open, "CYCLE NUM. 2 DE BRIS D OUTIL A DEFINIR", s_com_close, e$ 
			n$, s_com_open, "TEST BRIS OUTIL FRAISE", s_com_close, e$ 
			#n$, sbris_outil2, e$
			]
		if type_test_bris_outils = 3,	[
			n$, s_com_open, "CYCLE NUM. 3 DE BRIS D OUTIL A DEFINIR", s_com_close, e$  
			]		
		type_test_bris_outils = 0
		Test_bris_outils = 0
		]
#endregion

#region transition_palpages_tlchg0
p_palpages_tlchg0
	gcode$ = 1
	if prv_drill_cycl = 16,
	    [
	    spaces$ = 1
	    n$, *sgcode, "MEAS=1", *xr$, *yr$, "F=V_SPEED", e$
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    n$, *sgcode, "MEAS=1", *zr$, "F=V_SPEED",e$
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    ]
	if prv_drill_cycl <> 16,
	    [
	    spaces$ = 1
	    n$, *sgcode, "MEAS=1", *zr$, "F=V_SPEED",e$
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    n$, *sgcode, "MEAS=1", *xr$, *yr$,  e$
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    ]
#endregion

#endregion

#region erreurs
#-------------------------------------------------------------------------
s_erreur_message_0 		: ""
s_erreur_message 		: ""
serreur2        		: "nbr_combi_axes > 1, qu'une combinaison d'axe par programme"
serreur2_2        		: "Utilisation d'un BLOCK de revoie d'angle ou nbr_combi_axes > 1, qu'une combinaison d'axe par programme"
serreur3        		: "combinaison d'axe impossible, rotation en X sur B MODIFIER LE PLAN DE ROTATION"
serreur4        		: "combinaison d'axe impossible, rotation en Y sur A MODIFIER LE PLAN DE ROTATION"
serreurTar      		: "Erreur - Taraud avec un autre cycle"
serreurPalp1    		: "ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
serreurPalp2    		: "ATTENTION SENS DE PALPAGE X ERRONE"
serreurPalp3    		: "ATTENTION SENS DE PALPAGE Y ERRONE" 												# op_id$," AVEC OUTIL ",t$,e$
serreurPalp4    		: "ATTENTION VALEUR <=0 DANS - Cycle de palpage Pt de rEf. INTER ou EXTER COIN"     # op_id$," AVEC OUTIL ",t$,e$
serreurPalp5    		: "PALPAGE -ATTENTION PAS DE DECALAGE D ACTIVE _KNUM = G54, G55..."   				#, op_id$," AVEC LE PALPEUR", e$, "---",e$
serreurPalp6    		: "PALPAGE -ATTENTION VALEURS DE _ID ET _SETVAL[0] EN POSITIF"
serreurCC_Cor   		: "ATTENTION PRISE DE CORRECTION SUR UN CERCLE"
s_messagePalp1_1 		: "ATTENTION prEvoir A  la SUITE -UNE REFERENCE EN Z sur la face avec le nouveau plan CYCLE978"
s_messagePalp1_2 		: "MESURE D ANGLE en X OU Y AVEC REFERENCE sur la face vertic. avec le nouveau plan CYCLE998"
s_messagePalp1_3 		: "REFERENCE EN X sur la face vertic. avec le nouveau plan CYCLE978"
s_messagePalp1_4 		: "REFERENCE EN Y sur la face vertic. avec le nouveau plan CYCLE978"
s_messageBroche  		: "ATTENTION il n'y a pas de vitesse de broche"
s_erreur_prof_passe 	: "ATTENTION ***renseigner la profondeur de passe au PERCAGE"
s_erreur_origine_plan 	: "ATTENTION coordonnEe de l'origine du plan inclinE ne correspond A  l'origine de base"  
s_erreur_origine_plan2 	: "- POUR INFO - il peut Etre utilisE avec plusieurs piEces"  
s_erreur_Nom_RUD 		: "ATTENTION *** RUDs DIFFERENTS dans un meme programme ****" 
s_erreur_pas_fil 		: "ATTENTION RENSEIGNER LE PAS DU FILETAGE A  la fraise"    
s_erreur_pas_fil2 		: "ATTENTION l'outil et l'opEration non pas le meme PAS !" 
s_erreur_num_outil 		: "ATTENTION le numEro d'outil dEpasse les 60 !" 
s_erreur_tranf_plan 	: "ATTENTION transformation PLAN à plat ! Rotation sur Z !" 
s_erreur_dif_T_H_D 		: "ATTENTION num. d'outil est different du num -H- ou -D- !" 
s_erreur_avance_fil 	: "ATTENTION l'avance de filetage A  la fraise est TROP importante !" 
s_erreur_avanceS 		: "ATTENTION **INFORMER LA VALEUR DE --F-- DANS L OUTIL***" 
s_erreur_choix_axe 		: "ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
s_erreur_nbr_axes_rot 				: "le post-processeur ne supporte q'un axe rotatif"
s_erreur_choix_cycle_palpage 		: "CYCLES DE PALPAGES NON AUTORISE, VEUILLEZ CONTACTER FICAM POUR LES UTILISER"
s_erreur_stock_shape 				: "ERREUR - CONFIG. DU BRUT - Seulement rectangulaire ou Cylindrique supportEs CN." + no2asc(13) + no2asc(13) + "Info dans l'ISO, Solide-Maillage, Stl"
s_erreur_inclinaison_OP_5axes 		: "ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"
s_erreur_num_block_renvoie_angle 	: "ATTENTION ! Le numéro d'outil doit etre identique au numéro du BLOCK ORIENTABLE !"
s_erreur_angles_renvoie_angle 		: "ATTENTION ! L'ANGLE du PLAN n'est pas identique à l'angle du BLOCK ORIENTABLE !"
s_erreur_lub_perc_prof 				: "ATTENTION ! Opération de perçage très profond : l'arrosage sélectionné n'est pas au CENTRE OUTIL"
s_erreur_choix_palette 				: "erreur de choix de palette 1(A) ou 2(B) indiquez le nbr de pièces sur une des 2 palettes"
s_erreur_choix_axe_substitution 	: "ATTENTION ! erreur sur le choix de l'axe de substitution ! A CHANGER"
s_erreur_config_type_arc			: "ATTENTION ! erreur de config d'arcs au niveau armoire UNIQUEMENT -R- ou -IJK- en SIEMENS"
s_erreur_config_type_arc2			: "Veuillez le modifier dans la config. armoire"
s_erreur_config_type_arc3			: "Pour utiliser ce mode mettre la variable-erreur_type_arcs- liqne 145 du post-pro à -0-"
s_erreur_angles_renvoie_angle_2     : "ATTENTION ! L'ANGLE du PLAN n'est pas pris en charge par l'angle du BLOCK ORIENTABLE !"
s_erreur_S_maxi_renvoi_angle		: "ATTENTION ! S de rotation > S autorisé avec le renvoi d'angle --> la vitesse de broche passe au MAXIMUM AUTORISE!" 
s_erreur_angle_renvoi_fixe			: "ATTENTION ! Ce renvoi d'angle n'autorise pas de rotations !" 
#s_erreur_val_C_MM_perc				: "ATTENTION ! la valeur du choix du type % mm ne peut Etre à 0"  
s_erreur_val_inf_perc				: "ATTENTION ! la valeur Z de l'ammorce de perçage doit Etre inf."

p_erreur_messages
	if affiche_num_op_MC = 1, s_erreur_message_0 = "ATTENTION ERREUR A L'OP: " + s_old_spost_arg_2 + " AVEC L'OUTIL N° " + no2str(t$)
	if affiche_num_op_MC = 2, s_erreur_message_0 = "ATTENTION ERREUR A L'OP: " + no2str(op_number) + " AVEC L'OUTIL N° " + no2str(t$)
    result = mprint(s_erreur_message_0)
	
perreurTaraud   #"Erreur - Taraud avec un autre cycle"
	if paramT2 = 4 | paramT2 = 5,
	    [
		p_erreur_messages
	    "ERREUR NUM: 1", s_erreur_message_0, e$
	    result = mprint(serreurTar)
	    exitpost$
	    ]

PerreurCC_Cor   #"ATTENTION PRISE DE CORRECTION SUR UN CERCLE"
	@old_cc, @cc$
	if cc$ =41 | cc$ = 42 & old_cc <> cc$,
	    [
		p_erreur_messages
	    "ERREUR NUM: 2", s_erreur_message_0, "ANNULATION DE CORRECTEUR SUR MOUV. CIRC. OPERATION", e$
	    result = mprint(serreurCC_Cor)
	    exitpost$
	    ]
		
perreurPalp1    #"ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
	if (drl_prm1$ = 1 & drl_prm2$ = 1) | (drl_prm1$ = 0 & drl_prm2$ = 0),
	    [
		p_erreur_messages
	    "ERREUR NUM: 3", s_erreur_message_0, e$
	    result = mprint(serreurPalp1)
	    exitpost$
	    ]

perreurPalp2    #"ATTENTION SENS DE PALPAGE X ERRONE"
	if peck1$ < 0 | peck1$ > 1,
	    [
		p_erreur_messages
	    "ERREUR NUM: 4", s_erreur_message_0, e$
	    result = mprint(serreurPalp2)
	    exitpost$
	    ]

perreurPalp3    #"ATTENTION SENS DE PALPAGE Y ERRONE"
	if peck1$ < 0 | peck1$ > 1,
	    [
		p_erreur_messages
	    "ERREUR NUM: 5", s_erreur_message_0, e$
	    result = mprint(serreurPalp3)
	    exitpost$
	    ]

perreurPalp4    #"ATTENTION VALEUR <=0 DANS - Cycle de palpage Pt de rEf. INTER ou EXTER COIN"
	if (drl_prm4$ <= 0) | (drl_prm5$ <= 0) | (drl_prm7$ <= 0),
	    [
		p_erreur_messages
	    "ERREUR NUM: 6", s_erreur_message_0, e$
	    result = mprint(serreurPalp4)
	    exitpost$
	    ]

perreurPalp5    #"PALPAGE -ATTENTION PAS DE DECALAGE D ACTIVE _KNUM = G54, G55..."
	if dwell$ < 1,
	    [
		p_erreur_messages
	    "ERREUR NUM: 7", s_erreur_message_0, e$
	    result = mprint(serreurPalp5)
	    exitpost$
	    ]

perreurPalp6    #"PALPAGE -ATTENTION VALEURS DE _ID ET _SETVAL[0] EN POSITIF"
	if peck1$ <= 0 | peck2$ <= 0,
	    [
		p_erreur_messages
	    "ERREUR NUM: 8", s_erreur_message_0, e$
	    result = mprint(serreurPalp6)
	    exitpost$
	    ]

perreur_vit_broche
	if ssa = 0 & palpeur = 0 & posi_MORTAIS = 0, 
	    [
		p_erreur_messages
	    "ERREUR NUM: 9", s_erreur_message_0, e$
	    result = mprint(s_messageBroche)
	    #exitpost$
	    ]

Perreur_origine_plan    # OBSOLETE --> GENERE UN DECALLAGE DE COORDONNEES G52/TRANS/DEF 7 ... 
	if Val_origine_Z <> Old_Val_origine_Z | Val_origine_Y <> Old_Val_origine_Y | Val_origine_X <> Old_Val_origine_X,
    	[
		p_erreur_messages
        "ERREUR NUM: 10", s_erreur_message_0, e$
		result = mprint(s_erreur_origine_plan)
        result = mprint(s_erreur_origine_plan2)
        #exitpost$
        ]

Perreur_nom_RUD         # 2 ruds differents utilises dans un mEme programme
	if snom_RUD <> Sold_snom_RUD,
        [
		p_erreur_messages
        #"ERREUR NUM: 11", s_erreur_message_0, "REGENERER OPs SI BESOIN", e$
        #s_erreur_Nom_RUD, e$
        result = mprint(s_erreur_Nom_RUD)
        #exitpost$
        ]
	Sold_snom_RUD = snom_RUD

Perreur_prof_passe  #"ATTENTION ***renseigner la profondeur de passe au PERCAGE"
	if peck1$ = 0,
	    [
	    p_erreur_messages
		"ERREUR NUM: 12", s_erreur_message_0, e$
	    s_erreur_prof_passe, e$
	    result = mprint(s_erreur_prof_passe)
	    #exitpost$
	    ]

perreur_pas_fil  # "ATTENTION RENSEIGNER LE PAS DU FILETAGE A  la fraise"
	if tool_op$ = 100,
	    [
	    if pas_filetage = 9.999, [  # "ATTENTION RENSEIGNER LE PAS DU FILETAGE A  la fraise"
		    p_erreur_messages
			#"ERREUR NUM: 13", s_erreur_message_0, e$
		    result = mprint(s_erreur_pas_fil)
		    #exitpost$
		    ]
		if pas_filetage <> paramT7, [   # ""ATTENTION l'outil et l'opEration non pas le meme PAS !""
		    p_erreur_messages
			#"ERREUR NUM: 14", s_erreur_message_0, e$
		    result = mprint(s_erreur_pas_fil2)
		    #exitpost$
		    ]
	    #p_erreur_avance_fil 
	    ]

perreur_num_outil  # "ATTENTION le numEro d'outil dEpasse les 60 !" 
	if t$ > 60,
	    [
		#p_erreur_messages
	    #"ERREUR NUM: 15", s_erreur_message_0, e$
	    #result = mprint(s_erreur_num_outil)
	    #exitpost$
	    ]

perreur_tranf_plan # "ATTENTION transformation PLAN à plat !  Rotation sur Z !" 
    if (diviseur = 1 & m1$ <> 1) | (diviseur = 2 & m5$ <> 1), [
        p_erreur_messages
		"ERREUR NUM: 16", s_erreur_message_0, e$
        "ATTENTION VERIFIER SI LE NOUVEAU PLAN EST BIEN D EQUERRE PAR RAPPORT AU RUD", e$
        result = mprint(s_erreur_tranf_plan)
		n$, *m1$, *m2$, *m3$, *m4$, *m5$, *m5$, *m7$, *m8$, *m9$, e$
        ]
    if diviseur = 1 & m1$ <> 1, [
		p_erreur_messages
		"ERREUR NUM: 17", s_erreur_message_0, e$
        "ROTATION AXE MACHINE = ", s_axe_rot_A, e$
        "SOLUTION CREER LE NOUVEAU PLAN PAR RAPPORT AU RUD AVEC -PLAN ROTATION- DE X DEG. EN X,Y OU Z", e$
		]
    if diviseur = 2 & m5$ <> 1, [
		p_erreur_messages
		"ERREUR NUM: 18", s_erreur_message_0, e$
        "ROTATION AXE MACHINE = ", s_axe_rot_B, e$
        "SOLUTION CREER LE NOUVEAU PLAN PAR RAPPORT AU RUD AVEC -PLAN ROTATION- DE X DEG. EN X,Y OU Z", e$
		]

p_erreur_dif_T_H_D # "ATTENTION num. d'outil est different du num -H- ou -D- !"
	if t$ <> tloffno$ | t$ <> tlngno$ & opcode$ <> 3,
	    [
		p_erreur_messages
		#"ERREUR NUM: 19", s_erreur_message_0, e$
	    #s_erreur_dif_T_H_D, e$
	    result = mprint(s_erreur_dif_T_H_D)
	    #exitpost$
		]

p_erreur_avance_fil # "ATTENTION l'avance de filetage A  la fraise est TROP importante !"
	if fr_pos$ > 500,
	    [
	    p_erreur_messages
		"ATTENTION l'avance de filetage A  la fraise est TROP importante !", e$
	    "ERREUR NUM: 20", s_erreur_message_0, e$
	    result = mprint(s_erreur_avance_fil)
		result = mprint(s_erreur_message_0)
	    ]

p_erreur_avanceS    # "ATTENTION **INFORMER LA VALEUR DE --F-- DANS L OUTIL***"
	if drillcyc$ > 0 & frplunge$ = 0 | drillcyc$ = 0 fr_pos$ = 0,
	    [
	    "ATTENTION l'avance -F- EST A --0-- !", e$
	    "ERREUR NUM: 21", s_erreur_message_0, e$
	    #*drillcyc$, *frplunge$, *drillcyc$, *fr_pos$, e$
	    result = mprint(s_erreur_avanceS)
	    ]

p_erreur_choix_axe    # "ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
    p_erreur_messages
	"ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
    result = mprint(s_erreur_choix_axe)
    if diviseur = 1, "ROTATION AXE :", s_axe_rot_B, e$
    if diviseur = 2, "ROTATION AXE :", s_axe_rot_A, e$
    "ERREUR NUM: 22", s_erreur_message_0, e$
	
p_erreur_cycle_palpage
	p_erreur_messages
	n$, "CYCLES DE PALPAGES NON AUTORISE, VEUILLEZ CONTACTER FICAM POUR LES UTILISER", e$
	"ERREUR NUM: 23", s_erreur_message_0, e$
	result = mprint(s_erreur_choix_cycle_palpage)
	
p_erreur_inclinaison_OP_5axes    #: "ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"
    p_erreur_messages
	"ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"	
	"VEUILLEZ BLOQUER UN AXE SI POSSIBLE DANS L'OPERATION OU CHANGER D'OPERATION"
    result = mprint(s_erreur_inclinaison_OP_5axes)
    "ERREUR NUM: 24", s_erreur_message_0, e$
	exitpost$
	
p_erreur_num_block_renvoie_angle
	if t$ <> ra_block$, [
		p_erreur_messages
		"ERREUR NUM: 25", s_erreur_message_0, e$
		result = mprint(s_erreur_num_block_renvoie_angle)
		exitpost$
		]

p_erreur_angles_renvoie_angle 
	if ANGLE_XY_renvoie_angle <> Angle_PLAN_MC_renvoie_angle, [
		p_erreur_messages
		"ERREUR NUM: 26", s_erreur_message_0, e$
		result = mprint(s_erreur_angles_renvoie_angle)
		exitpost$
		]

p_erreur_lub_perc_prof
	if coolantx <> 4, [
		result = mprint(s_erreur_lub_perc_prof)
		]		

p_erreur_choix_axe_substitution 
	if diviseur = 1 & (rotaxis$ = -1 | rotaxis$ = 1), [
		p_erreur_messages
		"ERREUR NUM: 27", s_erreur_message_0, e$
		result = mprint(s_erreur_choix_axe_substitution)
		exitpost$
		]
	if diviseur = 2 & (rotaxis$ = -2 | rotaxis$ = 2), [
		p_erreur_messages
		"ERREUR NUM: 28", s_erreur_message_0, e$
		result = mprint(s_erreur_choix_axe_substitution)
		exitpost$
		]

p_erreur_config_type_arc
	s_com_open, "ERREUR NUM: 29", s_com_close, e$
	result = mprint(s_erreur_config_type_arc)
	result = mprint(s_erreur_config_type_arc2)
	result = mprint(s_erreur_config_type_arc3)

p_erreur_angles_renvoie_angle_2		# ICI ANGLES FIXES A INDIQUER --> ICI TETE A 4 fois 90DEG	
	if Angle_PLAN_MC_renvoie_angle <> 0 | Angle_PLAN_MC_renvoie_angle <> 90 | 
			Angle_PLAN_MC_renvoie_angle <> 180 | Angle_PLAN_MC_renvoie_angle <> 270, [
        p_erreur_messages
        "ERREUR NUM: 30", s_erreur_message_0, e$
        result = mprint(s_erreur_angles_renvoie_angle_2)
        exitpost$
        ]

p_erreur_perc_decomposes
	#if perc_1er_perc_pour_C_ou_mm = 0, [
		#p_erreur_messages
		#"ERREUR NUM: 31", s_erreur_message_0, e$
		#result = mprint(s_erreur_val_C_MM_perc)
		#]
	if P_er_perc_0 < P_er_perc_1 | peck1$ < P_er_perc_1, [
		p_erreur_messages
		"ERREUR NUM: 32", s_erreur_message_0, e$
		result = mprint(s_erreur_val_inf_perc)
		]		
#endregion 

#region percages

#region cycles_percages
#------------------------------- PERCAGES -----------------------------------
pcycle_pdrill   # Ecrire le cycle MCALL CYCLE81 (RTP,RFP,SDIS,DP,DPR) - MCALL CYCLE82 (RTP,RFP,SDIS,DP,DPR,DTB)
	if dwell$ = 0, n$, "MCALL CYCLE81("
	else, n$, "MCALL CYCLE82("
	spaces$ = 0
		*RTP
		","
		*RFP
		","
		*SDIS
		","
		if prof_cycle_Abs_Relatif = 1, *DP		# prof. en absolu
		","
		if prof_cycle_Abs_Relatif = 2, *DPR		# prof en relatif
		if dwell$ <> 0, ",", *DTB
		")", e$
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu) pour passage au dessus des brides
	OLD_RFP = RFP   					# MEMO Plan de rEfErence (en absolu) Z départ matière
	OLD_SDIS = SDIS 					# MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)

pcycle_ppeck_chpbrk    # Ecrire le cycle MCALL CYCLE83 (RTP,RFP,SDIS,DP,DPR,FDEP,FDPR,DAM,DTB,DTS,FRF,VARI,_AXN,_MDEP,_VRT,_DTD,_DIS1)
	FDPR = peck1$
	DAM = peck2$    				# DEgression : (introduire sans signe) valeurs : > 0 dEgression en tant que valeur - < 0 facteur de dEgression - = 0 pas de dEgression
	if DAM < -0, DAM = abs(DAM)		# DEgression : < 0 facteur de dEgression - = 0 pas de dEgression
	DTS = shftdrl$     				# Temporisation au point de dEpart et pour dEbourrage Valeurs : > 0 en secondes - < 0 en tours			débourrage & départ <0 = / tour
	#_DTD = 0    					# Temporisation E la profondeur finale Valeurs : > 0 en secondes - < 0 en tours - = 0 valeur comme DTB
	#DTB = dwell$					# Temporisation E la profondeur finale Valeurs : > 0 en secondes - < 0 en tours - = 0 					brise cop. <0 = / tour
	#FRF = 1     					# Facteur d avance pour la premiEre profondeur de perCage (introduire sans signe) Plage de valeurs : 0.001...1
	_AXN = 3    					# Axe de l'outil :Valeurs : 1 = 1Er axe gEomEtrique - 2 = 2Eme axe gEomEtrique - sinon 3Eme axe gEomEtrique
	#_MDEP = retr$   				# Profondeur minimale de perCage si DAM < 0 
	#if VARI = 0, _VRT = peckclr$  	# brise cop. Trajet variable de retrait pour bris du copeau (VARI=0) Valeurs : > 0 est la valeur du trajet 0 = trajet de 1 mm
	#if VARI = 1, _DIS1 = 0.5  		# débourrage Distance programmable d'arrEt anticipE lors nouvelle pEnEtration (pour dEbourrage VARI=1) Valeurs : > 0 valeur programmEe prise en compte - = 0 calcul automatique
	#"; valeur num. 8 -- 0= pas de dEgression -- sup. 0 =valeur de dEgression", e$
	
	#*peck1$, *peck2$, *peckclr$, *dwell$, *retr$, *shftdrl$, e$
	n$, "MCALL CYCLE83("
		spaces$ = 0
		*RTP
		","
		*RFP
		","
		*SDIS
		","
		if prof_cycle_Abs_Relatif = 1, *DP		# (Z1) prof. TOTALE en absolu
		","
		if prof_cycle_Abs_Relatif = 2, *DPR		# (Z1) prof. TOTALE en relatif	DPR = DPR * -1, 
		","
		if prof_cycle_Abs_Relatif = 1, *FDEP	# (D) 1ère prof. en absolu
		","
		if prof_cycle_Abs_Relatif = 2, *FDPR	# (D) 1ère prof en relatif	FDPR = FDPR * -1, 
		","
		*DAM  
		","
		if VARI = 0, *DTB						# TEMPO au FOND / brise cop. <0 = / tour
		","
		if VARI = 1, *DTS						# TEMPO en haut / débourrage & départ <0 = / tour
		","	
		*FRF									# facteur d'avance 1ère plongée AMORCE 
		","
		*VARI									# 0 bris du copeau - 1 dEbourrage
		","
		*_AXN   
		","
		if peck2$ < 0, *_MDEP					# si facteur /%
		","
		if VARI = 0, _VRT = peckclr$, *_VRT
		","
		*_DTD									# TEMPO au FOND 
		","
		if VARI = 1, _DIS1 = 0.5, *_DIS1
		","
		if VARI = 1, "0,0,0,11"					# débourrage		"0,X,0,11		Profondeur X=10 --> valeur cylindrique X=0 --> valeur à la pointe du foret TOUJOURS à 0		    
		if VARI = 0, "1.6,0,1,11"				# Brise copeaux  	"1.6,X,1,11"	Profondeur X=10 --> valeur cylindrique X=0 --> valeur à la pointe du foret TOUJOURS à 0		 	
			if peck2$ <0, "2", else, "1"		# DAM Val >0 X=1 DAM Val <0 X=2 --> %
			if prof_cycle_Abs_Relatif = 1, "2"	# (D) 1ère prof. en absolu
			if prof_cycle_Abs_Relatif = 2, "1"	# (D) 1ère prof. en relatif
				"111"
				if prof_cycle_Abs_Relatif = 1, "2"				# (Z1) prof. TOTALE en absolu
				if prof_cycle_Abs_Relatif = 2, "1"				# (Z1) prof. TOTALE en relatif
		")", e$
	
	#valide sur la CN 828D
	#MCALL CYCLE83(50,0,2,-25,,,2.45,4.9,0.75,0,89.9,0,0,1,0.5,0.85,0.5,0,0,12111112)
	
	OLD_RTP = RTP   # MEMO Plan de retrait (en absolu)
	OLD_RFP = RFP   # MEMO Plan de rEfErence (en absolu)
	OLD_SDIS = SDIS # MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP # MEMO Profondeur finale (en absolu)

pcycle_ptap # Ecrire le cycle   MCALL CYCLE84 (RTP,RFP,SDIS,DP,DPR,DTB,SDAC,MPIT,PIT,POSS,SST,SST1,_AXN,_PTAB,_TECHNO,_VARI,_DAM,_VRT)
	if tool_typ$ = 4, SDAC = 3  	# Sens de rotation aprEs fin de cycle valeurs : 3, 4 ou 5
	if tool_typ$ = 5, SDAC = 4  	# Sens de rotation aprEs fin de cycle valeurs : 3, 4 ou 5
	MPIT = 0        				# Pas du filet en tant que taille de filetage (avec signe) Valeurs : 3 (pour M3) E 48 (pour M48), le signe dEtermine le sens de rotation dans le filetage
	if tool_typ$ = 4, PIT = pas 	# Pas du filet en tant que valeur (avec signe) Valeurs : 0.001 ... 2000,000 mm), le signe dEtermine le sens de rotation dans le filetage si _PTAB=0 ou 1 : en mm (inchangE) si _PTAB=2 en nombre de filets par inch
	if tool_typ$ = 5, PIT = -pas    # Pas du filet en tant que valeur (avec signe) Valeurs : 0.001 ... 2000,000 mm), le signe dEtermine le sens de rotation dans le filetage si _PTAB=0 ou 1 : en mm (inchangE) si _PTAB=2 en nombre de filets par inch
	POSS = shftdrl$         		# Position de broche pour l arrEt orientE de la broche dans le cycle (en degrEs)
	SST = abs(ss$)      			# Vitesse de rotation pour taraudage
	SST1 = abs(ss$)     			# Vitesse de rotation pour retrait
	DTB = dwell$ 					# Tempo
	_AXN = 3        				# Axe de l'outil :Valeurs : 1 = 1Er axe gEomEtrique - 2 = 2Eme axe gEomEtrique - sinon 3Eme axe gEomEtrique
	_PTAB = 1       				# UnitE du pas du filet PIT Valeurs : 0... selon systEme d'unitEs programmE inch/mEtrique 1... pas du filet en mm 2... pas du filet en nombre de filets par inch 3... pas du filet en inch/tour
	_TECHNO = 0
	if peck1$ > 0, [					# VARI = --> 0=classic 	1=brise copeaux 	2=Débourrage
		if peckclr$ > 0, [
			VARI = 1					# 1=brise copeaux
			_VRT = peckclr$    			# _VRT Valeur variable de retrait pour bris du copeau
			]
		if peckclr$ = 0, VARI = 2		# 2=Débourrage
		_DAM = peck1$       			# Profondeur incrEmentale Plage de valeurs : 0 <= valeur maxi
		]					
	else, VARI = 0, _DAM = 0, _VRT = 0	# 0=classic
	
	#_VARI int Mode d'usinage : Valeurs : 0...taraudage direct A la profondeur finale 1...taraudage profond avec bris du copeau 2...taraudage profond avec dEbourrage Plage de valeurs : 0 <= valeur maxi
	
	n$, "MCALL CYCLE84("
	spaces$ = 0
		*RTP
		","
		*RFP
		","
		*SDIS
		","
		if prof_cycle_Abs_Relatif = 1, *DP
		","
		if prof_cycle_Abs_Relatif = 2, *DPR
		","
		*DTB
		","
		*SDAC
		","
		#*MPIT
		","
		*PIT
		","
		*POSS
		","
		*SST
		","
		*SST1
		","
		*_AXN
		","
		*_PTAB
		","
		*_TECHNO
		","
		*VARI
		","
		if VARI > 0, *_DAM
		","
		if VARI = 1, *_VRT
		")", e$
	
	OLD_RTP = RTP   # MEMO Plan de retrait (en absolu)
	OLD_RFP = RFP   # MEMO Plan de rEfErence (en absolu)
	OLD_SDIS = SDIS # MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP 	# MEMO Profondeur finale (en absolu)

pcycle_pbore # Ecrire le cycle   MCALL CYCLE85(RTP, RFP, SDIS, DP, DPR, DTB, FFR, RFF)
	n$, "MCALL CYCLE85("
	spaces$ = 0
		*RTP
		","
		*RFP
		","
		*SDIS
		","
		if prof_cycle_Abs_Relatif = 1, *DP
		","
		if prof_cycle_Abs_Relatif = 2, *DPR
		","
		*DTB
		","
		*FFR
		","
		*RFF
		",1,11)", e$

	OLD_RTP = RTP   # MEMO Plan de retrait (en absolu)
	OLD_RFP = RFP   # MEMO Plan de rEfErence (en absolu)
	OLD_SDIS = SDIS # MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP 	# MEMO Profondeur finale (en absolu)

#region positions_percages_et_annulation
p_val_cycles_percage    # calcul de (RTP, RFP, SDIS, DP, DPR)
	@depth$, @refht$, @tosz$, @initht$
	# pour info
	#if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
	#if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
	if rotaxis$ = 0,  [   		# XY CLASIQUE
		if opcode$ <> 16, [		# NON PERCAGE 5 axes
			RTP = initht$
			RFP = tosz$
			SDIS = refht$ - tosz$
			DP = depth$
			DPR = abs (depth$ - tosz$) 
			FDEP = tosz$ - peck1$
			FDPR = abs (tosz$ - peck1$)  
			]		
		if opcode$ = 16, [ 		# PERCAGE 5 axes				
		    if axeA = 0, [			
				RTP = zr$ 
				DP = z$					
				RFP = w$ 				
		    	SDIS = refht$ - drl_sel_tos$
				DPR = abs(RFP-SDIS-DP)	
				#*drl_sel_ini$, *drl_sel_ref$, *drl_sel_tos$, *drl_init_z$, e$ 
				#*drl_tos_z$, *drl_zdrl_z$, *drl_depth_z$, *w$, e$   
				]	    			
			if axeA <> 0, [
				#******* new_z/zabs = POINT Z CALCULE AU FOND DU TROU								
		    	SDIS = refht$ - drl_sel_tos$ 				
				DP = zabs #zabs - (drl_sel_ini$ - depth$)
				RTP = DP + abs(depth$) + refht$	# drl_sel_ini$
				RFP = RTP - SDIS
				DPR = depth$
				if drl_sel_ini$ > SDIS, RTP = zabs + drl_sel_ini$ + abs(depth$) 				
				]
		    if Mode_reglage_PP = 0, [
				#"zabs = fond du trou en ABSOLU VAL MC", e$	
				#"zabs = VALEUR DE REFERENCE POUR TOUS LES CALCULS DE ****Zs****", e$
				spaces$ = 1
				*z$, *DP, " ", *RTP, " ",  *RFP, " ", *y$, " ", *znci$, *ynci$,  e$ 
				*drl_ref_z$, *drl_sel_ini$, *drl_sel_ref$, *drl_sel_tos$, e$
				*drl_init_z$, *drl_tos_z$, *drl_zdrl_z$, " ",  *w$, " ", *z$, *znci$, e$
				*depth$, " ", *refht$, *zabs, e$	#*prof_perc_abs_5x, 
				*drl_depth_z$, *zr$, e$
				spaces$ = 0
				]
			#if type_dec_4x_percage = 1, garde_abs = 0	
			]
		]
	if rotaxis$ <> 0, [    # SUBSTITUTION
		p_calcul_AB_pos_Subs
		RTP = initht$ + (rotdia$/2)
		RFP = tosz$ + (rotdia$/2)
		DP = depth$ + (rotdia$/2)
		DPR = depth$ - tosz$
		]
	DTB = dwell$
	_DTD = dwell$ 
	FFR = frplunge$
	RFF = FFR 
	FRF = perc_AVANCE_pour_Cent_mm
	if FRF > 1, FRF = FRF / 100
	_MDEP = retr$
			
p_position_trou        #TRANSITION ENTRE CYCLE
	#p_correc_time_G0
	if rotaxis$ = 0, [
		xabs = x$
		yabs = y$
		zabs = z$
		]
	if rotaxis$ <> 0, [
		if rotaxis$ = -2 | rotaxis$ = 2, xabs = x$
		if rotaxis$ = -1 | rotaxis$ = 1, yabs = y$
		]
	
	spaces$ = 1
	if incremental = 0, n$, *xabs, *yabs, e$, !Xinc, !Yinc
	else, !xabs, !yabs, n$, *Xinc, *Yinc, e$
	
	if rotaxis$ <> 0, [	# & axeAB_subs <> prv_axeAB_subs, [
		if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0       # diviseur tourne autour de Y (X sbstitue)
	    if rotaxis$ = -2 | rotaxis$ = 2, yabs = 0       # diviseur tourne autour de X (Y sbstitue)	
		]
		
	p_modal     # afficher en format modal
    !x$, !y$    # mise a jour XY
    old_x = xabs
    old_y = yabs

p_axeAB_subs_perc	
	p_calcul_AB_pos_Subs
	n$, "MCALL", e$
	if axeAB_subs <> old_axeA, 
		[
		if mi7$ = 1, bloque = 2, n$, sbloque, e$	# si ROT - Débloque	
		gcode$ = 0
		n$, *sgcode, *axeAB_subs, e$
		if mi7$ = 1, bloque = 1, n$, sbloque, e$	# si ROT - Bloque
		old_axeA  = axeAB_subs
		]
#endregion

passage_drillcyc : 0
p_percages_decomposes
	#"p_percages_decomposes : ", *drillcyc$, *usecanDRILL, *usecanPECK, " ", *usecanCHIP, " ", *perc_1er_perc_pour_C_ou_mm, e$
	if drillcyc$ >= 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1) & passage_drillcyc = 0, 
		[
		if drillcyc$ = 0, n$, s_com_open, "PERCAGE LAMAGE TEMPO -G82-", s_com_close, e$ 
		if drillcyc$ = 1, n$, s_com_open, "PERCAGE DEBOURRAGE -G83-", s_com_close, e$
		if drillcyc$ = 2, n$, s_com_open, "PERCAGE DEBOURRAGE BRISE COPEAUX -G83-", s_com_close, e$ 
		#if drillcyc$ = 3, n$, s_com_open, "TARAUDAGE G84", s_com_close, e$ 
		dwell = dwell$ 
		passage_drillcyc = 1
		]	
	if drillcyc$ >= 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1) & perc_1er_perc_pour_C_ou_mm >= 0 & perc_Val_pour_Cent_mm <> 0, 
		[
		n$, s_com_open, "AVEC AMORCE DE PERCAGE", s_com_close, e$ 
		# Avances
		if perc_AVANCE_pour_Cent_mm > 0, [			# %		
			avance = (frplunge$ * perc_AVANCE_pour_Cent_mm) / 100
			]
		if perc_AVANCE_pour_Cent_mm < 0, [			# mm
			avance = perc_AVANCE_pour_Cent_mm * -1
			]
		# Profondeurs
		if perc_1er_perc_pour_C_ou_mm = 0, [		# VALEUR EN mm	
			P_er_perc_0 = perc_Val_pour_Cent_mm 
			P_er_perc_2 = refht$ - P_er_perc_0	
			]	
		if perc_1er_perc_pour_C_ou_mm = 1, [		# Valeur en %
			angle_foret = 90 - (paramT8 / 2)
			P_er_perc_0 = refht$ - z$
			P_er_perc_1 = (P_er_perc_0 * perc_Val_pour_Cent_mm) / 100 
			P_er_perc_2 = refht$ - P_er_perc_1					
			]
		n$, "G1", *P_er_perc_2, *avance, e$
		if dwell$ > 0, n$, *sg04, *dwell, e$ 
		p_erreur_perc_decomposes
		perc_1er_perc_pour_C_ou_mm = -1	# pour ne pas l'afficher sur les autres profondeurs
		]

pdrill0$
    p_correc_time_G0
	if usecanDRILL = 1, usecandrill$ = no$
	if usecanPECK = 1, usecanpeck$ = no$
	if usecanCHIP = 1, usecanchip$ = no$
	passage_drillcyc = 0	

pdrill$      # Cycle de percage G82 (pour la tempo)
	#Cycle de percage G81
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	if dwell$ = 0,  n$, s_com_open, "POINTAGE-PERCAGE", s_com_close, e$
    if dwell$ <> 0, n$, s_com_open, "POINTAGE-PERCAGE-TEMPO", s_com_close, e$
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	n$, frplunge$, e$   
	if type_cycle_percages = 1, [
		n$, "R101=", *RTP, ";RTP - PLAN DE RETRAIT EN ABSOLU",e$			
		n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$			
		n$, "R103=", *SDIS, ";SDIS - DISTANCE DE SECURITE SANS SIGNE",e$
		if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
		if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF", e$		
		n$, "R106=", *DTB, ";DTB - TEMPO AU FOND EN SECONDES",e$
		if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE82(R101,R102,R103,R104,,R106)", e$			
		if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE82(R101,R102,R103,,R105,R106)", e$
		]
	if type_cycle_percages = 2, pcycle_pdrill
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                   
	old_profrelatif = profrelatif
	perreurTaraud

ppeck$       # Cycle de debourrage G83
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	Perreur_prof_passe
	n$, s_com_open, "PERCAGE DEBOURRAGE", e$
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	n$, frplunge$, e$  
	if type_cycle_percages = 1, [
		n$, "R101=", *RTP, ";RTP - PLAN DE RETRAIT EN ABSOLU", e$
		n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU", e$
		n$, "R103=", *SDIS, ";SDIS - DISTANCE DE SECURITE SANS SIGNE", e$
		if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$
		if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF", e$
		n$, "R107=", *peck1$, ";FDPR - 1ERE PROFONDEUR EN RELATIF", e$
		n$, "R108=0 ;DAM - PAS DE DEGRESSION", e$
		n$, "R109=-2 ;DTB - TEMPO DE 2 ROTATIONS DE BROCHE", e$
		n$, "R116=-2 ;DTD - TEMPO DE 2 ROTATIONS DE BROCHE AU FOND", e$
		if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE83(R101,R102,R103,R104,,,R107,R108,R109,0,1,1,3,,0,R116,0)", e$
		if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE83(R101,R102,R103,,R105,,R107,R108,R109,0,1,1,3,,0,R116,0)", e$
		]
	if type_cycle_percages	= 2, [
		vari = 1
		pcycle_ppeck_chpbrk
		]
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                    
	old_profrelatif = profrelatif
	perreurTaraud

pchpbrk$     # Cycle de debourrage G83 ****BRISE COPEAUX****
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	n$, s_com_open, "PERCAGE BRISE COPEAUX", e$
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	n$, frplunge$,  e$  
	if type_cycle_percages = 1, [
		n$, "R101=", *RTP, ";RTP - PLAN DE RETRAIT EN ABSOLU",e$
		n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$
		n$, "R103=", *SDIS, ";SDIS - DISTANCE DE SECURITE SANS SIGNE",e$
		if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$
		if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		n$, "R107=", *peck1$, ";FDPR - 1ERE PROFONDEUR EN RELATIF",e$
		n$, "R108=", *peckclr$, ";DAM - VALEUR DE DEGRESSION",e$
		n$, "R109=-2 ;DTB - TEMPO DE 2 ROTATIONS DE BROCHE",e$
		n$, "R114=", *dwell$, ";_MDEP - PROFONDEUR MINI DE PERCAGE",e$
		n$, "R116=-2 ;DTD - TEMPO DE 2 ROTATIONS DE BROCHE AU FOND",e$
		if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE83(R101,R102,R103,R104,,,R107,R108,R109,0,1,0,3,R114,0,R116,0)",e$
		if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE83(R101,R102,R103,,R105,,R107,R108,R109,0,1,0,3,R114,0,R116,0)",e$
		]
	if type_cycle_percages	= 2, [
		vari = 0 
		pcycle_ppeck_chpbrk
		]	
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                 
	old_profrelatif = profrelatif
	perreurTaraud   

ptap$        # Cycle de taraudage G84
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	if pas_taraud_egale_ISO = 1,	[
	    if tldia$ = 2, pas = 0.4
	    if tldia$ = 2.5, pas = 0.45
	    if tldia$ = 3, pas = 0.5
	    if tldia$ = 4, pas = 0.7
	    if tldia$ = 5, pas = 0.8
	    if tldia$ = 6, pas = 1
	    if tldia$ = 8, pas = 1.25
	    if tldia$ = 10, pas = 1.5
	    if tldia$ = 12, pas = 1.75
	    if tldia$ = 14, pas = 2
	    if tldia$ = 16, pas = 2
	    ]
	else, pas = n_tap_thds$ 	#paramT7 
	if peck2$ > 0, pas = peck2$
	if peck1$ = 0 & peckclr$ = 0, n$, s_com_open, "TARAUDAGE", e$
	if peck1$ > 0 & peckclr$ > 0, n$, s_com_open, "TARAUDAGE BRISE COPEAUX", e$
	if peck1$ > 0 & peckclr$ = 0, n$, s_com_open, "TARAUDAGE AVEC DEBOURRAGE", e$
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	if type_cycle_percages = 1, [
		n$, "R101=", *RTP , ";RTP - PLAN DE RETRAIT EN ABSOLU",e$
		n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$
		n$, "R103=", *SDIS, ";SDIS - DISTANCE DE SECURITE SANS SIGNE",e$
		if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$
		if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		n$, "R106=0 ;DTB - TEMPO AU FOND DU TARAUDAGE",e$
		n$, "R110=", *pas, ";PIT - PAS DU FILETAGE",e$
		n$, "R112=", *sst, ";SST - VITESSE DE ROTATION",e$
		n$, "R113=R112 ;SST1 - VITESSE DE ROTATION DE RETRAIT",e$
		if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE84(R101,R102,R103,R104,,R106,3,,R110,0,R112,R113,3,1,,0,,)",e$
		if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE84(R101,R102,R103,,R105,R106,3,,R110,0,R112,R113,3,1,,0,,)",e$
		]
	if type_cycle_percages	= 2, pcycle_ptap 	
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                   
	old_profrelatif = profrelatif

pbore1$      # Cycle d'alesage G85 (ALESOIR)
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	frplunge2 = frplunge$
	n$, s_com_open, "ALESAGE", e$
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	n$, frplunge$, e$   
	if type_cycle_percages = 1, [
		n$, "R101=", *RTP, ";RTP - PLAN DE RETRAIT EN ABSOLU",e$
		n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$
		n$, "R103=", *SDIS, ";SDIS - DISTANCE DE SECURITE SANS SIGNE",e$
		if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
		if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		n$, "R106=0.5 ;DTB - TEMPO AU FOND DE L'ALESAGE",e$
		n$, "R107=", *frplunge2, ";FFR - VITESSE D'AVANCE PLONGEE",e$
		frplunge2 = frplunge2 * 2
		n$, "R108=", *frplunge2, ";RFF - VITESSE D'AVANCE RETRAIT",e$
		if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE85(R101,R102,R103,R104,,R106,R107,R108)", e$
		if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE85(R101,R102,R103,,R105,R106,R107,R108)", e$
		]
	if type_cycle_percages	= 2, pcycle_pbore 
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                   
	old_profrelatif = profrelatif
	perreurTaraud

pbore2$      # Cycle d'alesage avec arret de broche G86 (INDEXAGE retour en rapide)
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	n$, s_com_open, "ALESAGE INDEXE", e$
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	n$, frplunge$, e$   
	if type_cycle_percages = 1, [
		n$, "R101=", *RTP, ";RTP - PLAN DE RETRAIT EN ABSOLU",e$
		n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$
		n$, "R103=", *sdis, ";SDIS - DISTANCE DE SECURITE SANS SIGNE",e$
		if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
		if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		n$, "R106=1 ;DTB - TEMPO AU FOND DE L'ALESAGE",e$
		n$, "R108=-0.2 ;RPA - COURSE RETRAIT SUIV. L'ABSCISSE (X) RELATIF",e$
		n$, "R109=0 ;RPO - COURSE RETRAIT SUIV. L'ORDONNEE (Y) RELATIF",e$
		n$, "R110=0 ;RPAP - COURSE RETRAIT SUIV. PROFONDEUR (Z) RELATIF",e$
		n$, "R111=0 ;POSS - ANGLE D'ARRET DE BROCHE EN DEGRES",e$
		if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE86(R101,R102,R103,R104,,R106,3,R108,R109,R110,R111)", e$
		if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE86(R101,R102,R103,,R105,R106,3,R108,R109,R110,R111)", e$
		]
	if type_cycle_percages	= 2, n$, spaces$ = 0, "MCALL CYCLE86(", initht$, ",", *tosz$, ",", 
		sdis, ",", depth$, ",,", dwell$, ",",peck1$,",",peck2$,",",peckclr$, ",", retr$, ",", shftdrl$, ")", e$
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                    
	old_profrelatif = profrelatif
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_RFP = RFP   					# MEMO Plan de rEfErence (en absolu)
	OLD_SDIS = SDIS 					# MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)

pmisc1$      # Cycle alesage G87 (Stop)
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	n$, frplunge$, e$   
	#n$, "R101=", *initht, ";RTP - PLAN DE RETRAIT EN ABSOLU"
	#n$, "R102=", *tosz, ";RFP - PLAN DE REFERENCE EN ABSOLU"
	#n$, "R103=", *sdis, ";SDIS - DISTANCE DE SECURITE SANS SIGNE"
	#   #n$, "R104=", *depth, ";DP - PROFONDEUR FINAL EN ABSOLU"
	#n$, "R105=", *profrelatif, ";DPR - PROFONDEUR FINAL EN RELATIF"
	spaces$ = 0
	if type_cycle_percages	= 1, n$, "NON ACTIF", e$
	if type_cycle_percages	= 2, n$, spaces$ = 0, "MCALL CYCLE87(", initht$, ", ", *tosz$, ",", sdis, ",", depth$, ", ,", peck1$,")", e$
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                    
	old_profrelatif = profrelatif
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_RFP = RFP   					# MEMO Plan de rEfErence (en absolu)
	OLD_SDIS = SDIS 					# MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	
pmisc2$      # Cycle alesage G88 (Stop et tempo)
	if drill_4_axes = 1, p_drill_5axes
	debut = 2
	p_val_cycles_percage 
	if peck1$ = 3 | peck1$ = 4, peck1$ = peck1$,        
	else, n$, "erreur de valeur en rotation", e$, exitpost$
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	n$, frplunge$, e$
	#n$, "R101=", *initht, ";RTP - PLAN DE RETRAIT EN ABSOLU"
	#n$, "R102=", *tosz, ";RFP - PLAN DE REFERENCE EN ABSOLU"
	#n$, "R103=", *sdis, ";SDIS - DISTANCE DE SECURITE SANS SIGNE"
	#   #n$, "R104=", *depth, ";DP - PROFONDEUR FINAL EN ABSOLU"
	#n$, "R105=", *profrelatif, ";DPR - PROFONDEUR FINAL EN RELATIF"
	spaces$ = 0
	if type_cycle_percages	= 1, n$, "NON ACTIF", e$
	if type_cycle_percages	= 2, n$, spaces$ = 0, "MCALL CYCLE88(", initht$, ",", *tosz$, ",", sdis, ", ", depth$, ",,", dwell$, ",", peck1$, ")", e$
	spaces$ = 1
	if drill_4_axes = 1, n$, *xabs, *yabs, e$
	else, p_position_trou	# X Y
	old_tosz = tosz$                    
	old_profrelatif = profrelatif
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_RFP = RFP   					# MEMO Plan de rEfErence (en absolu)
	OLD_SDIS = SDIS 					# MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)

#pmisc3      # Cycle alesage G89 (tempo)
	#debut = 2
	#p_val_cycles_percage 
	#n$, frplunge 
	#n$, "R101=", *initht$, ";RTP - PLAN DE RETRAIT EN ABSOLU"
	#n$, "R102=", *tosz$, ";RFP - PLAN DE REFERENCE EN ABSOLU"
	#n$, "R103=", *sdis, ";SDIS - DISTANCE DE SECURITE SANS SIGNE"
	#   #n$, "R104=", *depth$, ";DP - PROFONDEUR FINAL EN ABSOLU"
	#n$, "R105=", *profrelatif, ";DPR - PROFONDEUR FINAL EN RELATIF"
	#spaces$ = 0
	#if type_cycle_percages	= 2, n$, spaces$ = 0 "MCALL CYCLE89(", initht$, ",", *tosz$, ",", sdis, ",", depth$, ",,", dwell$, ")", e$
	#spaces$ = 1
	#if drill_4_axes = 1, n$, *xabs, *yabs, e$
	#else, p_position_trou	# X Y
	old_tosz = tosz$                  
	old_profrelatif = profrelatif
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_RFP = RFP   					# MEMO Plan de rEfErence (en absolu)
	OLD_SDIS = SDIS 					# MEMO Distance de sEcuritE (introduire sans signe)
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)

pdrill_2$    # Canned Drill Cycle
	if drill_4_axes = 1, p_drill_5axes_2  
	if rotaxis$ <> 0, p_axeAB_subs_perc	 
	p_val_cycles_percage
	@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
	if type_cycle_percages	= 1, [
		if drill_4_axes = 1, if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP, [
			n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
			if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
			if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE82(R101,R102,R103,R104,,R106)",e$			
			if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE82(R101,R102,R103,,R105,R106)",e$		
			]
		]
	if type_cycle_percages	= 2, [
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
			#pcanceldc$
			pcycle_pdrill
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
    if drill_4_axes = 0, p_position_trou	# X Y		

ppeck_2$     # Canned Peck Drill Cycle	
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage	
	if type_cycle_percages	= 1, [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)   
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
			if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE83(R101,R102,R103,R104,,,R107,R108,R109,0,1,1,3,,0,R116,0)", e$
			if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE83(R101,R102,R103,,R105,,R107,R108,R109,0,1,1,3,,0,R116,0)", e$
		    old_tosz = tosz$                   
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages	= 2, [
		#p_val_cycles_percage
		@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			pcycle_ppeck_chpbrk
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y

pchpbrk_2$   # Canned Chip Break Cycle
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage
	if type_cycle_percages	= 1, [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)   
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		    if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE83(R101,R102,R103,R104,,,R107,R108,R109,0,1,0,3,R114,0,R116,0)",e$
			if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE83(R101,R102,R103,,R105,,R107,R108,R109,0,1,0,3,R114,0,R116,0)",e$
		    old_tosz = tosz$               
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages	= 2, [		
		@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			pcycle_ppeck_chpbrk
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y	

ptap_2$      # Canned Tap Cycle
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage
	if type_cycle_percages	= 1, [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)    
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		    if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE84(R101,R102,R103,R104,,R106,3,,R110,0,R112,R113,3,1,,0,,)",e$
			if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE84(R101,R102,R103,,R105,R106,3,,R110,0,R112,R113,3,1,,0,,)",e$
		    old_tosz = tosz$                    
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages	= 2, [
		@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			pcycle_ptap
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y

pbore1_2$    # Canned Bore #1 Cycle
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage
	if type_cycle_percages	= 1, [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)    
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		    if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE85(R101,R102,R103,R104,,R106,R107,R108)", e$
			if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE85(R101,R102,R103,,R105,R106,R107,R108)", e$
		    old_tosz = tosz$                   
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages	= 2, [
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			pcycle_pbore 
			spaces$ = 1
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y

pbore2_2$    # Canned Bore #2 Cycle
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage
	if type_cycle_percages	= 1,  [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)   
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		    if prof_cycle_Abs_Relatif = 1, n$, "MCALL CYCLE86(R101,R102,R103,R104,,R106,3,R108,R109,R110,R111)", e$
			if prof_cycle_Abs_Relatif = 2, n$, "MCALL CYCLE86(R101,R102,R103,,R105,R106,3,R108,R109,R110,R111)", e$
		    old_tosz = tosz$                   
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages  = 2, [
		@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			n$, spaces$ = 0, "MCALL CYCLE86(", initht$, ",", *tosz$, ",", 
				sdis, ",", depth$, ",,", dwell$, ",",peck1$, ",",peck2$, ",", peckclr$, ",", retr$, ",", shftdrl$, ")", e$
			spaces$ = 1
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y

pmisc1_2$    #
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage
	if type_cycle_percages	= 1, [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)   
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		    n$, "MCALL CYCLE82(R101,R102,R103,,R105,R106)", e$
		    old_tosz = tosz$                   
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages  = 2, [
		@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			n$, spaces$ = 0, "MCALL CYCLE87(", initht$, ", ", *tosz$, ",", sdis, ",", depth$, ", ,", peck1$,")", e$
			spaces$ = 1
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y

pmisc2_2$    # Canned Misc #2 Cycle
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage
	if type_cycle_percages	= 1, [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)   
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		    n$, "MCALL CYCLE82(R101,R102,R103,,R105,R106)", e$
		    old_tosz = tosz$                    
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages  = 2, [
		@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			n$, spaces$ = 0, "MCALL CYCLE88(", initht$, ",", *tosz$, ",", sdis, ", ", depth$, ",,", dwell$, ",", peck1$, ")", e$
			spaces$ = 1
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y

pmisc2_3    # Canned Misc #3 Cycle
	if drill_4_axes = 1, p_drill_5axes_2
	if rotaxis$ <> 0, p_axeAB_subs_perc
	p_val_cycles_percage
	if type_cycle_percages	= 1, [
		@old_tosz, @old_profrelatif, @tosz$, @profrelatif 
		if (tosz$ <> old_tosz) | (profrelatif <> old_profrelatif),	[
		    profrelatif = abs (depth$ - tosz$)   
		    n$, "R102=", *RFP, ";RFP - PLAN DE REFERENCE EN ABSOLU",e$	
		    if prof_cycle_Abs_Relatif = 1, n$, "R104=", *DP, ";DP - PROFONDEUR FINAL EN ABSOLU", e$ 
			if prof_cycle_Abs_Relatif = 2, n$, "R105=", *DPR, ";DPR - PROFONDEUR FINAL EN RELATIF",e$
		    n$, "MCALL CYCLE82(R101,R102,R103,,R105,R106)", e$
		    old_tosz = tosz$                   
		    old_profrelatif = profrelatif
		    ]
		]
	if type_cycle_percages  = 2, [
		@OLD_RTP, @RTP, @OLD_RFP, @RFP, @OLD_SDIS, @SDIS, @OLD_DP, @DP
		if OLD_RTP <> RTP | OLD_RFP <> RFP | OLD_SDIS <> SDIS | OLD_DP <> DP | rotaxis$ <> 0, [
	        #pcanceldc$
			n$, spaces$ = 0, "MCALL CYCLE89(", initht$, ",", *tosz$, ",", sdis, ",", depth$, ",,", dwell$, ")", e$
			spaces$ = 1
			]
		]
	OLD_DP = DP 						# MEMO Profondeur finale (en absolu)
	OLD_RTP = RTP   					# MEMO Plan de retrait (en absolu)
	OLD_DPR = DPR
	OLD_SDIS = SDIS
	p_position_trou	# X Y
#endregion

#region embranchements_cycles_palpages
pdrlcst$     # Test de l'appel des cycles  et embranchements 
	if Cycles_palpage_YN = 1 & drillcyc$ >7 & drillcyc$ <18, [        
		p_garde_Z
        if drl_prm10$ = 1 & entete_listage_cotes = 0,   #Listage des cotes
            [
            p_listage_cotes
            drl_prm10 = 1
            ]
        if drl_prm10 =0, perreurPalp5 
        #if dwell$ < 1, "----",e$,"ATTENTION PAS DE DECALAGE D ACTIVE _KNUM", op_id$," AVEC LE PALPEUR", e$, "---",e$ ,exitpost$
        if drillcyc$ = 8, pdrlcst_8   	#Cycle de palpage Pt de rEf. int. (exter) rectangulaire"
        if drillcyc$ = 9, pdrlcst_9   	#Cycle de palpage Pt de rEf. int. (exter) DiamA¨tre"
        if drillcyc$ = 10, pdrlcst_10 	#Cycle de palpage Pt de rEf. exter Coin"
        if drillcyc$ = 11, pdrlcst_11 	#Cycle de palpage Pt de rEf. inter Coin"
        if drillcyc$ = 12, pdrlcst_12 	#Cycle de palpage Pt de rEf. EN Z"
        if drillcyc$ = 13, pdrlcst_13 	#Cycle de palpage Pt de rEf. FACE EN X"
        if drillcyc$ = 14, pdrlcst_14 	#Cycle de palpage Pt de rEf. FACE EN Y"
        if drillcyc$ = 15, pdrlcst_15 	#Cycle de palpage dans une rainure ou sur une languette"   
        if drillcyc$ = 16, pdrlcst_16 	#Cycle de palpage pour redresser une surface en Z avec Origine"    
        if drillcyc$ = 17, pdrlcst_17 	#Cycle de palpage pour redresser suivant un angle sur une surface en X ou Y avec Origine"  
        #n$, "M71 ;Desactivation du palpeur", e$  
        #palpeur = 0             
		]
	if Cycles_palpage_YN = 0 & drillcyc$ >7 & drillcyc$ <18, p_erreur_cycle_palpage
	if drillcyc$ = 18, pdrlcst_18 	# Cycle Brossage EBAVURAGE 
    if drillcyc$ = 19, pdrlcst_19   # perçage très profond avec trous d'huile
	gcode$ = 0               
    old_drl_prm8 = drl_prm8$
    old_drl_prm9 = drl_prm9$

pdrlcst_2$   # Test de l'appel des cycles  et embranchements pour X palpages 
    if Cycles_palpage_YN = 1 & drillcyc$ >7 & drillcyc$ <18, [ 
		if drl_prm10 =0, perreurPalp5 
	    #n$, "*****************", e$
	    if drillcyc$ = 8, pdrlcst_8_2    	#Cycle de palpage Pt de rEf. int. (exter) rectangulaire"
	    if drillcyc$ = 9, pdrlcst_9_2    	#Cycle de palpage Pt de rEf. int. (exter) DiamEtre"
	    if drillcyc$ = 10, pdrlcst_10_2   	#Cycle de palpage Pt de rEf. exter Coin"
	    if drillcyc$ = 11, pdrlcst_11_2   	#Cycle de palpage Pt de rEf. inter Coin"
	    if drillcyc$ = 12, pdrlcst_12_2   	#Cycle de palpage Pt de rEf. EN Z"
	    if drillcyc$ = 13, pdrlcst_13_2   	#Cycle de palpage Pt de rEf. FACE EN X"
	    if drillcyc$ = 14, pdrlcst_14_2   	#Cycle de palpage Pt de rEf. FACE EN Y"
	    if drillcyc$ = 15, pdrlcst_15_2   	#Cycle de palpage dans une rainure ou sur une languette"   
	    if drillcyc$ = 16, pdrlcst_16_2   	#Cycle de palpage pour redresser une surface en Z avec Origine"    
	    if drillcyc$ = 17, pdrlcst_17_2  	#Cycle de palpage pour redresser suivant un angle sur une surface en X ou Y avec Origine"  
	    #if drillcyc$ >7 & drillcyc$ <18, palpeur = 0  		#Pour désactiver le palpeur
	    #n$, "M71 ;Desactivation du palpeur", e$
	    #palpeur = 0             
		]
    if drillcyc$ = 18, pdrlcst_18_2   # perçage très profond avec trous d'huile
	if drillcyc$ = 19, pdrlcst_19_2   # perçage très profond avec trous d'huile
	gcode$ = 0              
#endregion

#region cycles_palpages
p_listage_cotes     #entAªte de listage des cotes
    sprog_name = ucase(sprog_name)
    spaces$ = 1
    # caractA¨res ASCI "=34  _=95    *=42    ,=44
    n$, ";MESURE avec journal DE COTES", e$
    #n$, "DEF INT NUMPIECE, NUMORDRE", e$
    n$, ";------REglage des paramA¨tres de listage------", e$
    "    _CBIT[10]=1 ;sauvegarde dans un fichier", e$
    "    _CBIT[11]=0 ;journal avec entete par dEfaut", e$
    n$, ";------entete du journal------", e$
    #n$, "NUMPIECE=1111111 NUMORDRE=22222", e$
    #strings palpages
    "    _PROTNAME[0]=", 34, snouvnom, 34, ";NOM DU FICHIER EN SPF", e$
    "    _PROTNAME[1]=", 34, sprog_name, 34, ";ARTICLE", e$
    "    _HEADLINE[0]=", 34, s_Piece, 34, ";NOM DE LA PIECE", e$
    "    _HEADLINE[1]=", 34, s_Numplan, 34, ";NUMERO DE LA PIECE", e$
    "    _HEADLINE[2]=", 34, s_indice, 34, ";INDICE", e$
    "    _HEADLINE[3]=", 34, "HURON", 34, ";MACHINE", e$
    n$, ";------FORMAT du journal------", e$
    "    _PROTSYM[0]=", 34, 44, 34, "; -,- sEparateur des valeurs", e$
    "    _PROTSYM[1]=", 34, 42, 34, "; -*- valeur HORS tolErance", e$
    #"    _PROTFORM[4]=2            ;2 Lignes de valeurs", e$
    "    _PROTFORM[0]=SET(68,80,1,3,4)", e$
    n$, ";68 Lignes-Page, 80 Carac.-Ligne, 1 1er NUM. Page", e$
    n$, ";3 Lignes-entete, 4 Lignes-resultat", e$
    n$, ";------contenu du journal------", e$
    n$, ";Ligne de titre", e$
    #"    _PROTVAL[0]=", 34, "Axe mesure , axe , valeur consigne , valeur reelle ,",  e$
    "    _PROTVAL[0]=", 34, "MESURE, AXE , COTE PLAN , COTE MESURE , TOL+ , TOL-, DIFF. ", 34, e$
    #"    _PROTVAL[1]=", 34, "point , , valeur ", 34, e$
    n$, "R27=1 ; dEbut du compteur de palpages", e$
    n$, "CYCLE100 ;ACTIVATION DU LISTAGE DES COTES", e$
    entete_listage_cotes = 1

p_garde_Z
    gcode$ = 1
    spaces$ = 1
    n$, *sgcode, "MEAS=1", "Z", *refht$, e$ # *tosz$, refht$, *depth$
    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$

pdrlcst_8    #Cycle de palpage Pt de rEf./mesure int. (exter) rectangulaire" 
	spaces$ = 1
	#gcode$ = 0
	#profrelatif = (initht$-depth$) * ( -1)
	profrelatif = (refht$-depth$) * ( -1)
	if prv_drill_cycl = 8, pdrlcst_2$, ex$
		if drl_prm1$ = 1,
			[
			n$, ";REF. INT. RECTANGLE", e$
			mvar = 105
			]   # SECURITE EN INTER
		if drl_prm2$ = 1,
			[
			n$, ";REF. EXT. RECTANGLE", e$
			mvar = 106
			]   # SECURITE EN EXTER
		perreurPalp1
		if mvar = 105, "     _MVAR=", mvar, "; _MVAR =105 REF. INTER RECTANGLE", e$
		if mvar = 106, "     _MVAR=", mvar, "; _MVAR =106 REF. EXTER RECTANGLE", e$
		if drl_prm10$ = 1,
			[
			"     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
			]
		else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
		"     _SETV[0]=", peck1$, ";Longueur en X", e$
		"     _SETV[1]=", peck2$, ";Largeur en Y", e$
		if drl_prm10$ = 1,
			[
			"     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
			"     _TLL=", drl_prm9$ "; Tolerance MINI", e$
			]
		"     _ID=", profrelatif, "; Profondeur en relatif", e$
		"     _TSA=1 ; Zone de fiabilite +-1mm", e$
		"     _PRNUM=1 ; Numero de palpeur", e$
		"     _VMS=300 ; Vitesse de mesure", e$
		"     _NMSP=1 ; Nombre de mesure au meme point", e$
		"     _FA=5 ; Course de mesure +-5mm", e$
		"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
		"     ;   ", e$
		if drl_prm10$ = 1,    #mesure
			[
			pdrlcst_8_2_2
			]
	  n$, "CYCLE977", e$
	  p_ori_usi_force
	  prv_drill_cycl = 8

pdrlcst_9    #Cycle de palpage Pt de rEf./mesure int. (exter) DiamEtre"
	spaces$ = 1
	#gcode$ = 0
	#profrelatif = (initht$-depth$) * ( -1)
	profrelatif = (refht$-depth$) * ( -1)
	if prv_drill_cycl = 9, pdrlcst_2$, ex$
	if drl_prm1$ = 1,
		[
		n$, ";REF. INT. DIAMETRE", e$
		n$, *sgcode, "MEAS=1", "Z", *profrelatif,  e$   
		n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
		mvar = 101
		]   # SECURITE EN INTER
	if drl_prm2$ = 1,
		[
		n$, ";REF. EXT. DIAMETRE", e$
		mvar = 102
		]   # SECURITE EN EXTER
	perreurPalp1
	#if drl_prm1$ <> 1 & drl_prm2$ <> 1, "----",e$,"1 ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**", e$,"---",exitpost$
	if mvar = 101, "     _MVAR=", *mvar, "; _MVAR =101 REF. INTER DIAMETRE", e$
	if mvar = 102, "     _MVAR=", *mvar, "; _MVAR =102 REF. EXTER DIAMETRE", e$
	if drl_prm10$ = 1,
		[
		"     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
		]
	else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"     _SETVAL=", *peck1$, ";Diametre de palpage", e$
	if drl_prm10$ = 1,
		[
		"     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
		"     _TLL=", drl_prm9$ "; Tolerance MINI", e$
		]
	if drl_prm2$ = 1 ,"     _ID=", profrelatif, ";Profondeur en relatif", e$
	"     _TSA=1 ; Zone de fiabilite +-1mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=300 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=5 ; Course de mesure +-5mm", e$
	"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	"     ;   ", e$
	if drl_prm10$ = 1, pdrlcst_8_2_2   #mesure
	n$, "CYCLE977", e$
	p_ori_usi_force
	prv_drill_cycl = 9

pdrlcst_10   #Cycle de palpage Pt de rEf. EXTER COIN" 
	spaces$ = 1
	#gcode$ = 0
	#profrelatif = (initht$-depth$) * ( -1)
	profrelatif = (refht$-depth$) * ( -1)
	if prv_drill_cycl = 10, pdrlcst_2$, ex$
	perreurPalp4
	n$, "; REF. EXTER COIN", e$
	"     _MVAR=106 ; COIN EXTER 3 POINTS", e$
	#"     _MVAR=108 ; COIN EXTER 4 POINTS", e$
	if drl_prm10$ = 1, "     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
	else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"     _STA1=", *drl_prm6$, "; ANGLE 1ERE ARETE ABSCISSE", e$
	"     _INCA=", *drl_prm7$, "; ANGLE 2EME ARETE RELATIVE 1ERE", e$
	"     _ID=", *profrelatif, "; Pour retrait, Profond. en relatif", e$
	"         ;0=contour du coin en EXTER", e$
	"     _SETV[0]=", *drl_prm4$, "; long Maxi 2EME PT sur X EN +", e$
	"     _SETV[1]=", *drl_prm5$, "; long Maxi 4eme PT sur Y EN +", e$
	"     _EVNUM=20 ; Valeur empirique", e$
	#if drl_prm10$ = 1,
		#[
		#"    _TUL=", drl_prm8$ "; Tolerance MAXI", e$
		#"    _TLL=", drl_prm9$ "; Tolerance MINI", e$
		#]
	#"    _TSA=1 ; Zone de fiabilite +-1mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=5 ; Course de mesure +-5mm", e$
	"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE961", e$
	p_ori_usi_force
	prv_drill_cycl = 10

pdrlcst_11   #Cycle de palpage Pt de rEf. INTER COIN"   
	spaces$ = 1
	#gcode$ = 0
	#profrelatif = (initht$-depth$) * ( -1)
	profrelatif = (refht$-depth$) * ( -1)
	if prv_drill_cycl = 11, pdrlcst_2$, ex$
	perreurPalp4
	n$, "; REF. INTER COIN", e$
	"     _MVAR=105 ; COIN INTER 3 POINTS", e$
	#"     _MVAR=107 ; COIN INTER 4 POINTS", e$
	if drl_prm10$ = 1, "     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
	else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"     _STA1=", *drl_prm6$, "; ANGLE 1ERE ARETE ABSCISSE", e$
	"     _INCA=", *drl_prm7$, "; ANGLE 2EME ARETE RELATIVE 1ERE", e$
	"     _ID=", *profrelatif, "; Pour retrait, Profond. en relatif", e$
	"         ;0=contour du coin en EXTER", e$
	"     _SETV[0]=", *drl_prm4$, "; long Maxi 2EME PT sur X EN +", e$
	"     _SETV[1]=", *drl_prm5$, "; long Maxi 4eme PT sur Y EN +", e$
	"     _EVNUM=20 ; Valeur empirique", e$
	#if drl_prm10$ = 1,
		#[
		#"     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
		#"     _TLL=", drl_prm9$ "; Tolerance MINI", e$
		#]
		#"     _TSA=1 ; Zone de fiabilite +-1mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=5 ; Course de mesure +-5mm", e$
	"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE961", e$
	p_ori_usi_force
	prv_drill_cycl = 11

pdrlcst_12   #Cycle de palpage Pt de rEf. EN Z" 
	spaces$ = 1
	profrelatif = (refht$-depth$) * ( -1)
	if prv_drill_cycl = 12, pdrlcst_2$, ex$
	#gcode$ = 0
	spaces$ = 1
	if drl_prm10$ = 1,
		[
		#_Axis=Z, _OVR[0]= valeur de consigne,  _OVR[4]= valeur rEelle, _OVR[8]= TOL+, _OVR[12]= TOL-, _OVR[16]= diffErence page A-405
		"     _PROTVAL[1]=", 34, "R27,_Axis,_OVR[0],_OVR[4],_OVR[8],_OVR[12],_OVR[16],_TIME", 34,  e$
		n$, ";MESURE EN Z", e$
		]
	else, n$, ";REF. EN Z", e$
	"     _MVAR=100 ; 100= avec correction du DO", e$
	if drl_prm10$ = 1,
		[
		"     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
		]
	else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"     _SETVAL=", *depth$, "; Z de palpage", e$
	"     _MA=3 ; Axe de mesure 3 = Z", e$
	"     _EVNUM=20 ; Valeur empirique", e$
	if drl_prm10$ = 1,
		[
		"     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
		"     _TLL=", drl_prm9$ "; Tolerance MINI", e$
		]
	"     _TSA=1 ; Zone de fiabilite +-1mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=3 ; Course de mesure +-3mm", e$
	"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE978", e$
	p_ori_usi_force
	prv_drill_cycl = 12

pdrlcst_13   #Cycle de palpage Pt de rEf. FACE EN X" 
	spaces$ = 1
	if prv_drill_cycl = 13, pdrlcst_2$, ex$
	#gcode$ = 0
	palpage = x$
	if peck1$ = 1, n$, "G1 G91 X+3.5 F1000", e$    # Degagement en X- pour palpage en X+ (3.5 pour palpeur D5)
	if peck1$ = 0, n$, "G1 G91 X-3.5 F1000", e$    # """"      X+    """"         X-     """
	perreurPalp2
	n$, "G90", e$
	n$, "G1", *z$, "F1000", e$
	if drl_prm10$ = 1,
	    [
	    #_Axis1=X, _OVR[1]= valeur de consigne, _OVR[5]= valeur rEelle, _OVR[9]= TOL+, _OVR[13]= TOL-, _OVR[17]= diffErence page A-405
	    "     _PROTVAL[2]=", 34, "R27,_Axis1,_OVR[1],_OVR[5],_OVR[9],_OVR[13],_OVR[17],_TIME", 34,  e$
	    n$, "; MESURE EN X", e$
	    ]
	else, n$, ";REF. EN X", e$
	"     _MVAR=100 ; 100= avec correction du DO", e$
	if drl_prm10$ = 1,
	    [
	    "     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
	    ]
	  else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"   ", *palpage, "; X de palpage", e$
	"     _MA=1 ; Axe de mesure 1 = X", e$
	"     _EVNUM=20 ; Valeur empirique", e$
	if drl_prm10$ = 1,
	    [
	    "     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
	    "     _TLL=", drl_prm9$ "; Tolerance MINI", e$
	    ]
	"     _TSA=1 ; Zone de fiabilite +-1mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=2 ; Course de mesure +-2mm", e$
	"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE978", e$
	p_ori_usi_force
	prv_drill_cycl = 13

pdrlcst_14   #Cycle de palpage Pt de rEf. FACE EN Y" 
	spaces$ = 1
	if prv_drill_cycl = 14, pdrlcst_2$, ex$
	#gcode$ = 0
	palpage = y$
	if peck1$ = 1, n$, "G1 G91 Y+3.5 F1000", e$    # Degagement en Y- pour palpage en Y+ (3.5 pour palpeur D5)
	if peck1$ = 0, n$, "G1 G91 Y-3.5 F1000", e$    # """"      Y+    """"         Y-     """
	perreurPalp3
	n$, "G90", e$
	n$, "G1", *z$, "F1000", e$
	if drl_prm10$ = 1,
	    [
	    #_Axis2=Y, _OVR[2]= valeur de consigne, _OVR[6]= valeur rEelle, _OVR[10]= TOL+, _OVR[14]= TOL-, _OVR[18]= diffErence page A-405
	    "     _PROTVAL[3]=", 34, "R27,_Axis2,_OVR[2],_OVR[6],_OVR[10],_OVR[14],_OVR[18],_TIME", 34,  e$
	    n$, ";MESURE EN Y", e$
	    ]
	else, n$, ";REF. EN Y", e$
	"     _MVAR=100 ;100= avec correction du DO", e$
	if drl_prm10$ = 1,
	    [
	    "     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
	    ]
	  else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"   ", *palpage, "; Y de palpage", e$
	"     _MA=2 ; Axe de mesure 2 = Y", e$
	"     _EVNUM=20 ; Valeur empirique", e$
	if drl_prm10$ = 1,
	    [
	    "     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
	    "     _TLL=", drl_prm9$ "; Tolerance MINI", e$
	    ]
	"     _TSA=1 ; Zone de fiabilite +-1mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=2 ; Course de mesure +-2mm", e$
	"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE978", e$
	p_ori_usi_force
	prv_drill_cycl = 14

pdrlcst_15   #Cycle de palpage Pt de rEf. sur une rainure ou languette EN X ou Y" 
	spaces$ = 1
	if prv_drill_cycl = 15, pdrlcst_2$, ex$
	#gcode$ = 0
	#pt de dEpart suivant inter ou exter
	#x_depart = pt de dEpart de palpage en X
	#y_depart = pt de dEpart de palpage en Y
	#fin
	X_ = x$
	Y_ = y$
	if drl_prm1$ = 1,   # RAINURE
	    [
	    if drl_prm10$ <> 1, n$, ";REF. SUR UNE RAINURE", e$
	    else, n$, ";MESURE SUR UNE RAINURE", e$
	    n$, ";-POSITION A L INTERIEUR PRES DE", e$
	    n$, ";LA FACE A PALPER", e$
	    n$, ";Z DANS LA RAINURE-", e$
	    p_X_Y_depart
	    #n$, *sgcode, *x_depart, *y_depart, "; decalE de la face + garde + rayon du palpeur", e$   
	    n$, "G01 MEAS=1", z$, "F1000", e$   
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    mvar = 103
	    ]
	if drl_prm2$ = 1,   # LANGUETTE
	    [
	    if drl_prm10$ <> 1, n$, "; REF. SUR UNE LANGUETTE", e$
	    else, n$, "; MESURE SUR UNE LANGUETTE", e$
	    n$, "; -POSITION A L EXTERIEUR PRES DE", e$
	    n$, "; LA FACE A PALPER", e$
	    n$, "; Z SOUS LA LANGUETTE-", e$
	    p_X_Y_depart
	    n$, "G01 MEAS=1", z$, "F1000", e$   
	    n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	    mvar = 104
	    ]
	perreurPalp1
	if mvar = 103,  # RAINURE
	    [
	    #n$, "G1", z$, "F1000", e$
	    "     _MVAR=", *mvar, "; _MVAR =103 REF. SUR UNE RAINURE", e$
	    ]
	if mvar = 104,  # LANGUETTE
	    [
	    #profrelatif = (initht$-depth$) * ( -1)
	    profrelatif = (refht$-depth$)
	    "     _MVAR=", *mvar, "; _MVAR =104 REF. SUR UNE LANGUETTE", e$
	    #"    _ID=", profrelatif, ";Profondeur en relatif", e$
	    "     _ID=", *profrelatif, "; Valeur de saut en relatif **EN +**", e$
	    "          ", "; depuis le Z de palpage", e$
	    ]
	if drl_prm10$ = 1,
	    [
	    "     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
	    ]
	  else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"     _SETVAL=", *drl_prm4$, ";Largeur a palper", e$    #palpage = _SETVAL=
	#"     _MA=2 ;Axe de mesure 2 = Y", e$
	"     _CPA=", *X_, "; ABSCISSE centre = X", e$
	"     _CPO=", *Y_, "; Ordonnee centre = Y", e$
	"     _STA1=", *drl_prm5$, "; Valeur de l angle de palpage", e$
	"     _EVNUM=20 ; Valeur empirique", e$
	if drl_prm10$ = 1,
	    [
	    "     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
	    "     _TLL=", drl_prm9$ "; Tolerance MINI", e$
	    ]
	"     _TSA=1 ; Zone de fiabilite +-1mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=2 ; Course de mesure +-2mm", e$
	"     _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE979", e$
	p_ori_usi_force
	prv_drill_cycl = 15

p_X_Y_depart
	spaces$ = 1
	#Palpage en X
	if drl_prm6$ <> 0,
	    [
	    if drl_prm6$ < 0,
	        [
	        X_depart = X_-((drl_prm4$/2)+4) #pt centre X - (valeur de la largeur A  palper /2) +4 de garde)
	
	        ]
	    if drl_prm6$ > 0,
	        [
	        X_depart = X_+((drl_prm4$/2)+4) #pt centre X + (valeur de la largeur A  palper /2) +4 de garde)
	        ]
	    n$, *sgcode, *X_depart, "; decalE de la face + garde + rayon du palpeur", e$   
	    if drl_prm10$ = 1,
	            [
	            #_Axis1=X, _OVR[1]= valeur de consigne, _OVR[5]= valeur rEelle, _OVR[9]= TOL+, _OVR[13]= TOL-, _OVR[17]= diffErence page A-405
	            "     _PROTVAL[2]=", 34, "R27,_Axis1,_OVR[1],_OVR[5],_OVR[9],_OVR[13],_OVR[17],_TIME", 34,  e$
	            n$, ";MESURE EN X", e$
	            ]
	    ]
	#Palpage en Y
	if drl_prm7$ <> 0,
	    [
	    if drl_prm7$ < 0,
	        [
	        Y_depart = Y_-((drl_prm4$/2)+4) #pt centre Y - (valeur de la largeur A  palper /2) +4 de garde)
	        ]
	    if drl_prm7$ > 0,
	        [
	        Y_depart = Y_+((drl_prm4$/2)+4) #pt centre Y + (valeur de la largeur A  palper /2) +4 de garde)
	        ]
	    n$, *sgcode, *Y_depart, "; decalE de la face + garde + rayon du palpeur", e$   
	    if drl_prm10$ = 1,
	        [
	        #_Axis2=Y, _OVR[2]= valeur de consigne, _OVR[6]= valeur rEelle, _OVR[10]= TOL+, _OVR[14]= TOL-, _OVR[18]= diffErence page A-405
	        "     _PROTVAL[3]=", 34, "R27,_Axis2,_OVR[2],_OVR[6],_OVR[10],_OVR[14],_OVR[18],_TIME", 34,  e$
	        n$, ";MESURE EN Y", e$
	        ]
	    ]

pdrlcst_16   #Cycle de palpage pour redresser une surface en Z avec Origine" 
	spaces$ = 1
	if prv_drill_cycl = 16, pdrlcst_2$, ex$
	#gcode$ = 0
	n$, "; REF. ORIENTATION DE FACE EN Z", e$
	n$, "$P_UIFR[", *dwell$, "]= $P_UIFR[", *workofs_, "] ; Copie la valeur du dEcallage actif dans le nouveau", e$
	n$, "; POSITION XY A L INTERIEUR DE LA FACE A PALPER", e$
	n$, "; ATTENTION AUX OBSTACLES entre les POINTS", e$
	#n$, "G01 MEAS=1", *zr$, "F1000", e$   
	#n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	"     _MVAR=100106 ; MESURE DE 2 angles AVEC REFERENCE", e$
	"     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"     _ID=", *peck1$, "; ABSCISSE - 2EME PT sur X EN + RELATIF au 1er PT", e$
	"     _SETV[0]=", *peck2$, "; ORDONNEE - 3EME PT sur Y EN + RELATIF au 1er PT", e$
	"     _STA1=0 ; ANGLE autour du 1er AXE du PLAN", e$
	"     _INCA=0 ; ANGLE autour du 2EMZ AXE du PLAN", e$
	"     _EVNUM=0 ; Valeur empirique", e$
	"     _TSA=20 ; Zone de fiabilite +-20mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=40 ; Course de mesure +-40mm", e$
	#"    _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE998", e$
	p_ori_usi_force
	perreurPalp6
	n$, "; Prise en compte du nouveau plan", e$
	n$, "; Rotation des axes A et B", e$
	spaces$ = 1
	n$, ";", e$
	result = mprint(s_messagePalp1_1)
	result = mprint(s_messagePalp1_2)
	result = mprint(s_messagePalp1_3)
	result = mprint(s_messagePalp1_4)
	#n$, "; ATTENTION prEvoir ", e$
	#n$, "; REfErence en Z sur la face avec le nouveau plan CYCLE978 ", e$
	#p_ori_usi_force
	#n$, "; Mesure d angle en Y sur la face vertic. avec le nouveau plan CYCLE998 ", e$
	#p_ori_usi_force
	#n$, "; REfErence en X sur la face vertic. avec le nouveau plan CYCLE978 ", e$
	#p_ori_usi_force
	#n$, "; REfErence en Y sur la face vertic. avec le nouveau plan CYCLE978 ", e$
	#p_ori_usi_force
	prv_drill_cycl = 16

pdrlcst_17   #Cycle de palpage pour redresser suivant un angle sur une surface en X ou Y avec Origine"
	spaces$ = 1
	if prv_drill_cycl = 17, pdrlcst_2$, ex$
	#gcode$ = 0
	n$, "; REF. ORIENTATION ANGULAIRE D UNE FACE EN X OU Y", e$
	n$, "; POSITION XY A L INTERIEUR DE LA FACE A PALPER", e$
	if peck1$ = 1 & peck2$ > 0, n$, "G01 G91 MEAS=1 X5. F1000", e$
	if peck1$ = 1 & peck2$ < 0, n$, "G01 G91 MEAS=1 X-5. F1000", e$
	if peck1$ = 2 & peck2$ > 0, n$, "G01 G91 MEAS=1 Y5. F1000", e$
	if peck1$ = 2 & peck2$ < 0, n$, "G01 G91 MEAS=1 Y-5. F1000", e$
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	n$, "G90", e$
	n$, "G01 MEAS=1", *z$, "F1000", e$  
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	"     _MVAR=105 ; MESURE DE 1 ANGLE EN X OU Y AVEC REFERENCE", e$
	"     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	if peck1$ = 1,
	    [
	    "     _MA=101 ;Axe de mesure 1 = X palpage en X", e$
	    "     _ID=", *peck2$, "; ABSCISSE - longueur en X entre les 2 PTs", e$
	    #"     _SETVAL=0 ; ORDONNEE - longueur en X entre les 2 PTs", e$
	    ]
	if peck1$ = 2,
	    [
	    "     _MA=102 ; Axe de mesure 2 = Y palpage en Y", e$
	    #"     _ID=0 ; ABSCISSE - longueur en X entre les 2 PTs", e$
	    "     _SETVAL=", *peck2$, "; ORDONNEE - longueur en Y entre les 2 PTs", e$
	    ]
	"     _RA=0 ; Nombre de rotation d'axe", e$
	"     _STA1=0 ; ANGLE autour du 1er AXE du PLAN", e$
	"     _EVNUM=0 ; Valeur empirique", e$
	"     _TSA=10 ; Zone de fiabilite +-10mm", e$
	"     _PRNUM=1 ; Numero de palpeur", e$
	"     _VMS=200 ; Vitesse de mesure", e$
	"     _NMSP=1 ; Nombre de mesure au meme point", e$
	"     _FA=10 ; Course de mesure ANGULAIRE MAXI +-10mm", e$
	#"    _CHBIT[21]=1 ; 1=Valeur origine 0=Valeur de difference", e$
	n$, "CYCLE998", e$
	p_ori_usi_force
	n$, "; ATTENTION prEvoir ", e$
	n$, "; REfErence en X et Y ", e$
	n$, ";", e$
	prv_drill_cycl = 17

pdrlcst_repetitions
	#spaces$ = 1
	#n$, "G1", *zr$, "F1000", e$
	#n$, *sgcode, "MEAS=1", *x$, *y$, "F=V_SPEED", e$
	#n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	
	if old_profrelatif <> profrelatif & drillcyc$ <> 12, "     _ID=", *profrelatif, ";Profondeur en relatif", e$
	
	if drl_prm10$ = 1,
	    [
	    if mvar = 101, "     _MVAR=", *mvar, "; _MVAR =101 REF. INTER DIAMETRE", e$
	    if mvar = 102, "     _MVAR=", *mvar, "; _MVAR =102 REF. EXTER DIAMETRE", e$
	    if mvar = 105, "     _MVAR=", *mvar, "; _MVAR =105 REF. INTER RECTANGLE", e$
	    if mvar = 106, "     _MVAR=", *mvar, "; _MVAR =106 REF. EXTER RECTANGLE", e$
	    if mvar = 101 | mvar = 102, "     _SETVAL=", *peck1$, ";Diametre de palpage", e$
	    if mvar = 105 | mvar = 106,
	        [
	        "     _SETV[0]=", *peck1$, ";Longueur en X", e$
	        "     _SETV[1]=", *peck2$, ";Largeur en Y", e$
	        ]
	    if old_drl_prm8 <> drl_prm8$, "     _TUL=", *drl_prm8$ "; Tolerance MAXI", e$
	    if old_drl_prm9 <> drl_prm9$, "     _TLL=", *drl_prm9$ "; Tolerance MINI", e$
	    old_drl_prm8 = drl_prm8$
	    old_drl_prm9 = drl_prm9$
	    ]
	n$, "MCALL", e$
	n$, "R27=R27+1 ; IncrEment du compteur de palpages", e$
	old_profrelatif = profrelatif

pdrlcst_8_2      #Cycle de palpage Pt de rEf./mesure int. (exter) rectangulaire"   
	spaces$ = 1
	if drl_prm1$ = 1,
		[
		n$, ";REF. INT. RECTANGLE", e$
		mvar = 105
		]   # SECURITE EN INTER
	if drl_prm2$ = 1,
		[
		n$, ";REF. EXT. RECTANGLE", e$
		mvar = 106
		]   # SECURITE EN EXTER
	n$, "G1", *zr$, "F1000", e$
	n$, *sgcode, "MEAS=1", *x$, *y$, "F=V_SPEED", e$
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	pdrlcst_repetitions
	if drl_prm10$ = 1, pdrlcst_8_2_2
	#"    _ID=", profrelatif, ";Profondeur en relatif", e$
	#n$, "MCALL", e$
	#n$, "R27=R27+1 ; IncrEment du compteur de palpages", e$

pdrlcst_9_2      #Cycle de palpage Pt de rEf./mesure int. (exter) DiamEtre" 
	spaces$ = 1
	if drl_prm1$ = 1,
	    [
	    n$, ";REF. INT. DIAMETRE", e$
	    mvar = 101
	    ]   # SECURITE EN INTER
	  if drl_prm2$ = 1,
	    [
	    n$, ";REF. EXT. DIAMETRE", e$
	    mvar = 102
	    ]
	n$, "G1", *zr$, "F1000", e$
	n$, *sgcode, "MEAS=1", *x$, *y$, "F=V_SPEED", e$
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	pdrlcst_repetitions
	if drl_prm10$ = 1, pdrlcst_9_2_2
	#"    _ID=", profrelatif, ";Profondeur en relatif", e$
	#n$, "MCALL", e$
	#n$, "R27=R27+1 ; IncrEment du compteur de palpages", e$

pdrlcst_10_2     #Cycle de palpage Pt de rEf. EXTER COIN"    
    "    _ID=", profrelatif, ";Profondeur en relatif", e$

pdrlcst_11_2     #Cycle de palpage Pt de rEf. INTER COIN"    
    "    _ID=", profrelatif, ";Profondeur en relatif", e$

pdrlcst_12_2     #Cycle de palpage Pt de rEf. EN Z"  
	spaces$ = 1
	if drl_prm10$ = 1,
	    [
	    n$, ";MESURE EN Z", e$
	    ]
	  else, n$, ";REF. EN Z", e$
	n$, "G1", *zr$, "F1000", e$
	n$, *sgcode, "MEAS=1", *x$, *y$, "F=V_SPEED", e$
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	"     _SETVAL=", *depth$, ";Z de palpage", e$
	pdrlcst_repetitions
	#n$, "MCALL", e$
	#n$, "R27=R27+1 ; IncrEment du compteur de palpages", e$
	#spaces$ = 0

pdrlcst_13_2     #Cycle de palpage Pt de rEf. FACE EN X" 
	spaces$ = 1
	palpage = x$
	n$, "G1", *zr$, "F1000", e$
	n$, *sgcode, "MEAS=1", *x$, *y$, "F=V_SPEED", e$
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	if peck1$ = 1, n$, "G1 G91 X+3.5 F1000", e$    # Degagement en X- pour palpage en X+ (3.5 pour palpeur D5)
	if peck1$ = 0, n$, "G1 G91 X-3.5 F1000", e$    # """"      X+    """"         X-     """
	n$, "G90", e$
	perreurPalp2
	if drl_prm10$ = 1,
	    [
	    "     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
	    ]
	  else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"   ", *palpage, ";X de palpage", e$
	"     _MA=1 ;Axe de mesure 1 = X", e$
	if drl_prm10$ = 1,
	    [
	    "     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
	    "     _TLL=", drl_prm9$ "; Tolerance MINI", e$
	    n$, "R27=R27+1 ; IncrEment du compteur de palpages", e$
	    ]
	n$, "MCALL", e$

pdrlcst_14_2     #Cycle de palpage Pt de rEf. FACE EN Y" 
	spaces$ = 1
	palpage = y$
	n$, "G1", *zr$, "F1000", e$
	n$, *sgcode, "MEAS=1", *x$, *y$, "F=V_SPEED", e$
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	if peck1$ = 1, n$, "G1 G91 Y+3.5 F1000", e$    # Degagement en Y- pour palpage en Y+ (3.5 pour palpeur D5)
	if peck1$ = 0, n$, "G1 G91 Y-3.5 F1000", e$    # """"      Y+    """"         Y-     """
	n$, "G90", e$
	perreurPalp2
	if drl_prm10$ = 1,
	    [
	    "     _KNUM=0 ; Numero d'origine 0 pour MESURE", e$
	    ]
	  else, "     _KNUM=", *dwell$, "; Numero d'origine 1=54 2=55", e$
	"   ", *palpage, ";Y de palpage", e$
	if drl_prm10$ = 1,
	    [
	    "     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
	    "     _TLL=", drl_prm9$ "; Tolerance MINI", e$
	    n$, "R27=R27+1 ; IncrEment du compteur de palpages", e$
	    ]
	n$, "MCALL", e$

pdrlcst_15_2     #Cycle de palpage Pt de rEf. sur une rainure ou languette EN X ou Y" 
	spaces$ = 1
	n$, "G1", *zr$, "F1000", e$
	n$, *sgcode, "MEAS=1", *x$, *y$, "F=V_SPEED", e$
	p_X_Y_depart
	n$, "TEST_INTERRUPTION ; APPEL DU SOUS-PROG.", e$
	"     _SETVAL=", *drl_prm4$, ";Largeur a palper", e$    #palpage = _SETVAL=
	#"     _MA=2 ;Axe de mesure 2 = Y", e$
	"     _CPA=", *X_, "; ABSCISSE centre = X", e$
	"     _CPO=", *Y_, "; Ordonnee centre = Y", e$
	"     _STA1=", *drl_prm5$, ";Valeur de l angle de palpage", e$
	if drl_prm10$ = 1,
	    [
	    "     _TUL=", drl_prm8$ "; Tolerance MAXI", e$
	    "     _TLL=", drl_prm9$ "; Tolerance MINI", e$
	    n$, "R27=R27+1 ; IncrEment du compteur de palpages", e$
	    ]
	n$, "MCALL", e$

pdrlcst_16_2
    n$, ";CYCLE DE PALPAGE N 9 ***", e$
    n$, ";A completer", e$

pdrlcst_17_2
    n$, ";CYCLE DE PALPAGE N 10 ***", e$
    n$, ";A completer", e$

#-------------------- affichage des parametres de mesure --------------------------
pdrlcst_8_2_2    #Cycle de palpage Pt de rEf./mesure int. (exter) rectangulaire"    
	#_Axis1=X, _OVR[1]= valeur de consigne, _OVR[5]= valeur rEelle, _OVR[9]= TOL+, _OVR[13]= TOL-, _OVR[17]= diffErence page A-405
	"     _PROTVAL[2]=", 34, "R27,_Axis1,_OVR[1],_OVR[5],_OVR[9],_OVR[13],_OVR[17],_TIME", 34,  e$
	#_Axis2=Y, _OVR[2]= valeur de consigne, _OVR[6]= valeur rEelle, _OVR[10]= TOL+, _OVR[14]= TOL-, _OVR[18]= diffErence    page A-405
	"     _PROTVAL[3]=", 34, "R27,_Axis2,_OVR[2],_OVR[6],_OVR[10],_OVR[14],_OVR[18],_TIME", 34,  e$
	n$, "; MESURE EN X et Y dans le rectangle", e$

pdrlcst_9_2_2    #Cycle de palpage Pt de rEf./mesure int. (exter) DiamA¨tre" 
	#_Axis1=X, _OVR[1]= valeur de consigne, _OVR[5]= valeur rEelle, _OVR[9]= TOL+, _OVR[13]= TOL-, _OVR[17]= diffErence page A-405
	"      _PROTVAL[2]=", 34, "R27,_Axis1,_OVR[1],_OVR[5],_OVR[9],_OVR[13],_OVR[17],_TIME", 34,  e$
	#_Axis2=Y, _OVR[2]= valeur de consigne, _OVR[6]= valeur rEelle, _OVR[10]= TOL+, _OVR[14]= TOL-, _OVR[18]= diffErence page A-405
	"      _PROTVAL[3]=", 34, "R27,_Axis2,_OVR[2],_OVR[6],_OVR[10],_OVR[14],_OVR[18],_TIME", 34,  e$
	n$, ";MESURE EN X et Y dans le DIAMETRE", e$

fmt "Z" 4 nombre_Va_et_Vient
fmt "Z" 2 Z_dep_brosse
fmt "Z" 2 Z_fin_brosse
pdrlcst_18 	# Cycle Brossage EBAVURAGE  
	n$, s_com_open, "CYCLE DECOMPOSE D EBAVURAGE A LA BROSSE", s_com_close, e$
	if drill_4_axes = 1, p_drill_5axes    
	p_casse_modalite        	# casser la modalité de xyzra
	p_casse_modalite_perce      # casser la modalité de la garde et la prof
	Z_dep_brosse = drl_sel_tos$
	Z_fin_brosse = z$
	initht_ = initht$
	n$, "M3 S20", e$
	n$, "G01", *Z_fin_brosse, "F300", e$
	n$, *ssa, pgamme, *spdlon, e$
	while nombre_Va_et_Vient < peck2$, [
		nombre_Va_et_Vient = nombre_Va_et_Vient +1
		n$, *Z_dep_brosse, e$		
		n$, *Z_fin_brosse, e$			
		]
	nombre_Va_et_Vient = 0
	n$, *Z_dep_brosse, e$
	n$, "M5", e$
	gcode$ = 0
	n$, *sgcode, *initht_, e$	
	perreurTaraud
	
pdrlcst_18_2 	# Cycle Brossage EBAVURAGE  
	if drill_4_axes = 1, p_drill_5axes_2  
	xabs = x$
	yabs = y$
	gcode$ = 0
	n$, *sgcode, xabs, yabs, e$
	p_casse_modalite        	# casser la modalité de xyzra
	p_casse_modalite_perce      # casser la modalité de la garde et la prof
	Z_dep_brosse = drl_sel_tos$
	Z_fin_brosse = z$
	initht_ = initht$
	n$, "M3 S20", e$
	n$, "G01", *Z_fin_brosse, "F300", e$
	n$, *ssa, pgamme, *spdlon, e$
	while nombre_Va_et_Vient < peck2$, [
		nombre_Va_et_Vient = nombre_Va_et_Vient +1
		n$, *Z_dep_brosse, e$		
		n$, *Z_fin_brosse, e$			
		]
	nombre_Va_et_Vient = 0
	n$, *Z_dep_brosse, e$
	n$, "M5", e$
	gcode$ = 0
	n$, *sgcode, *initht_, e$

pdrlcst_19    # perçage très profond avec trous d'huile   
	gcode$ = 0
	p_erreur_lub_perc_prof
	#result = mprint(s_mess_per_prof)
	#result = mprint(s_mess_per_prof2)
	#if ssa > 500, result = mprint(s_mess_per_prof3)    # "ATTENTION -S- DE DEPART > 500 Tr/mn A MODIFIER DANS L'ISO !"
	f_p_profond = abs(frplunge$ *2)
	depth_ = depth$
	tosz_ = tosz$
	initht_ = initht$
	refht_ = refht$
	z_dep_p_prof = tosz$ +2
	if dwell$ <1,	[
	    tempo = dwell$
	    tempo = tempo*1000   
	    ]
	n$, "( PERCAGE TRES PROFOND )", e$
	posi_p_prof = 2
	p_rot_perc_profond
	n$, "M4", *ssa, e$
	n$, "G4 X1.", e$
	n$, "G1", *refht_, f_p_profond, e$   # Z secu dehors
	n$, *z_dep_p_prof, "(Z DEPART PLUS 2MM)", e$    # Z départ
	posi_p_prof = 2
	p_rot_perc_profond
	n$, "M3", *ssa, e$
	n$, "G4 X1.", e$
	n$, *scoolantx, e$
	n$, "G4 X1.", e$
	n$, *depth_, *frplunge$, e$
	#n$, *tempo, e$
	n$, "M9", e$
	n$, *tosz_, "F1000", e$
	posi_p_prof = 1
	p_rot_perc_profond
	n$, "M3", *ssa, e$
	n$, initht_, e$
	drillcyc$ = -1
	drlcst7 = 1
    perreurTaraud

pdrlcst_19_2    # perçage très profond avec trous d'huile   
	gcode$ = 0
	p_position_trou
	#result = mprint(s_mess_per_prof)
	#result = mprint(s_mess_per_prof2)
	f_p_profond = abs(frplunge$ *2)
	z_dep_p_prof = tosz$ +2
	depth_ = depth$
	tosz_ = tosz$
	initht_ = initht$
	refht_ = refht$
	if dwell$ <1, [
	    tempo = dwell$
	    tempo = tempo*1000   
	    ]
	n$, "( PERCAGE TRES PROFOND )", e$
	n$, "M4",  e$
	n$, "G1", *refht_, f_p_profond, e$   # Z secu dehors
	n$, *z_dep_p_prof, "(Z DEPART PLUS 2MM)", e$    # Z départ
	posi_p_prof = 2
	p_rot_perc_profond
	n$, "M3", *ssa, e$
	n$, "G4 X1.", e$
	n$, *scoolantx, e$
	n$, "G4 X1.", e$
	n$, *depth_, *frplunge$, e$
	#n$, *tempo, e$
	n$, "M9", e$
	n$, *tosz_, "F1000", e$
	posi_p_prof = 1
	p_rot_perc_profond
	n$, "M3", *ssa, e$
	n$, initht_, e$
	drillcyc$ = -1
	drlcst7 = 1
	
#endregion

#region fin_cycles
#-------------------- fin de cycles
pcanceldc$   # Cancel canned drill cycle
	if opcode$ = 16, [
		n$, "MCALL", e$
		if drillref = 0, n$, "G0", *zabs_deb_fin_secu_p_5x, e$
		else, n$, "G0", *zabs, e$
		]    
	debut = 0
	if drill_4_axes = 0 & palpeur = 0, n$, "MCALL", e$ 

pcancelcc$   # Cancel canned drill cycle
#endregion

#region percages_5axes

#region si_dev_avec_decallage_G52
p_drill_5axes_commun_debut
	if Mode_reglage_PP = 0, n$, "--> pdrill_5_commun VOIR: ", e$ 	
	gcode$ = 0
	vx = u$ - x$
	vy = v$ - y$
	vz = w$ - z$
	longvec=sqrt(vx * vx + vy * vy + vz * vz)
	vx2 = (vx/longvec)
	vy2 = (vy/longvec)
	vz2 = (vz/longvec)
	if Mode_reglage_PP = 0, n$, "--> pdrill_5_commun VOIR: ", *vx, *vy, *vz, *longvec, *vx2, *vy2, *vz2, *m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$ 
	if diviseur = 1, [
		#m7$ = vx2
		m8$ = vy2
		m9$ = vz2
		]
	if diviseur = 2, [
		m7$ = vx2
		#m8$ = vy2
		m9$ = vz2
		]
	if type_dec_4x_percage = 1, [	#PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0
		tox4_ = 0	#((vx2 * abs(depth$)) + x$)
		toy4_ = 0 	#((vy2 * abs(depth$)) + y$)
		toz4_ = w$ 	#((vz2 * abs(depth$)) + z$)
		]
	if type_dec_4x_percage = 0, [	#PERCAGE EN ABSOLU PTs MC CLASSIQUE
		#n$, s_com_open, "PERCAGE EN ABSOLU PTs MC CLASSIQUE", s_com_close, e$
		]

p_drill_5axes_commun_fin
	if Mode_reglage_PP = 0, n$, "--> p_drill_5axes_commun_fin", e$  
	old_tox4 = tox4$    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
	old_toy4 = toy4$
	old_toz4 = toz4$
	old_w_= w$ 
	old_x= xr$
	old_y= yr$
	old_z= zr$
	#if type_dec_4x_percage = 1, x$=0, y$=0	#PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0
	!x$,!y$,!z$,!xr$,!yr$,!zr$
#endregion
	  
p_drill_5axes   # ecriture pour TOUS LES percageS en 4 axes continus **AVEC** ZONE DE SECU G1 OU G0 
	if Mode_reglage_PP = 0, [ 
		n$, "--> pdrill_5_1 VOIR", *x$, *y$, *z$, *zr$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$, e$
		*m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
		] 
	if old_op = 11, [	#force le "A/B" après le pmx$
		p_calcul_rot_pmx 
		n$, *xabs, *yabs, p_axeAB_pmx, e$
		if mi7$ = 1 & bloque = 2, bloque = 1, n$, sbloque, e$ 
		old_op = -1
		]
	#p_Z_mini_maxi_OP
	gcode$ = 0	
	#xabs = xnci$ 
	#yabs = ynci$
	#p_drill_5axes_commun_debut
	p_calcul_rot_pmx 	
	SDIS = refht$ - drl_sel_tos$	# test s'il y a une distance de sécurité 	
	n$, *sgcode, "G17", *xabs, *yabs, p_lubrif_ON, e$ 	
	if mi7$ = 1, bloque = 2, n$, sbloque, e$ 
	n$, *sgcode, p_axeAB_pmx, e$  
	if mi7$ = 1, bloque = 1, n$, sbloque, e$
	
	if axeA = 0, n$, *zr$, e$
	else, [
		if drillref = 0 & drl_sel_ini$ = SDIS, [				# ne pas remonter à la sécu entre 2	# reste en bas
			zabs_deb_fin_secu_p_5x = zabs + abs(depth$) + drl_sel_ref$ + refht$ + drl_sel_ini$ 	
			n$, *zabs_deb_fin_secu_p_5x, e$
			zabs_deb_fin_secu_p_5x = zabs + abs(depth$) + refht$
			n$, *zabs_deb_fin_secu_p_5x, e$
			] 		
		if drl_sel_ini$ > SDIS, [
			zabs_deb_fin_secu_p_5x = zabs + drl_sel_ini$ + abs(depth$)  		# AVEC la SECU
			n$, *zabs_deb_fin_secu_p_5x, e$
			]
		#if drl_sel_ini$ = SDIS, zabs = zabs + abs(depth$) + drl_sel_ref$ 		# SANS la SECU
		]
					
	debutpmx = 1
	if t$ <> old_t, [
	    #n$, "G52 X0. Y0. Z0.", e$
	    #p_degage_4_axes
	    old_t = t$
	    ]
	comment$
	if type_dec_4x_percage = 1, [	#PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0
		n$, "TRANSxx", *tox4_, *toy4_, *toz4_, e$
		xnci$ = 0
		ynci$ = 0
		]
	if type_dec_4x_percage = 0, [	#PERCAGE EN ABSOLU PTs MC CLASSIQUE
		#"ICI 4 AXES -------------------------", e$
		]

p_drill_5axes_2   # ecriture DE TOUS LES percageS SUIVANTS en 4 axes continus **SANS** la ZONE DE SECU
	if Mode_reglage_PP = 0, [
		n$, "--> pdrill_5_2 VOIR", *x$, *y$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$, e$ 
		*m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
		] 
	#p_drill_5axes_commun_debut
	p_correc_time_G0 
	if type_dec_4x_percage = 1, [	 
		if affichage_cycle = 1, [	# affichage aprEs l'affichage du cycle
			spaces$ = 1
			n$, "MCALL", e$
			n$, "TRANS X0 Y0 Z0", e$
			affichage_cycle = 0
			]
		xabs = xnci$ 
		yabs = ynci$
		n$, *sgcode, *xabs, *yabs, strcantext, e$
		n$, "TRANS", tox4$, toy4$, toz4$, e$
		]
	p_calcul_rot_pmx
		
	SDIS = refht$ - drl_sel_tos$	# test s'il y a une distance de sécurité
	
	if drillref = 0 & drl_sel_ini$ = SDIS, [				# ne pas remonter à la sécu entre 2	# reste en bas
		zabs_deb_fin_secu_p_5x = zabs + abs(depth$) + refht$   	
		] 		
	if drl_sel_ini$ > SDIS, [
		zabs_deb_fin_secu_p_5x = zabs + drl_sel_ini$ + abs(depth$)  							# AVEC la SECU
		]
	#if drl_sel_ini$ = SDIS, zabs = zabs + abs(depth$) + drl_sel_ref$ 							# SANS la SECU				
		
	pdril5x_annul
	# *old_axeA, *epsi, e$	
	if epsi <> 0, [	
		#p_Z_SECU_ret_5x
		if mi7$ = 1, bloque = 2, n$, sbloque, e$	# si ROT - Débloque		
		gcode$ = 0
		n$, sgcode, p_axeAB_pmx, e$ 
		if mi7$ = 1, bloque = 1, n$, sbloque, e$	# si ROT - Bloque
		epsi = 0
		]
	#old_garde_RTP = RTP
				
pdril5x_annul   # annulation percage 5 axes ENTRE 2
	if Mode_reglage_PP = 0, n$, "--> pdril5x_annul", e$
	if epsi <> 0 | nextop$ = 80 | gcode$ = 80 | nextop$ = 1003, [
		n$, "MCALL", e$, olf_fr_5axes = -1
		gcode$ = 0
		if drillref = 0, [
			zabs_deb_fin_secu_p_5x = zabs + drl_sel_ini$ + abs(depth$) + drl_sel_tos$
			n$, *sgcode, *zabs_deb_fin_secu_p_5x, e$
			]
		]
	
#endregion
#endregion 

#region Type_d_opErations
# Type d'operation
s_too_lop_0    : "NON DEFINIT"
s_too_lop_1    : "CONTOUR"
s_too_lop_2    : "PERCAGE"
s_too_lop_3    : "POCHE"
s_too_lop_4    : "TRANSFORMATION-MIRROR ROTATE TRANSLATE"
s_too_lop_5    : "MULTI-SURF. EBAUCHE PARALLELLE"
s_too_lop_6    : "MULTI-SURF. EBAUCHE RADIALE"
s_too_lop_7    : "MULTI-SURF. EBAUCHE PROJECTION"
s_too_lop_8    : "MULTI-SURF. EBAUCHE ISOPARAM"
s_too_lop_9    : "MULTI-SURF. EBAUCHE CONTOUR"
s_too_lop_10   : "MULTI-SURF. EBAUCHE POCHE"
s_too_lop_11   : "MULTI-SURF. FINIT. PARALLELLE"
s_too_lop_12   : "MULTI-SURF. FINIT. RADIALE"
s_too_lop_13   : "MULTI-SURF. FINIT. PROJECTION"
s_too_lop_14   : "MULTI-SURF. FINIT. ISOPARAM"
s_too_lop_15   : "MULTI-SURF. FINIT. CONTOUR"
s_too_lop_16   : "OPERATION PAR C-HOOK"
s_too_lop_17   : "ENTREE MANUELLE"
s_too_lop_18   : "CERCLE"
s_too_lop_19   : "POINT"
s_too_lop_20   : "LIMITATION"
s_too_lop_21   : "REGLE"
s_too_lop_22   : "REVOLUTION"
s_too_lop_23   : "LETTRE"
s_too_lop_24   : "BALAYEE 2D"
s_too_lop_25   : "BALAYEE 3D"
s_too_lop_26   : "CARREAU"
s_too_lop_27   : "SECTION"
s_too_lop_28   : "PERCAGE 5-AXES"
s_too_lop_29   : "COURBE 5-AXES"
s_too_lop_30   : "PROJECT. SUR UN PLAN"
s_too_lop_31   : "PROJECT. SUR UN CYLINDRE"
s_too_lop_32   : "PROJECT. SUR UNE SPHERE"
s_too_lop_33   : "PROJECT. SUR UN CONE"
s_too_lop_34   : "PROJECT. SUR UNE SECTION"
s_too_lop_35   : "PROJECT. SUR UNE SURFACE"
s_too_lop_36   : "NON-ASSOCIATIF CONTOUR"
s_too_lop_37   : "NON-ASSOCIATIF PERCAGE"
s_too_lop_38   : "NON-ASSOCIATIF POCHE"
s_too_lop_39   : "MULTI-SURF. FINIT. PENCIL TRACE"
s_too_lop_40   : "MULTI-SURF. FINIT. LEFTOVER STOCK"
s_too_lop_41   : "MULTI-SURF. FINIT. STEEP"
s_too_lop_42   : "MULTI-SURF. FINIT. SHALLOW"
s_too_lop_43   : "MULTI-SURF. FINIT. CONSTANT SCALLOP"
s_too_lop_44   : "MULTI-SURF. EBAUCHE PLUNGE"
s_too_lop_45   : "MULTI-SURF. FINIT. 5-AXE ISOPARAM"
s_too_lop_46   : "MULTI-SURF. FINIT. 4-AXE"
s_too_lop_47   : "MERGED IN ASCII NCI"
s_too_lop_48   : "5-AXE SWARF"
s_too_lop_49   : "5-AXE ROLL DIE"
s_too_lop_50   : "NON DEFINIT"
s_too_lop_51   : "CONTOURNAGE AXIAL"
s_too_lop_52   : "CONTOURNAGE RADIAL"
s_too_lop_53   : "CONTOURNAGE AXE C"
s_too_lop_54   : "VE PERCAGE, NOT USED NON-ASSOCIATI"
s_too_lop_55   : "PERCAGE AXIAL"
s_too_lop_56   : "PERCAGE RADIAL"
s_too_lop_57   : "PERCAGE AXE C"
s_too_lop_58   : "NON DEFINIT"
s_too_lop_59   : "NON DEFINIT"
s_too_lop_60   : "EBAUCHE"
s_too_lop_61   : "FINITION"
s_too_lop_62   : "GORGE"
s_too_lop_63   : "FILETAGE"
s_too_lop_64   : "PERCAGE"
s_too_lop_65   : "POINT"
s_too_lop_66   : "DRESSAGE"
s_too_lop_67   : "TRONCONNAGE"
s_too_lop_68   : "GORGE"
s_too_lop_69   : "ENTREE MANUELLE"
s_too_lop_70   : "MERGED ASCII"
s_too_lop_71   : "NON DEFINIT"
s_too_lop_72   : "NON DEFINIT"
s_too_lop_73   : "NON DEFINIT"
s_too_lop_74   : "CONTOUR FIL"
s_too_lop_75   : "CYCLE FIL"
s_too_lop_76   : "POCHE FIL"
s_too_lop_77   : "ENTREE MANUELLE FIL"
s_too_lop_78   : "POINT FIL"
s_too_lop_79   : "4-AXES FIL"
s_too_lop_80   : "TRANSFORMATION FIL"
s_too_lop_81   : "ASSOCIATIVE TRIMMED FIL"
s_too_lop_82   : "MERGED IN ASCII NCI FIL"
 
s_too_lop_100  : "FILETAGE A LA FRAISE"				# +18
s_too_lop_101  : "EDIT COMMON OPERATION PARAMETERS"
s_too_lop_102  : "SURFACAGE"
s_too_lop_103  : "ASSOCIATIF LIMITATION"
s_too_lop_104  : "CONTROL OPERATION SOLID PERCAGE"
s_too_lop_105  : "SLOT MILL"
s_too_lop_106  : "HELIX BORE"
s_too_lop_107  : "MULTI-SURF. EBAUCHE REPRISE"
s_too_lop_108  : "ASSOCIATIF NESTING CONTAINER OPERATION"

s_too_lop_201  : "CYCLE FINITION"					# +83
s_too_lop_202  : "CYCLE EBAUCHE"
s_too_lop_203  : "CYCLE EBAUCHE ET FINITION"
s_too_lop_204  : "CYCLE EBAUCHE DRESSAGE"
s_too_lop_205  : "CYCLE EBAUCHE ET FINITION DRESSAGE"
s_too_lop_206  : "CYCLE MODEL REPETITION EBAUCHE"
s_too_lop_207  : "CYCLE MODEL REPETITION EBAUCHE ET FINITION"
s_too_lop_208  : "CYCLE GORGE EBAUCHE"
s_too_lop_209  : "CYCLE GORGE FINITION"
s_too_lop_210  : "RAPIDE EBAUCHE"
s_too_lop_211  : "RAPIDE FINITION"
s_too_lop_212  : "RAPIDE GORGE"
s_too_lop_213  : "OPERATION GENEREE PAR C-HOOK"
s_too_lop_214  : "TRANSFER BRUT"
s_too_lop_215  : "RETOURNE BRUT"
s_too_lop_216  : "AVANCE BARRE"
s_too_lop_217  : "SERRAGE - DESSERAGE MORS"
s_too_lop_218 : "Tailstock operation"
s_too_lop_219 : "Steadyrest operation"
s_too_lop_220 : "Pinch-turn operation"
s_too_lop_221 : "Custom operation with tool" 
s_too_lop_222 : "Custom operation without tool" 
s_too_lop_223 : "PERCAGE AVANCE"
s_too_lop_224 : "Plunge turn (chained geometry)"
s_too_lop_225 : "Plunge turn (point geometry)"
s_too_lop_226 : "Turret park operation"
s_too_lop_227 : "Custom threading"
s_too_lop_228 : "B-axis contour turning (Mill-Turn only)"
s_too_lop_229 : "--------"
s_too_lop_230 : "Simple bar feed (Mill-Turn only)"
s_too_lop_231 : "Bar feed with tool stop or tool pull (Mill-Turn only)"
s_too_lop_232 : "Spindle clamp/unclamp (Mill-Turn only)"
s_too_lop_233 : "Spindle advance/retract (Mill-Turn only)"
s_too_lop_234 : "Spindle sync (Mill-Turn only)"
s_too_lop_235 : "Tailstock advance/retract (Mill-Turn only)"
s_too_lop_236 : "Turret park (Mill-Turn only)"
s_too_lop_237 : "Center operation(Mill-Turn only)"
s_too_lop_238 : "Steady rest operation(Mill-Turn only)"
s_too_lop_239 : "Steady rest point operation(Mill-Turn only)" 

s_too_lop_416 : "ENGRAVING"  					# +77          
s_too_lop_439 : "ART"                  
s_too_lop_309 : "5AXMSURF"           
s_too_lop_441 : "SWARF 5AX"            
s_too_lop_442 : "MORPH 5AX"            
s_too_lop_443 : "PARALLEL 5AX"        
s_too_lop_444 : "ALONGCURVE 5AX"      
s_too_lop_445 : "MESH 5AX"           
s_too_lop_446 : "ROUGHING 5AX"         
s_too_lop_447 : "PROJECT 5AX"          
s_too_lop_448 : "CONVERT 5AX"          
s_too_lop_449 : "PORT EXPERT"          
s_too_lop_450 : "BLADE EXPERT"         
s_too_lop_451 : "ROTARY ADV"           
s_too_lop_459 : "DEBURR"               
s_too_lop_460 : "EBAUCHE 3+2 AUTOM."  
s_too_lop_461 : "UNIFIE"               

s_too_lop : ""
fstrsel s_too_lop_0 tool_op$ s_too_lop 147 -1
#endregion

#region infos_outils_liste
#------------------Liste des OUTILS---------------------------------------------------
smanu : ""           		# string info outil texte dans "mandrin" (manufactured)
svide : " "
smand : ""           		# string info outil texte dans "mandrin" (chuck name)
snom_porte_outil : "" 		
snom_assemblage_outil_porte_outil : "" 		
sposi_porte_out_def : "Porte"   # string test prEsence "porte outil par dEfaut"
fmt   		7 posi_porte_out_defaut   
fmt   		7 longsmand     	
fmt  		4 paramT1    		# Num outil
fmt   		2 paramT2      		# Type d'outil
fmt   		2 paramT3      		# Matiere de l'outil 1=Rapide 2=carbure 3=carbure revetu 4=cermet 5=borzon
fmt   		2 paramT4      		# Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt "D=" 	2 paramT5   		# Diametre
fmt "R=" 	2 paramT6   		# Rayon de bout
fmt "P=" 	2 paramT7   		# PAS / Nombre de filet par mm
fmt "A=" 	2 paramT8   		# Angle de bout
fmt   		2 paramT9      		# Num de correcteur de rayon
fmt   		2 paramT10     		# Num de correcteur de longeur
fmt   		2 paramT11     		# Avance travail
fmt   		2 paramT12     		# Avance plongee
fmt   		2 paramT13     		# Avance retraction
fmt   		2 paramT14     		# Vitesse de broche
fmt   		2 paramT15     		# Type de lubrification 0=arret 1=eau 2=au centre 3=broche 4=les 2
fmt "NBR-DENTS="  4 paramT16 	# Nombre de dents

# géométrie de l'outil
fmt   	  6 paramT20            # Diamètre pilote
fmt "EP=" 6 paramT21            # Hauteur de coupe
fmt "HS=" 6 paramT22            # Hauteur de sortie totale
fmt   	  6 paramT23            # Hauteur helice
fmt   	  6 paramT24            # Diametre de queue
fmt   	  6 paramT25            # Diametre porte-outil
fmt   	  6 paramT26            # Hauteur porte-outil
fmt   	  6 paramT27            # 0=sens horaire 1=sens horaire
fmt   	  6 paramT28            # % de la vitesse de coupe
fmt   	  6 paramT29            # % de l'avance par dent
fmt   	  4 paramT30            # 0=pouces 1=metrique

#RENVOIE D ANGLE Aggregate head parameters
fmt   	  3 paramT41   			# Head axis in X
fmt   	  3 paramT42   			# Head axis in Y
fmt   	  3 paramT43   			# Head axis in Z
fmt   	  3 paramT44   			# Head body type: (0 = cylinder, 1 = square)
fmt   	  3 paramT45   			# Head body diameter
fmt   	  3 paramT46   			# Head body length
fmt   	  3 paramT47   			# Station body type (0 = cylinder, 1 = square)
fmt   	  3 paramT48   			# Station body diameter
fmt   	  3 paramT49   			# LONG: SORTIE / pince--> face  pince -- Station body length

stypT00 : "FORME"
stypT01 : "FORET A C."
stypT02 : "FORET A P."
stypT03 : "FORET"
stypT04 : "TARAUD A D."
stypT05 : "TARAUD A G."
stypT06 : "ALESOIR"
stypT07 : "BARRE D ALES."
stypT08 : "FR. COUTEAU"
stypT09 : "FR. A EBAVUR."
stypT10 : "FR."
stypT11 : "FR. BOULE"
stypT12 : "FR. A CHANF."
stypT13 : "TOURTEAU"
stypT14 : "FR. 3 T."
stypT15 : "FR. CONCAVE"
stypT16 : "FR. QUEUE D ARONDE"
stypT17 : "FR. CONIQUE RAYONNEE TRONQUEE"
stypT18 : "FR. SPHERIQUE"
stypT19 : "FR. TORIQUE"
stypT20 : "SPECIALE"
stypT21 : "FRAISE A GRAVER"
stypT22 : "FORET BRAD"
stypT23 : "BARRE D ALESAGE"
stypT24 : "FRAISE A FILETER"
stypT25 : "FRAISE TONNEAU"
stypT26 : "FRAISE DEPOUILLE"
stypT27 : "FRAISE LENTILLE"
stypT28 : "FRAISE LENTILLE TONNEAU"
stypT29 : "DIVERS"
stypeT : ""
fstrsel stypT00 paramT2 stypeT 30 -1

smatT0  : ""
smatT1  : "HSS"
smatT2  : "CA."
smatT3  : "CA. REVETU"
smatT4  : "CERMET"
smatT5  : "BORZON"
smatT6  : "BORZON"
smatT7  : "BORZON"
smatT8  : "BORZON"
smatT9  : "BORZON"
smatT10 : "INCONNU"
smatT : ""
fstrsel smatT0 paramT3 smatT 11 -1

ppas       # afficher ou non le pas
	if paramT7 > 0, *paramT7

ptypeBoutT # afficher on non le rayon de bout
	if paramT4 <> 0, *paramT6

pangleT    # afficher ou non l'angle de l'outil
	if paramT2 = 2 | paramT2 = 3 | paramT2 = 9 | paramT2 = 12 | paramT2 = 16 | paramT2 = 17, *paramT8

phauteurT  # afficher la hauteur de dent pour une fraise 3 tailles
	if paramT2 = 14, paramT21

ptype      # Pour afficher le texte des outils perso suivant comment. dans "mandrin" (chuck name)
	longsmand = strlen(smand)
	if longsmand > 5, *smand
	else, *stypeT

pporte_outil
	posi_porte_out_defaut = strstr(sposi_porte_out_def, snom_porte_outil)
	spaces$ = 1
	if posi_porte_out_defaut < 1, [ 
		if Nom_porte_outil_entete = 1, n$, "; porte out.:", no_spc$, snom_porte_outil, *paramT22, e$ 
		if Nom_porte_outil_entete = 2, n$, "; Assemblage:", no_spc$, snom_assemblage_outil_porte_outil, *paramT22, e$
		if Nom_porte_outil_entete = 3, n$, "; porte out.:", no_spc$, snom_porte_outil, "Assemblage:", no_spc$, snom_assemblage_outil_porte_outil, *paramT22, e$
		if Nom_porte_outil_entete > 0 & ra_type$ = 1 & ra_block$ >0, n$, s_com_open, "RENVOIE D'ANGLE AVEC LONGUEUR DE L AXE Z A LA FACE DE :", *paramT49, s_com_close, e$ 
		]

pwrttparam$    # lire les parametres (des outils) avant la sortie de l'ISO
    if affiche_prmcodes = 0, "-->pwrttparam DONNEES avant la sortie de l'ISO", ~prmcode$, "=", ~sparameter$, e$
	if syncaxis$ <> old_syncaxis, nbr_combi = nbr_combi + 1
	old_syncaxis = syncaxis$
	if prmcode$ = 15166, workofs_pwrtt = rpar(sparameter$, 1)   #15166=Val origine de base 
																#15181=Val Numéro de l'origine actif
																#15333=Val départ incrément, op transformation 
	#if prmcode$ = 15334, workofs_dec = rpar(sparameter$, 1)	#15334=Val incrément, op transformation
	if prmcode$ = 20002, smanu = sparameter$   
	if prmcode$ = 20003, smand = sparameter$   
	if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)
	if prmcode$ = 20007, paramT20 = rpar(sparameter$, 11)
	if prmcode$ = 20008, paramT41 = rpar(sparameter$, 9)
	#if prmcode$ = 12727, snom_porte_outil = sparameter$         
	if prmcode$ = 20020, snom_porte_outil = sparameter$ 
	if prmcode$ = 20021, snom_assemblage_outil_porte_outil = sparameter$         
	longsmand = strlen (smand)

parrosage  # affichage de "arrosage au centre"
	if paramT15 = 2, "ARROSAGE AU CENTRE"

pwrtt$      # Liste d'outils & infos (--> lecture avant traitement parcours)
    strtool$ = ucase(strtool$)
    smanu = ucase(smanu)
    # vErification des rotations avant le traitement ISO
    if m9$ <> 1, rotation_axe = 1               # Inclinaison des axes
	if nextop$ = 11, rotation_axe = 1			# useaxe = 1	#si pas de lecture def armoire en OP 5 axes seule
    if m1$ = 1 & m5$ <> 1, rotation_A = 1       # incliné en Y uniquement (et Z) = ROTATION SUR L'AXE X
    if m1$ <> 1 & m5$ = 1, rotation_B = 1       # incliné en X uniquement (et Z) = ROTATION SUR L'AXE Y
    if m1$ <> 1 & m5$ <> 1, rotation_axe = 2    # Erreur de plan
	if ra_type$ = 1 & ra_block$ >0, renvoi_d_angle = 1
	if ra_type$ = 1 & ra_block$ >0, rotation_axe = 0	# FORCE pas de 4 axes avec le RENVOI  
	
	# calcul nombre d'outils pour les temps
	# Temps de changement d'outil
	if t$ > 0, Nbr_outils = Nbr_outils + 1		# a changer
	
	if Affiche_temps_dll = 1, [ 	# TEMPS DE L OUTIL			
		if t$ > 0 & t$ <> old_t & old_t <> -9999, [	
			Types_Temps_DLL = plcval (s_Types_Temps_DLL, 2)
			if Types_Temps_DLL = 2, [
				p_Convert_time_dll 
				n$, "  ", s_com_open, "TPS OUT. = ", *Heure, *min, *sec, s_com_close, e$
				Tot_time_Out = 0
				]
			]
		]	

	# pour info : Type_infos_outil	 
	# 1 = NOM de l'outil "texte NOM" --> strtool$
	# 3 = NOM MC de l'outil et Infos géométrique réelle de l'outil
	# 4 = NOM de l'outil "texte NOM" & Infos géométrique réelle de l'outil --> = 0 + 2	
	if Liste_outils, [
	    if nom_outil = 1, [
	        if t$ > 0, [
				spaces$ = 0
				n$, s_com_open, " ", 34, strtool$, 34,
				spaces$ = 1
					if Type_infos_outil	= 1, e$
					if Type_infos_outil	= 2 | Type_infos_outil= 4, "--", *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$ 
					if Type_infos_outil	= 3, "--", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$ 
				pporte_outil
				]
	        ]
	    if nom_outil = 0, [
	        if outils_param = 0, [	# sans les parametres
				if t$ > 0, [	            	
					spaces$ = 1
					if Type_infos_outil	= 1, n$, "; T", paramT1, strtool$, e$					
					if Type_infos_outil	= 2 | Type_infos_outil	= 3, n$, "; T", no_spc$, paramT1, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  			
	            	if Type_infos_outil	= 4, n$, "; T", no_spc$, paramT1, strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  				
					pporte_outil
					]
				]
	        if outils_param = 1,  [  # avec les parametres
	            outil_paramT1 = paramT1
	            outil_paramT1 = outil_paramT1 + 500   
				if t$ > 0, [
					if Type_infos_outil	= 1, n$, "R", outil_paramT1, no_spc$, "=", no_spc$, paramT1, "; T=", no_spc$, paramT1, strtool$, e$	
					if Type_infos_outil	= 2 | Type_infos_outil	= 3, n$, "R", outil_paramT1, no_spc$, "=", no_spc$, paramT1, ";", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  
					if Type_infos_outil	= 4, n$, "R", outil_paramT1, no_spc$, "=", no_spc$, paramT1, ";", strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  
					pporte_outil
					]					
				]
	        ]
		]
    # Décalages d'origines en entête à afficher --> NE PAS LAISSER DE DECALLAGES VIDES --> METTRE UN "0"
	if affiche_ori_entete > 0, [	
		# 0 -1=54 / 1=55 / 2=56 /.../ 6=505 /...
		if xform_op_id$ <> op_id$, workofs_pwrtt = workofs$ & workofs_dec > 0, workofs_pwrtt = workofs_pwrtt +54   # OPERATIONS TRANSFORMEES 
		if xform_op_id$ = op_id$, workofs_pwrtt = workofs_pwrtt +54	
		#if old_workofs <> workofs$,	[
        	#workofs_pwrtt = workofs_pwrtt + 54	# 0|1=55 / 2=56 / 6=505
			#if workofs_pwrtt > 59, workofs_pwrtt = workofs_pwrtt + 445
        	#]
		if affiche_ori_entete = 1 | affiche_ori_entete = 11, subout$ = 1	# sous la liste d'outil
		if affiche_ori_entete = 2 | affiche_ori_entete = 22, subout$ = 3	# dans un autre fichier
		spaces$ = 1
		compteur_workofs = compteur_workofs + 1
		if compteur_workofs = 1, *e$, n$, s_com_open, "ORIGINES UTILISES :", s_com_close, e$
		if workofs_pwrtt <> old_workofs, [		
			if (workofs_pwrtt = 53 | workofs_pwrtt = 54) & ori_1 =0, workofs_pwrtt = 54, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_1 = 1
			if workofs_pwrtt = 55 & ori_2 =0, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_2 = 1
			if workofs_pwrtt = 56 & ori_3 =0, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_3 = 1
			if workofs_pwrtt = 57 & ori_4 =0, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_4 = 1
			if workofs_pwrtt = 58 & ori_5 =0, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_5 = 1
			if workofs_pwrtt = 59 & ori_6 =0, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_6 = 1
			if workofs_pwrtt = 60 & ori_7 =0, workofs_pwrtt = workofs_pwrtt + 445, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_7 = 1
			if workofs_pwrtt = 61 & ori_8 =0, workofs_pwrtt = workofs_pwrtt + 445, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_8 = 1				
			if workofs_pwrtt = 62 & ori_9 =0, workofs_pwrtt = workofs_pwrtt + 445, n$, s_com_open, *workofs_pwrtt, s_com_close, e$, ori_9 = 1
			]	
		old_workofs = workofs_pwrtt
		spaces$ = 0
		subout$ = 0
		] 
	#temps DLL POUR EVENTUELLEMENT L'AFFICHER EN ENTETE **BRUT DE Mc **SANS AFFINAGE POSSIBLE** & 
    sdllTimeOp = spathpst$ + "TimeOp.dll"	# A LAISSER DANS LE PWRTT$
	if Affiche_temps_dll = 1, [ 
	    if last_op_id_pwrtt <> op_id$,    [
	        sOpId = no2str(op_id$)
	        result = dll(sdllTimeOp,sOpId)
	        timeOp = rpar(spost_arg_1$,1)
	        timeTT = timeTT + timeOp
			Tot_time_Out = Tot_time_Out + timeOp		
			# TEMPS DE L OPERATION
			Types_Temps_DLL = plcval (s_Types_Temps_DLL, 1)
			if Types_Temps_DLL = 1, [
				p_Convert_time_dll 	#"aaaaa", *Tot_time_op, e$
				n$, "  ", s_com_open, "TPS OPE. = ", *Heure, *min, *sec, s_com_close, e$
				]
	        ]	
        strtool$ = ucase(strtool$)
		last_op_id_pwrtt = op_id$
		]
    if t$ <> old_t, old_t = t$
	if arctype$ <> 5 & arctype$ <> 2 & erreur_type_arcs = 1, p_erreur_config_type_arc
    ptravel
    pwritbuf5
		
#endregion

#region pmachineinfo_ lecture des parametres de def armoire et def machine
# Machine Definition Parameters
fprmtbl 17000   11   #13 Table Number, Size
#   Param   Variable to load value into
	17391   axis_label   #Axis label - 1=X,2=Y,3=Z	
    17397   srot_label   #Rotary Axis label (Generally A, B or C) - Not yet available.
	17401   rot_zero     #Rotary zero degree position	
	17402   rot_dir      #Rotary direction
	17408   rot_index    #Index or continuous
    17409   rot_angle    #Index step
    17410   rot_type     #M3/M4 Rotary type	
    17605   min_speed    #50 tr/min Minimum spindle speed	
    #17066   maxfrinv_m  #Maximum feedrate - inverse time - metric - Minimum value from MD as this is inverse time
    #17933   maxfrdeg     #Maximum feedrate deg/min
	17063   maxfeedpm_m  #Limit for feed in mm/min
    17101   all_cool_off #First coolant off command shuts off ALL coolant options
    17102   v9_coolant   #Use V9 coolant option

fprmtbl 18000   1           # Lecture des Param de def armoire
    18171   write_ops       # Autoriser l'ecriture de l'information CN d'operation
    #18458   CN_textes       # Nombre de caracteres pour les commentaires
    #18713   sous_prog_type  # type de merge des sous prog (0 apres prog principal 1 avant)
    #18705   cor_arc         # compensation sur les arcs autorisee
	
#---------------- BLOCS DE DEF MACHINE ET DEF ARMOIRE ---------------------------------
pmachineinfo$    # lecture des parametre de def armoire et def machine
    #rd_md is used to call pmachineinfo postblock and read the parameters of the selected axis
    #combination machine entity set in rd_mch_ent_no
    #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
    #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters

	if affiche_prmcodes = 0, "-->pmachineinfo DONNEES MACHINE ", ~prmcode$, "=", sparameter$, e$        # pour afficher tous les parametres

	#if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$
	#if prmcode$ = 18458, "nombre de caracteres de commentaire",  sparameter$, e$
	#if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$         # Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
	#if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$
	#if prmcode$ = 17201, *prmcode$, "nom de l'element =", sparameter$, e$

	if prmcode$ = 17063, fmaxi = rpar(sparameter$, 1)               # avance maxi en G1
    if prmcode$ = 17062, fmini = rpar(sparameter$, 1)               # avance mini en G1
	if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000)   # Run the parameter table for Machine Definition Parameters
	if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000)   # Lecture de la table de parametre Control Definition
	if prmcode$ >= 19000 & prmcode$ < 19900, result = fprm(19000)   # Run the parameter table for Toolpath Group Parameters
	if prmcode$ = 17012, s_nom_machine_entete = ucase(sparameter$)  # Nom de la machine
	#if prmcode$ = 17201,        [               					# nom du composant
        #if ucase(sparameter$) = spalette, palette = 1       		# si c'est une palette, activer la gestion de palette
        #]
	if prmcode$ = 19958,        [               					# type de composant  5 = axe rotatif
        type_composant = rpar(sparameter$, 1)
	        if type_composant = 5,  [               				# si c'est un axe rotatif
	        #useaxe = 1									#--> oui mais pas forcément utilisé
	        compt_axes_rot  = compt_axes_rot + 1            		# compter le nombre d'axes rotatif
	        ]
	    ]
    # AXE DE ROTATION UTILISé --> la configuration machine doit Etre dEfinie correctement
	#Direction de l'axe Z - Vers Y = ROTATION AXE A / Vers X = ROTATION AXE B
      if prmcode$ = 17392 & axis_label = 3, [
        Z_dir = rpar(sparameter$, 1)  #Z axis direction - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
        if Z_dir <> 3 & Z_dir <> 9, #vmc = 0   #0 = Horizontal Machine, 1 = Vertical Mill
        else, #vmc = 1
        ]	
	if prmcode$ = 17399,    [                   					# AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
        diviseur = rpar(sparameter$, 1)
        if diviseur > 3, diviseur = diviseur - 6        			# ne garder que x y z
        ]
	if prmcode$ = 17402,    [                   					# sens de l'axe rotatif 0=trigo 1=horaire
        sens_A_B= rpar(sparameter$, 1)
        if sens_A_B = 0, sens_A_B = 1                   			# variable sens pour le post pro
        else, sens_A_B = -1
        ]
	if prmcode$ = 17598, nbr_outil = rpar(sparameter$, 1)           # nombre d'outils du changeur de la def machine
    if prmcode$ = 17932, s_axe_rot_label = sparameter$              # 17391 AXE rotatif (ABC) (NOM DE L'axe -- PAS le LABEL)	
	if prmcode$ = 17921, fr_rapid_mach = rpar(sparameter$, 1)     	# ou 17925 avance rapide de la machine     
	if prmcode$ = 17597, tlchg_time = rpar(sparameter$, 1)    		# temps de changement d'outil de la machine
		
p_lire_axes   # Lecture des parametres de la combinaison d'axes uniquement
    #"p_lire_axes", e$
    if syncaxis$ <> old_syncaxis, [
        compt_axes_rot = 0
        erreur = 0
        ]
    rd_mch_ent_no$ = syncaxis$      			# pour avoir les infos de la conbinaison d'axe utilisée
    #rd_mch_ent_no$ = -2            			# forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    #rd_cd$                 					# lecture de la def armoire
    if lire_def_machine = 1, rd_md$          	# lecture de la def machine
    result = nwadrs(s_axe_rot_label, axeA)      # affectation du nom de l'axe rotatif en ABS
	#s_axe_rot_label = "I" + s_axe_rot_label    # affectation du nom de l'axe rotatif en INC
    #result = nwadrs(s_axe_rot_label, axeAi)    # affectation du nom de l'axe rotatif en INC
    p_test_machine
    old_syncaxis = syncaxis$

p_test_machine    # verif de la def machine
    #*nbr_combi, "---------", e$
    if nbr_combi > 1, erreur = 3        # le pst ne supporte q'une combinaison d'axe par programme
    if compt_axes_rot > 1, erreur = 2       # le pst ne supporte q'un axe rotaif
    #if write_ops = 0, erreur = 1        # Write NC Operation information MUST be enabled in CD
    #p_erreur

p_erreur
    !erreur
    !serreur
    if erreur <> 0, [
        if erreur = 4 & testerreur4 = 0, [
            serreur2 = serreur + no2str(increment_op_outil)
            result = mprint(serreur2, 3)
            if result = 3, serreur2 , e$, exitpost$ 	# abandonner
            if result = 4, serreur2                 	# recommencer
            if result = 5, testerreur4 = 1             	# ignorer
            ]
        if erreur <> 4, [
            result = mprint(s_erreur_nbr_axes_rot, 2)
            exitpost$
            ]
        ]

p_affiche_infos_config_armoire
    #affichage des prmcode$
    if Mode_reglage_PP = 0, [
        "***INFOS DONNEES -CONFIG DE LA MACHINE-***", e$
        "fmaxi: ", *fmaxi, e$
        "fmini: ", *fmini, e$
        "smachine: ", s_nom_machine_entete, e$
        "spalette: ", spalette, e$
        "type_composant ", *type_composant, e$
        "INFOS CONFIG GROUPE MACHINE : diviseur +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9: : ", *diviseur, e$
        "sens de l'axe rotatif 0=trigo 1=horaire: ", *sens_A_B, e$
        "nbr_outil: ", *nbr_outil, e$
        "s_axe_rot_label NOM: ", s_axe_rot_label, e$
        ]
#endregion

#region pparameter_ lecture parametres d'OP	
pparameter$
    #rd_params is used to call pparameter postblock and read the parameters of the operation specified in rd_param_op_no
    if affiche_prmcodes = 0, "-->pparameter DONNEES OPERATIONS ", ~prmcode$, "=", ~sparameter$, e$        # pour afficher tous les parametres

    #if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$
    #if prmcode$ = 18458, "nombre de caracteres de commentaire",  sparameter$, e$
    #if prmcode$ = 19958, *prmcode$, "type de composant", "=", sparameter$, e$  	# type de composant 5 = axe rotatif
    #if prmcode$ = 17399, *prmcode$, "AXE DE L'AXE ROTATIF", "=", sparameter$, e$   # AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17402, *prmcode$, "sens de laxe", "=", sparameter$, e$       	# sens de l'axe rotatif 0=trigo 1=horaire
    #if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$         	# Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$
    #if prmcode$ = 17201, *prmcode$, "nom de l'element =", sparameter$, e$
	
	if prmcode$ = 10030, F_USI_prmcode = rpar(sparameter$, 1)
	if prmcode$ = 10031, F_plongee = rpar(sparameter$, 1) 
	if prmcode$ = 12068, surep_Z_surf_2D  = rpar(sparameter$, 1) 
	if prmcode$ = 15140, F_retract = rpar(sparameter$, 1)
	if prmcode$ = 12147, tolerance_usinage_5x = rpar(sparameter$, 1)	# Tolérance TOTALE 5X 
	if prmcode$ = 12718, F_G1_ugv_2D   = rpar(sparameter$, 1)
    if prmcode$ = 12194, pas_filetage = rpar(sparameter$, 1)   	# "valeur du pas du filetage A  la fraise"
	if prmcode$ = 12662, F_G1_ugv_3D   = rpar(sparameter$, 1)
	if prmcode$ = 12593, tolerance_usinage_3D = rpar(sparameter$, 1)	# Tolérance TOTALE 3D 
	if prmcode$ = 12553, tolerance_usinage_2D = rpar(sparameter$, 1) 	# Tolérance TOTALE 2D 
	if prmcode$ = 12053, tolerance_usinage_REEL = rpar(sparameter$, 1) 	# Tolérance REEL USINAGE xx AVEC LE FILTRAGE
	if prmcode$ = 15136, tolerance_usinage_max_pcent = rpar(sparameter$, 1)	# Tolérance REEL USINAGE xx AVEC LE FILTRAGE % MAX 
	if prmcode$ = 12628, hs_surf_style = rpar(sparameter$, 1)  	# type d'usinage de surface UGV 
    if prmcode$ = 15163, Val_origine_Z = rpar(sparameter$, 1)   # "valeur de l'origine MC en Z"
    if prmcode$ = 15164, Val_origine_Y = rpar(sparameter$, 1)   # "valeur de l'origine MC en Y"
    if prmcode$ = 15165, Val_origine_X = rpar(sparameter$, 1)   # "valeur de l'origine MC en X"
	if prmcode$ = 15166, workofs_ = rpar(sparameter$, 1)    	# 15166=Val origine de base 
																# 15181=Val Numéro de l'origine actif
																# 15333=Val départ incrément, op transformation 
	if prmcode$ = 15334, workofs_dec = rpar(sparameter$, 1)		# 15334=Val incrément, op transformation 	
    if prmcode$ = 15240, op_number = rparsngl(sparameter$, 1)	# Numéro OP MC réelle
	#if prmcode$ = 15346, Type_Comp_OP = rpar(sparameter$, 1)   # Type de compensation outil par OP / 0=ORDI 1=ARMOIRE 2=USURE 3=USURE inverse 4=SANS
	if prmcode$ = 15902, F_G1_rot_5x = rpar(sparameter$, 1) 
	if prmcode$ = 20002, smanu = sparameter$
    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)  		# lecture des parametres d'outi
    if prmcode$ = 20007, paramT20 = rpar(sparameter$, 11)   	# lie les param. avec l'Epaisseur  
    if prmcode$ = 20011, sinfo_origine = sparameter$    		
    if prmcode$ = 20014, snom_RUD = sparameter$
	if prmcode$ = 20018, snomgroupe_op = ucase (sparameter$)    # Lecture du nom de groupe d'usinage
	if prmcode$ = 40270, F_micro_remontee = rpar(sparameter$, 1)#	        		
	if prmcode$ = 15071, usecanDRILL = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGE
	if prmcode$ = 15072, usecanPECK = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGE/deb
    if prmcode$ = 15073, usecanCHIP = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGES/brise copeaux
	if prmcode$ = 15074, perc_1er_perc_pour_C_ou_mm = rpar(sparameter$, 1)	# CHOIX DU MODE - Valeur de la 1ère plongée en % ou MM (& décomposé) 
	if prmcode$ = 15075, perc_Val_pour_Cent_mm = rpar(sparameter$, 1)		# VALEUR de la 1ère plongée en % ou MM (& décomposé) 	
	if prmcode$ = 15076, perc_AVANCE_pour_Cent_mm = rpar(sparameter$, 1)	# VALEUR de l'avance 1ère plongée en % ou MM (& décomposé) 
	
	if opcode$ <> 19, result = fprm (1)  # pour surfacage
    if opcode$ = 19, result = fprm (2)   # pour 2D 3D
    
#endregion

#region chemin_prog
# ***************Pour tiliser le chemin du programme en entete************
fmt 1 nom_repert  
fmt 1 numchemin
numchemin : 0
schemincn : ""
sqchemin : ""
scheminpc : ""

sslach : ""      #"\" asci
sslachasci : ""  #"\" asci 92
sfraisagecoupe : ""
sfraisagecoupe2 : ""
sdiverscoupe : ""
scoupe2 : ""
scoupe3 : ""
snom_rep : ""
sfraisage   : "FRAISAGE"  #25 fin A  25 caract.
sdivers     : "DIVERS"
fmt 7 posisfraisage
fmt 7 posisdivers
fmt 7 posislach
fmt 7 posislach2
fmt 7 nbrcaracte    	# nbr de caracteres
fmt 7 long2

pchemin     #pour afficher ";$PATH=/_N_WKS_DIR/_N_SNECMA_0013_2_WPD" avec le nom du rEpA¨rtoire client
    scheminpc = spathnc$ #chemin du prog sur ce PC
    #   *scheminpc, e$
    sslachasci = no2asc(92)
    nbrcaracte = strlen (scheminpc)
    posisdivers = strstr(sdivers, scheminpc)
    long2 = nbrcaracte - posisdivers
    if posisdivers > 0 & long2 > 9,     # pour les clients "dans divers"
        [
        sdiverscoupe = brksps (posisdivers, scheminpc)
        posislach = 8
        scoupe2 = brksps (posislach, sdiverscoupe)
        posislach = strstr(sslachasci, scoupe2)
        scoupe3 = brksps (posislach, scoupe2)
        snom_rep = scoupe2
        ]
    else,
        [
    posisfraisage = strstr(sfraisage, scheminpc)
    posisfraisage = posisfraisage + 9
    #if nom_repert = 0, posisfraisage = posisfraisage + 25  
    sfraisagecoupe = brksps (posisfraisage, scheminpc)  #end_str_ix+26      end_str_ix+1
    long2 = strlen (sfraisagecoupe)
    sfraisagecoupe2 = sfraisagecoupe
    scoupe2 = brksps (long2, sfraisagecoupe2)
    scoupe3 = sfraisagecoupe2
    snom_rep = scoupe3
        ]
    if nom_repert = 1, schemincn = snom_rep + stiretbasasc + snouvnom    
    if nom_repert = 0, schemincn = stiretbasasc + snouvnom           

#   **************************
    #brksps : coupe la "string" initiale en 2
    # posipoint : 6
    # string1 "O1235.txt
    #ex. string2 = brksps (posipoint, string1)
    #   string1 = O1235     string2 = txt

# Pour changer le tiret "-" du NCI en tiret-bas "_"
sprog_name : ""
stiretasc : ""  	#"-" asci
stiretbasasc : ""   #"_" asci
stiret : ""         #"-"
stiretbas : "_"     #"_"
snccoupe : ""       # REsultat
snccoupeap : ""     # REsultat aprEs le tiret
snouvnom : ""       # nouveau nom aprEs modifs
snccoupe2 : ""
snamenci2 : ""

fmt 7 positiret
fmt 7 positiret2
fmt 7 nbrcaract     # nbr de caracteres
fmt 7 nbrcaractap   # nbr de caracteres aprEs

p_modif_tiret
    # string1 "O1235.txt
    #ex. string2 = brksps (posipoint, string1)
    #   string1 = O1235     string2 = txt
    stiretasc = no2asc(45)
    stiretbasasc = no2asc(95)
    nbrcaract = strlen (snamenci$)
    sprog_name = snamenci$
    snamenci2 = snamenci$
    positiret = strstr(stiretasc, sprog_name)
    snccoupe = brksps (positiret, sprog_name)   #(st_str_ix-1, sprog_name)
    nbrcaractap =  nbrcaract - positiret
    snccoupeap = brksps (positiret+1, snamenci2)    #st_str_ix-nbrcaractap
    positiret2 = strstr(stiretasc, snccoupeap)
    if positiret2 > 0, snccoupe2 = brksps (positiret2, snccoupeap)
    if positiret2 > 0, snccoupe2 = brksps (2, snccoupe2)
    if positiret > 0,
        [
         snouvnom = sprog_name + stiretbas + snccoupeap + stiretbas + snccoupe2     
        ]
    else, snouvnom = sprog_name + snccoupeap
    snouvnom = ucase (snouvnom)
#endregion

#region entete_prog
# **************************** Affichage des commentaires de dEbut d'OP en entete Prog.
stextentete : ""
stextecoupe : ""

svirgule : ","

#strings palpages
#s_Client
s_Piece : ""
s_Numplan : ""
s_indice : ""

sposiNomprog : "/PROGRAMMEUR/"
sposiClient : "/CLIENT/"
sposiPiece : "/NOM PIECE/"
sposiNumplan : "/NUM PLAN/"
sposiIndiceplan : "/INDICE/"
#Textes origines
sposiX  : "/X/"
sposiY  : "/Y/"
sposiZ  : "/Z/"
#Texte Orientation
sposiOrient : "/ORIENTATION/"
#Texte Divers
sposInfos : "/INFO/"
#sposivirgule : ""    # la virgule indique le saut A  la ligne
sSlash : "/"   

fmt 7 posiNomprog
fmt 7 posiClient
fmt 7 posiNomPiece
fmt 7 posiNumplan
fmt 7 posiIndiceplan
fmt 7 posiX
fmt 7 posiY
fmt 7 posiZ
fmt 7 posiOrientation
fmt 7 posiInfo
fmt 7 posivirgule
fmt 7 posicoupe
fmt 7 posiSlash 
fmt 7 long_TEXTE

ptextentete

    stextentete = scomm$
    long_TEXTE = strlen(stextentete)    
    posiNomprog = strstr(sposiNomprog, stextentete)
    posiClient = strstr(sposiClient, stextentete)
    posiNomPiece = strstr(sposiPiece, stextentete)
    posiNumplan = strstr(sposiNumplan, stextentete)
    posiIndiceplan = strstr(sposiIndiceplan, stextentete)
    posiX = strstr(sposiX, stextentete)
    posiY = strstr(sposiY, stextentete)
    posiZ = strstr(sposiZ, stextentete)
    posiOrientation = strstr(sposiOrient, stextentete)
    posiInfo = strstr(sposInfos, stextentete)
    posivirgule = strstr(svirgule, stextentete)
    #posivirgule = strstr(svirgule, stextentete)
    posiSlash = strstr(sSlash, stextentete) 

    longTexte = 1           
        if posiNomprog <>0,
            [
            posicoupe = posiNomprog+13
            pcoupetexte
            n$, " ; PAR:", stextecoupe, e$
            ]
        if posiClient >0,
            [
            posicoupe = posiClient+8
            pcoupetexte
            n$, " ; CLIENT:", stextecoupe, e$
            ]
        if posiNomPiece >0,
            [
            posicoupe = posiNomPiece+11
            pcoupetexte
            n$, " ; PIECE:", stextecoupe, e$
            s_Piece = stextecoupe
            ]
        if posiNumplan >0,
            [
            posicoupe = posiNumplan+10
            pcoupetexte
            n$, " ; PLAN:",stextecoupe, e$
            s_Numplan = stextecoupe
            ]
        if posiIndiceplan >0,
            [
            posicoupe = posiIndiceplan+8
            pcoupetexte
            n$, " ; INDICE:",stextecoupe, e$
            s_indice = stextecoupe
            ]
        if posiX >0,
            [
            posicoupe = posiX+3
            pcoupetexte
            n$, " ; ORIGINE:", e$, n$, " ; X:", stextecoupe, e$
            ]
        if posiY >0,
            [
            posicoupe = posiY+3
            pcoupetexte
            n$, " ; Y:", stextecoupe, e$
            ]
        if posiZ >0,
            [
            posicoupe = posiZ+3
            pcoupetexte
            n$, " ; Z:",stextecoupe, e$
            ]
        if posiOrientation >0,
            [
            posicoupe = posiOrientation+13
            pcoupetexte
            n$, " ; A: 0", e$, n$, " ; C: 0", e$
            n$, " ; ORIENTATION PIECE:",e$, n$, " ;", stextecoupe, e$
            ]
        if posiInfo >0,
            [
            posicoupe = posiInfo+6
            pcoupetexte
            n$, " ; *****************************",e$
            n$, " ;", stextecoupe, e$
            ]
        #if posivirgule > 0,
            #[
            #posicoupe = posivirgule+1
            #pcoupetexte
            #n$, " ;",stextecoupe, e$
            #]
        if posiSlash = 0 & long_TEXTE > 0,
            [
            n$, " ;", scomm$, e$
            ]

pcoupetexte #coupe le texte
            stextecoupe = brksps(posicoupe, stextentete)
#endregion

#region modif_nom_fichiers
# ------------------------ RENOMMER LE FICHIER NC EN FONCTION DU NUMERO DE PROGRAMME -------------------------
snom_nc : ""        # STRING de stockage du non du NC complet avec chemin et extension style c:\cfao\prog-cn\TOTO.NC
snom_numero : ""    # STRING de stockage du non du NC sous forme O0123.nc avec chemin et extesion style c:\cfao\prog-cn\ous forme O0123.NC
spoint : ""      	# STRING du POINT pour l'extenssion (.NC)
#stringo        	# STRING du O pour le non (O0123) en nom du Numero PRG
#seditor : "C:\WINNT\system32\notepad.exe" 											# non de l'editeur pour les prog en nom du Numero PRG (avec chemin complet si pas dans Windows)
#seditor : "C:\WINDOWS\notepad.exe"    												# XP non de l'editeur pour les prog en nom du Numero PRG (avec chemin complet si pas dans Windows)
#seditor : "C:\Program Files\Microsoft Office\Office\WINWORD.EXE"  					# ouvrir avec WORD
#seditor : "C:\Mcam91\Common\Editors\Cedit\CIMCOEdit.exe"  							# ouvrir avec CIMCOEDIT (ne fonctionne pas)
#seditor : "C:\mcamx\common\editors\mastercam\MCXStart.exe"    						# ouvrir avec Editeur MCX
seditor  : "C:\Program Files\Mastercam 2022\Mastercam\Extensions\CodeExpert.exe"    # NOUVEL EDITEUR MC"

sdebut : "F"
smachine : "_HS"
snouv_nom : ""
schange_nom_fichier : "" #nouveau nom uniquement, sans le chemin
snomprogentete : ""
#sfraisage_ "\FRAISAGE\"
#stous_clients "\TOUS_CLIENTS\"
sext : ""    		# extention
spoint2 : "."      	# STRING du POINT pour l'extenssion (.NC) UNIQUEMENT pour les entEtes prog.
fmt 7 posipoint
#fmt 7 posiFraisage_
#fmt 7 posiTous_clients
sfileops : ""       # string du nom du fichier OPS
sops : ".ops"       # extention des fichier OPS
spathnc_ : "C:\MASTERCAM FICAM\ISO\" #chemin pour les fichiers ISO

sdebut2 : "PR"    
snom_entete : ""     
#sprogno = progno$

pnom_nc     # GEnEration des noms du fichier NC
	#snom_fichier = sdebut+snamenci+smachine+spoint+sextnc
	snom_nc = spathnc_+snamenc$+spoint+sextnc$             #spathnc$ Fichier NC en cours de creation sous forme toto.nc
	#snom_numero = no2str (progno)
	snouv_nom = spathnc_+sdebut2+snamenci$+spoint+sextnc$  #spathnc$ nouveau non de fichier NC sous forme F15662-A-2-HE.H
	schange_nom_fichier = snouv_nom
	snom_entete = sdebut+smcname$+smachine+spoint+sextnc$ #0300 nouveau non de fichier NC sous forme F15662-A-2-HE.H  AFFICHE EN COMMENTAIRE
	
	#smcpath$ = ucase (smcpath$)    #retourne le chemin du fichier CN
	#smcname$ = ucase (smcname$)    #Nom du fichier NC
	#smcext$ = ucase (smcext$)      #retourne l'extention du pst
	#snamepst$ = ucase (snamepst$)  #retourne le nom du pst

ptest_nom   # test du non du fichier NC si O0123.NC
	#progno2 = progno
	if fexist (snouv_nom), pchange_nom
	    #[
	    #Q10
	 #pchange_nom   #ex #snom_numero
	#if remplace = 0, pchange_nom
	#if remplace = 1, result = remove (snouv_nom)
	    #pchange_nom
	    #snouv_nom = schange_nom_fichier
	    #]
	pmodif_nom_entete

pchange_nom     # changer le numEro de prog si fichier exite dEja
	while fexist (snouv_nom),       #(snom_numero)
	    [
	    q10
	    #snom_numero = no2str (progno)
	    #snouv_nom = spathnc+sdebut+snouv_nom+smachine+spoint+sextnc
	snouv_nom = schange_nom_fichier
	    ]
	pmodif_nom_entete

pmodif_nom_entete   #modif nom au dEbut et fin de l'ISO
	snomprogentete = snouv_nom
	
	#posiTous_clients = strstr(stous_clients, snomprogentete)
	#posiTous_clients = posiTous_clients + 14
	
	snomprogentete = brksps(25,snomprogentete)
	
	#if posiTous_clients > 15,
	    #[
	    #snomprogentete = brksps(posiTous_clients,snomprogentete)
	    #]
	#else,
	    #[
	    #posiFraisage_ = strstr(sfraisage_, snomprogentete)
	    #posiFraisage_ = posiFraisage_ + 10
	    #snomprogentete = brksps(posiFraisage_,snomprogentete)
	    #]
	#enlever l'extention de fichier ex: .H
	#ex. string2 = brksps (posipoint, string1)
	#   string1 = O1235     string2 = txt
	posipoint = strstr(spoint2, snomprogentete)
	sext = brksps (posipoint, snomprogentete)
#endregion

[ENDBIN]

#region TEXTES_XML
[CTRL_TEXT_XML_BEGIN]  # All post text edits must be made through Control Definition Manager
<?xml version="1.0" encoding="UTF-8"?>
<mp_xml_post_text xml:space="preserve">
	<control>
		<control_label>CTRL_MILL|DEFAULT</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>4 axes utilis. Z sécu OP:1=axe A 0=axe B</text>
				<value>0</value>
			</misc_2>
			<misc_3>
				<text>Val. angulaire index. broche (mortaisage)</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>Bris outil 1=AXIAL-FORET 2=FRAISE 3=??</text>
			</misc_5>
			<misc_6>
				<text>Test_Bris_Out =1 (en FIN d OPERATION)</text>
			</misc_6>
			<misc_7>
				<text>Blocage déblocage AXES ROT. 1=OUI 0=NON</text>
				<value>1</value>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>Force Cycle832 1=OUI 0=NON</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>Cycle832 à 3 valeurs--&gt; Tol: mm</text>
			</misc_7>
			<misc_8>
				<text>Cycle832 à 3 valeurs--&gt; Tol: DEG</text>
			</misc_8>
			<misc_9>
				<text>Cycle832 -force- 1=Finit 2=Semi-Finit 3=EB.</text>
			</misc_9>
			<misc_10>
				<text>Cycle832 si VAL.inf Fini.025 demi/f.1 EB. &gt;.1</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<description>
				<text>PERCAGE LAMAGE G82</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond en S.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>DEBOURRAGE G83</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo. dEbut et fond &gt; 0= S. &lt; 0=tr[DTS]</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<retract>
				<text>Garde (R)</text>
			</retract>
			<first_peck>
				<text>Valeur profond. FDPR</text>
			</first_peck>
			<subsequent_peck>
				<text>prof. suiv. &gt; 0=VAL mm/ &lt; 0= % [DAM]</text>
				<value>0</value>
			</subsequent_peck>
			<peck_clearance>
				<text>Val retour (DECOMP. uniquement)</text>
				<value>0.5</value>
			</peck_clearance>
			<retract_amount>
				<text>Prof. mini si 2ème plongée &lt; 0 [V1]</text>
			</retract_amount>
			<shift>
				<text>Tempo-scnds au début [DTS]</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>BRISE COPEAUX G83</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo-scnds Prof. finale [DTD]</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<retract>
				<text>Garde (R)</text>
			</retract>
			<first_peck>
				<text>Premiere prof [FDPR]</text>
			</first_peck>
			<subsequent_peck>
				<text>prof. suiv. &gt; 0=VAL/ &lt; 0=% [DAM]0=sans</text>
				<value>0</value>
			</subsequent_peck>
			<peck_clearance>
				<text>Tempo-scnds next@Prof [DTB]</text>
			</peck_clearance>
			<retract_amount>
				<text>Prof. mini si 2ème plongée &lt; 0 [V1]</text>
			</retract_amount>
			<shift>
				<text>Tempo-scnds au début [DTS]</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>TARAUDAGE 84: brise C.: débour.</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo en mode brise copeaux</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Brise C. ou débourrage si &gt; 0 </text>
				<value>0</value>
			</first_peck>
			<subsequent_peck>
				<text>Pas spEcial(si &lt;&gt;0)</text>
				<value>0</value>
			</subsequent_peck>
			<peck_clearance>
				<text>Valeur(inc) remontée brise C. si &gt; 0</text>
				<value>0</value>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>Angle de broche en deg.</text>
				<value>0</value>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>ALESAGE - ALESOIR G85</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo DTB</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Vit avance ret RFF</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>ALESAGE - INDEXE G86</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo en S.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Sens rot 3/4 SDIR 3</text>
			</first_peck>
			<subsequent_peck>
				<text>Retrait X en G91 -.2</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Retrait Y en G91 0</text>
			</peck_clearance>
			<retract_amount>
				<text>Retrait Z en G91 0</text>
			</retract_amount>
			<shift>
				<text>Angle STOP broche 0</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>ALESAGE G87 (fin Z M5 M0)</text>
			</description>
			<feed_rate>
				<text>Avances en S.</text>
			</feed_rate>
			<dwell>
				<text>""</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Sens rot 3/4 SDIR</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc1>
		<misc2>
			<description>
				<text>ALESAGE G88 (fin Z tempo M5 M0)</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo DTB en S.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Sens rot 3 ou 4 SDIR</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc2>
		<drill_cycle_9>
			<description>
				<text>REf. Inter Exter rectangle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Long. en X</text>
			</first_peck>
			<subsequent_peck>
				<text>Larg. en Y</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_9>
		<drill_cycle_10>
			<description>
				<text>REf. Inter Exter Cercle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Diametre nominal</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_10>
		<drill_cycle_11>
			<description>
				<text>REf. Coin EXTER</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_11>
		<drill_cycle_12>
			<description>
				<text>REf. Coin INTER</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_12>
		<drill_cycle_13>
			<description>
				<text>REf. en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Z rEf. palpage</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_13>
		<drill_cycle_14>
			<description>
				<text>REf. PALPAGE en X</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>VERS X+=1/X-=0</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_14>
		<drill_cycle_15>
			<description>
				<text>REf. PALPAGE en Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>VERS Y+=1/Y-=0</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_15>
		<drill_cycle_17>
			<description>
				<text>Ref. ORIENTATION FACE en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>dist. relative en X+</text>
			</first_peck>
			<subsequent_peck>
				<text>en Y+ au 1er pt</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_17>
		<drill_cycle_18>
			<description>
				<text>Ref. ORIENT. ANGLE FACE en X ou Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>VERS X=1/Y=2</text>
			</first_peck>
			<subsequent_peck>
				<text>dist. relative pt1-pt2</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_18>
		<drill_cycle_19>
			<description>
				<text>Brosse Ebavurage trous</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>Nombre de va et vient</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_19>
		<drill_cycle_20>
			<description>
				<text>Percage tres profond</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MATIERE</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 1</text>
			</description>
			<parameter_1>
				<text>1-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
				<value>-1</value>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 2</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>2-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>		
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
				<value>-1</value>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
			<parameter_7>
				<text>Prof. mini si 2ème plongée &lt; 0</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>	
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 3</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>3-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
				<value>-1</value>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
			<parameter_7>
				<text>Prof. mini si 2ème plongée &lt; 0</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>REf. Int./Ext. Rectangle</text>
			</description>
			<parameter_1>
				<text>REf. Inter rectangle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>REf. Exter rectangle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>REf. Int./Ext. Cercle</text>
			</description>
			<parameter_1>
				<text>REf. Inter Cercle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>REf. Exter Cercle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>REf. Ext. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>long. Maxi 2EME PT X en +</text>
			</parameter_4>
			<parameter_5>
				<text>long. Maxi 4EME PT Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>ANGLE ARETE ABSCISSE</text>
			</parameter_6>
			<parameter_7>
				<text>ANGLE ARETE G91 1ERE</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>REf. Int. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>long. Maxi 2EME PT X en +</text>
			</parameter_4>
			<parameter_5>
				<text>long. Maxi 4EME PT Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>ANGLE ARETE ABSCISSE</text>
			</parameter_6>
			<parameter_7>
				<text>ANGLE ARETE G91 1ERE</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>REf. en Z</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>REf. FACE en X</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>REf. FACE en Y</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 18</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Percage tres profond</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>PERCAGE/LAMAGE G82 Tempo</text>
			</simple_drill>
			<peck_drill>
				<text>DEBOURRAGE G83</text>
			</peck_drill>
			<chip_break>
				<text>BRISE COPEAUX G83</text>
			</chip_break>
			<tapping>
				<text>TARAUDAGE G84</text>
			</tapping>
			<boring_1>
				<text>ALESAGE G85 (AlEsoir)</text>
			</boring_1>
			<boring_2>
				<text>ALESAGE G86 (Indexation)</text>
			</boring_2>
			<misc_drill_1>
				<text>ALASAGE G87 (Stop)</text>
			</misc_drill_1>
			<misc_drill_2>
				<text>ALESAGE G88 (Stop et tempo)</text>
			</misc_drill_2>
			<custom_drill_9>
				<text>Ref. Inter Exter. Rectangle</text>
			<resource>IMAGES PPs\Poche rectangul INTER-EXTER_1.bmp</resource>
			</custom_drill_9>
			<custom_drill_10>
				<text>Ref. Inter Exter. Cercle</text>
			<resource>IMAGES PPs\CERCLE INTER-EXTER_1.bmp</resource>
			</custom_drill_10>
			<custom_drill_11>
				<text>Ref. Exter Coin</text>
			<resource>IMAGES PPs\COIN EXTER_1.bmp</resource>
			</custom_drill_11>
			<custom_drill_12>
				<text>Ref. Inter Coin</text>
			<resource>IMAGES PPs\COIN INTER_1.bmp</resource>
			</custom_drill_12>
			<custom_drill_13>
				<text>Ref. EN Z</text>
			<resource>IMAGES PPs\FACE EN -Z-_1.bmp</resource>
			</custom_drill_13>
			<custom_drill_14>
				<text>Ref. FACE EN X</text>
			<resource>IMAGES PPs\FACE EN -X-_1.bmp</resource>
			</custom_drill_14>
			<custom_drill_15>
				<text>Ref. FACE EN Y</text>
			<resource>IMAGES PPs\FACE EN -Y-_1.bmp</resource>
			</custom_drill_15>
			<custom_drill_16>
				<text>Ref. RAINURE LANGUETTE</text>
			<resource>IMAGES PPs\RAINURE_1.bmp</resource>
			</custom_drill_16>
			<custom_drill_17>
				<text>Ref. ORIENTATION FACE en Z</text>
			<resource>IMAGES PPs\PLAN EN -Z-_1.bmp</resource>
			</custom_drill_17>
			<custom_drill_18>
				<text>Ref. ORIENT. ANGLE FACE en X ou Y</text>
			<resource>IMAGES PPs\FACE EN -X-_1.bmp</resource>
			</custom_drill_18>
			<custom_drill_19>
				<text>Brosse Ebavurage</text>
				<resource>IMAGES PPs\Brosse Ebavurage.bmp</resource>
			</custom_drill_19>
			<custom_drill_20>
				<text>Percage trEs profond</text>
				<resource>IMAGES PPs\PERCAGE TRES PROFOND_1.bmp</resource>
			</custom_drill_20>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>Texte 1</text>
			</canned_text_1>
			<canned_text_2>
				<text>Texte 2</text>
			</canned_text_2>
			<canned_text_3>
				<text>Texte 3</text>
			</canned_text_3>
			<canned_text_4>
				<text>Texte 4</text>
			</canned_text_4>
			<canned_text_5>
				<text>Texte 5</text>
			</canned_text_5>
			<canned_text_6>
				<text>Texte 6</text>
			</canned_text_6>
			<canned_text_7>
				<text>Texte 7</text>
			</canned_text_7>
			<canned_text_8>
				<text>Texte 8</text>
			</canned_text_8>
			<canned_text_9>
				<text>Texte 9</text>
			</canned_text_9>
			<canned_text_10>
				<text>Texte 10</text>
			</canned_text_10>
		</canned_text>
	</control>
<control>
		<control_label>CTRL_MILL|MILL_ST_SIEMENS_8XX-ROTATION-A-OU-B</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>4 axes utilis. Z sécu OP:1=axe A 0=axe B</text>
				<value>0</value>
			</misc_2>
			<misc_3>
				<text>Val. angulaire index. broche (mortaisage)</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>Bris outil 1=AXIAL-FORET 2=FRAISE 3=??</text>
			</misc_5>
			<misc_6>
				<text>Test_Bris_Out =1 (en FIN d OPERATION)</text>
			</misc_6>
			<misc_7>
				<text>Blocage déblocage AXES ROT. 1=OUI 0=NON</text>
				<value>1</value>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>Force Cycle832 1=OUI 0=NON</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>Cycle832 à 3 valeurs--&gt; Tol: mm</text>
			</misc_7>
			<misc_8>
				<text>Cycle832 à 3 valeurs--&gt; Tol: DEG</text>
			</misc_8>
			<misc_9>
				<text>Cycle832 -force- 1=Finit 2=Semi-Finit 3=EB.</text>
			</misc_9>
			<misc_10>
				<text>Cycle832 si VAL.inf Fini.025 demi/f.1 EB. &gt;.1</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<description>
				<text>PERCAGE LAMAGE G82</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond en S.</text>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>DEBOURRAGE G83</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo. dEbut et fond &gt; 0= S. &lt; 0=tr[DTS]</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<retract>
				<text>Garde (R)</text>
			</retract>
			<first_peck>
				<text>Valeur profond. FDPR</text>
			</first_peck>
			<subsequent_peck>
				<text>prof. suiv. &gt; 0=VAL mm/ &lt; 0= % [DAM]</text>
				<value>0</value>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>Prof. mini si 2ème plongée &lt; 0 [V1]</text>
			</retract_amount>
			<shift>
				<text>Tempo-scnds au début [DTS]</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>BRISE COPEAUX G83</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo-scnds au fond &gt; 0= S. &lt; 0=tr [DTD]</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Premiere prof [FDPR]</text>
			</first_peck>
			<subsequent_peck>
				<text>prof. suiv. &gt; 0=VAL mm/ &lt; 0= % [DAM]</text>
				<value>0</value>
			</subsequent_peck>
			<peck_clearance>
				<text>Tempo-scnds next@Prof [DTB]</text>
			</peck_clearance>
			<retract_amount>
				<text>Prof. mini si 2ème plongée &lt; 0 [V1]</text>
			</retract_amount>
			<shift>
				<text>Tempo-scnds au début [DTS]</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>TARAUDAGE 84: brise C.: débour.</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo en mode brise copeaux</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Brise C. ou débourrage si &gt; 0 </text>
				<value>0</value>
			</first_peck>
			<subsequent_peck>
				<text>Pas spEcial(si &lt;&gt;0)</text>
				<value>0</value>
			</subsequent_peck>
			<peck_clearance>
				<text>Valeur(inc) remontée brise C. si &gt; 0</text>
				<value>0</value>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>Angle de broche en deg.</text>
				<value>0</value>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>ALESAGE - ALESOIR G85</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo DTB</text>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Vit avance ret RFF</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>ALESAGE - INDEXE G86</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo en S.</text>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Sens rot 3/4 SDIR 3</text>
			</first_peck>
			<subsequent_peck>
				<text>Retrait X en G91 -.2</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Retrait Y en G91 0</text>
			</peck_clearance>
			<retract_amount>
				<text>Retrait Z en G91 0</text>
			</retract_amount>
			<shift>
				<text>Angle STOP broche 0</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>ALESAGE G87 (fin Z M5 M0)</text>
			</description>
			<feed_rate>
				<text>Avances en S.</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Sens rot 3/4 SDIR</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc1>
		<misc2>
			<description>
				<text>ALESAGE G88 (fin Z tempo M5 M0)</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo DTB en S.</text>
			</dwell>
			<clearance>
				<text>Plan Retrait RTP</text>
			</clearance>
			<retract>
				<text>Garde SDIS</text>
			</retract>
			<depth>
				<text>Profondeur DP</text>
			</depth>
			<first_peck>
				<text>Sens rot 3 ou 4 SDIR</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc2>
		<drill_cycle_9>
			<description>
				<text>REf. Inter Exter rectangle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Long. en X</text>
			</first_peck>
			<subsequent_peck>
				<text>Larg. en Y</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_9>
		<drill_cycle_10>
			<description>
				<text>REf. Inter Exter Cercle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Diametre nominal</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_10>
		<drill_cycle_11>
			<description>
				<text>REf. Coin EXTER</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_11>
		<drill_cycle_12>
			<description>
				<text>REf. Coin INTER</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_12>
		<drill_cycle_13>
			<description>
				<text>REf. en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Z rEf. palpage</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_13>
		<drill_cycle_14>
			<description>
				<text>REf. PALPAGE en X</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>VERS X+=1/X-=0</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_14>
		<drill_cycle_15>
			<description>
				<text>REf. PALPAGE en Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>VERS Y+=1/Y-=0</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_15>
		<drill_cycle_17>
			<description>
				<text>Ref. ORIENTATION FACE en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>dist. relative en X+</text>
			</first_peck>
			<subsequent_peck>
				<text>en Y+ au 1er pt</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_17>
		<drill_cycle_18>
			<description>
				<text>Ref. ORIENT. ANGLE FACE en X ou Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan SEcuritE</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>VERS X=1/Y=2</text>
			</first_peck>
			<subsequent_peck>
				<text>dist. relative pt1-pt2</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_18>
		<drill_cycle_19>
			<description>
				<text>Brosse Ebavurage trous</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>Nombre de va et vient</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_19>
		<drill_cycle_20>
			<description>
				<text>Percage tres profond</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MATIERE</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 1</text>
			</description>
			<parameter_1>
				<text>1-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
				<value>-1</value>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 2</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>2-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>		
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
				<value>-1</value>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>		
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 3</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>3-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
				<value>-1</value>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>REf. Int./Ext. Rectangle</text>
			</description>
			<parameter_1>
				<text>REf. Inter rectangle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>REf. Exter rectangle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>REf. Int./Ext. Cercle</text>
			</description>
			<parameter_1>
				<text>REf. Inter Cercle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>REf. Exter Cercle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>REf. Ext. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>long. Maxi 2EME PT X en +</text>
			</parameter_4>
			<parameter_5>
				<text>long. Maxi 4EME PT Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>ANGLE ARETE ABSCISSE</text>
			</parameter_6>
			<parameter_7>
				<text>ANGLE ARETE G91 1ERE</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>REf. Int. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>long. Maxi 2EME PT X en +</text>
			</parameter_4>
			<parameter_5>
				<text>long. Maxi 4EME PT Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>ANGLE ARETE ABSCISSE</text>
			</parameter_6>
			<parameter_7>
				<text>ANGLE ARETE G91 1ERE</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>REf. en Z</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>REf. FACE en X</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>REf. FACE en Y</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>tolErance MAXI</text>
			</parameter_8>
			<parameter_9>
				<text>tolErance MINI</text>
			</parameter_9>
			<parameter_10>
				<text>MESURE = 1</text>
			</parameter_10>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 18</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>ParamA¨tres de cycle spEcial 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Percage tres profond</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>PERCAGE/LAMAGE G82 Tempo</text>
			</simple_drill>
			<peck_drill>
				<text>DEBOURRAGE G83</text>
			</peck_drill>
			<chip_break>
				<text>BRISE COPEAUX G83</text>
			</chip_break>
			<tapping>
				<text>TARAUDAGE G84</text>
			</tapping>
			<boring_1>
				<text>ALESAGE G85 (AlEsoir)</text>
			</boring_1>
			<boring_2>
				<text>ALESAGE G86 (Indexation)</text>
			</boring_2>
			<misc_drill_1>
				<text>ALESAGE G87 (Stop)</text>
			</misc_drill_1>
			<misc_drill_2>
				<text>ALESAGE G88 (Stop et tempo)</text>
			</misc_drill_2>
			<custom_drill_9>
				<text>Ref. Inter Exter. Rectangle</text>
				<resource>IMAGES PPs\Poche rectangul INTER-EXTER_1.bmp</resource>
			</custom_drill_9>
			<custom_drill_10>
				<text>Ref. Inter Exter. Cercle</text>
				<resource>IMAGES PPs\CERCLE INTER-EXTER_1.bmp</resource>
			</custom_drill_10>
			<custom_drill_11>
				<text>Ref. Exter Coin</text>
				<resource>IMAGES PPs\COIN EXTER_1.bmp</resource>
			</custom_drill_11>
			<custom_drill_12>
				<text>Ref. Inter Coin</text>
				<resource>IMAGES PPs\COIN INTER_1.bmp</resource>
			</custom_drill_12>
			<custom_drill_13>
				<text>Ref. EN Z</text>
				<resource>IMAGES PPs\FACE EN -Z-_1.bmp</resource>
			</custom_drill_13>
			<custom_drill_14>
				<text>Ref. FACE EN X</text>
				<resource>IMAGES PPs\FACE EN -X-_1.bmp</resource>
			</custom_drill_14>
			<custom_drill_15>
				<text>Ref. FACE EN Y</text>
				<resource>IMAGES PPs\FACE EN -Y-_1.bmp</resource>
			</custom_drill_15>
			<custom_drill_16>
				<text>Ref. RAINURE LANGUETTE</text>
				<resource>IMAGES PPs\RAINURE_1.bmp</resource>
			</custom_drill_16>
			<custom_drill_17>
				<text>Ref. ORIENTATION FACE en Z</text>
				<resource>IMAGES PPs\PLAN EN -Z-_1.bmp</resource>
			</custom_drill_17>
			<custom_drill_18>
				<text>Ref. ORIENT. ANGLE FACE en X ou Y</text>
				<resource>IMAGES PPs\FACE EN -X-_1.bmp</resource>
			</custom_drill_18>
			<custom_drill_19>
				<text>Brosse Ebavurage</text>
				<resource>IMAGES PPs\Brosse Ebavurage.bmp</resource>
			</custom_drill_19>
			<custom_drill_20>
				<text>Percage trEs profond</text>
				<resource>IMAGES PPs\PERCAGE TRES PROFOND_1.bmp</resource>
			</custom_drill_20>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>Texte 1</text>
			</canned_text_1>
			<canned_text_2>
				<text>Texte 2</text>
			</canned_text_2>
			<canned_text_3>
				<text>Texte 3</text>
			</canned_text_3>
			<canned_text_4>
				<text>Texte 4</text>
			</canned_text_4>
			<canned_text_5>
				<text>Texte 5</text>
			</canned_text_5>
			<canned_text_6>
				<text>Texte 6</text>
			</canned_text_6>
			<canned_text_7>
				<text>Texte 7</text>
			</canned_text_7>
			<canned_text_8>
				<text>Texte 8</text>
			</canned_text_8>
			<canned_text_9>
				<text>Texte 9</text>
			</canned_text_9>
			<canned_text_10>
				<text>Texte 10</text>
			</canned_text_10>
		</canned_text>
	</control>
</mp_xml_post_text>
[CTRL_TEXT_XML_END]
#endregion
