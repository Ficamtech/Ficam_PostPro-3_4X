[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V27.00 P0 E1 W27.00 T1722257585 M27.00 I0 O0
scustpost_revision    : "25.2407" #:= Revision number for use by Resellers or customers.
# ----------------------------------------
# premier depot
# - REALISE PAR                 --> FS
# ---------------------------------------- config PP
# - TYPE PP                     --> FRAISAGE
# - NOMBRE d'AXES               --> 4
# - AXE                         --> A ou B
# - TYPE DE LANGAGE             --> FANUC
#            VERSION            --> 18 ...
# ---------------------------------------- client / infos machine
# - CLIENT                      -->
# - NON MACHINE                 -->
# - AXE ROTATIF(1)              --> A/B
# ----------------------------------------
#
# Variables d'ajustement des temps d'usinage
# 	- Valeurs fixes en secondes, après être remonté au point haut ***changement UNIQUEMENT***
#	correction de la valeur définie dans "l'armoire" 1 Seconde par défaut 
Temps_chang_outil 	: 5		# secondes en +- par outil
# A configurer par type d'opération 
#	- en utilisant un FACTEUR 1=1 1.1= * 1.1 le temps de ces types d'opérations
coefficient_G0		: 10	# Facteur de correction des rapides en --> accélération & décélération 
							# exprimé en 1/10 de secondes d'accélération/décélération par "G0"
							# obligatoirement > 0 --> 1 mini

#region possibilites_PP
# ---------------------------------------- infos complEmentaires / config PP
# - RESTRICTIONS                --> OUI - numéro de clé/en durée/version MC
# - ENTETEs
#                   ANCIENNE    --> OUI
#                   NOUVELLE    --> OUI
#         OP MC COMMENTAIRE     --> OUI
# - LECTURE INFOS ARMOIRE       --> OUI ou NON --> Suivant config choisie dans le PP
# - LECTURE INFOS MACHINE       --> OUI ou NON --> Suivant config choisie dans le PP
# - ORIGINES                    --> OUI
# - INSPECTION D'OUTIL          --> OUI
# - ARROSAGES VX                --> NON
# - AVANCES EN VARIABLES        --> OUI
# - OUTILS EN VARIABLES         --> OUI
# - APPEL OUTILS SUIVANT EN NOM --> OUI
# - CYCLES PALPAGES             --> OUI / OPTIONNEL
# - SOUS-PROGRAMMES
#                       en Z    --> OUI
#                translation    --> OUI
#                   Rotation    --> OUI
#                     Miroir    --> OUI ?
# - SUBSTITUTION D'AXES         --> OUI
#		"			" PERCAGES	--> OUI
# - TEXTES AVANT/AVEC/APRES     --> NON / NON a completer
# ---------------------------------------- infos complEmentaires
# - SIMULATION ISO              --> NON
# - PERCAGES AVANCé             --> OUI
# - PERC. TRES PROFOND          --> OUI - M4,G1Z...,M3,M7...
# - PERCAGES "5 AXES" A ou B    --> OUI
#            TRANSITION SECU    --> OUI
# - MODIFICATION AUTO DU NOM    --> OUI - F12345.NC ou 12345-NH.NC ou F12345-NH.NC
# - OUVERTURE D'UN AUTRE EDITEUR--> OUI
# - AFFICHAGE DU TEMPS D'USINAGE
#                     PAR OUTIL --> OUI
#                        TOTAL  --> OUI
#                    TOTAL DLL  --> OUI
# - AJUSTEMENT DES TEMPS   		--> OUI	--> explications ci-dessous 
# - ARRET CONTROLE BRIS D'OUTIL --> OUI
# - CYCLE TEST BRIS D'OUTIL     --> OUI
# - NOMs PROGRAMMES/SP "O"-":"  --> OUI
# - OPTIMISATION AVANCES ARCS   --> NON/OUI MC
# - RENVOIE D'ANGLE             --> OUI
# - MORTAISAGE ANGULAIRE BROCHE --> NON --> A DEVELOPPER
# - ORIGINES EN ENTETE          --> OUI
#                       FICHIER	--> OUI
# - BLOCAGE-DEBLOCAGE axe A/B   --> OUI
# - GESTION DES PALETTES        --> OUI
# - Axes A/B en DEG/Mn          --> OUI
# - CYCLE D EBAVURAGE BROSSE	--> OUI
# - ORIGINE par TRANSFORMATION	--> OUI --> A DEVELOPPER
# - RENVOI D'ANGLE
#					FIXE MANUEL --> OUI
#				CIRCULAIRE AUTO --> OUI
# ---------------------------------------- INFOS
# mi1$ sans
# mi2$ utilisé pour FORCER le Z sécu de l'op si la config est remonter en Z HAUT 	
# mi3$ utilisé pour "Val. angulaire index. broche (mortaisage)
# mi4$ utilisé pour "
# mi5$ utilisé pour "Bris outil 1=AXIAL-FORET 2=FRAISE 3=??
# mi6$ utilisé pour "Test_Bris_Out =1 (en FIN d OPERATION)
# mi7$ utilisé pour Ecrire M10 M11 (blocage/dEblocage du diviseur)
# mi8$ utilisé pour Ecrire l'ORIGINE DE TRANSFORMATION 1=G54.. 2=G52xyz 3=G92xyz
#
# mr1$ 
# Workofs (n°de Décalage) de 54 a 59  (0 pour 54 1 pour 55 etc...) et 59.1 P1 P2 apres
# ecriture des parametres dans NCI et du fichier OPS (pour lire les infos de surep_XY_2D)
#
# lecture de la def armoire pour :
#   l'extension de l'iso
#   les arcs /CONFIGURATION FORCEE dans le PP
#   les commentaires
#   la preparation de l'outil suivant
# Lecture de la def machine pour :
#   Le nom de la machine
#   Le nombre d'axes rotatif (1 seul supporté)
#   Le sens de rotation de l'axe rotatif
#
# Affichages (à activer):
#   surepaisseurs OPs
#   type de compensations outils par OP
#
# AJUSTEMENT DES TEMPS   		
# 	Acces au client aux variables pour ajuster 
#	suivant des types d'opérations uniquement
# ----------------------------------------
#endregion

# ----------------------------------------
erreur_type_arcs	= 1				# message d'alerte si les ARCS sont mal configurés dans la DEF. ARMOIRE

# ----- dEgagements au changement d'outil, rotations d'axes et inspection de plaquettes
type_deg    		: 1     		# 1 = G28 G91 ... ; G90
                    				# 2 = G53 G90
                    				# 0 = G0 Z... ;  X... Y...    #VALEURS ABSOLU OPERATIONS MASTERCAM

S_macro_deg : "M130 (RET. PT CHANG. OUTIL)"                # NOM de la macro de dégagement si active
# configuration des dEgagements
# --------------------------------  0=SANS  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY  6=MACRO_CN
deg_debut   		: 1             # Degagement au debut du prog
deg_outil   		= 1             # Degagement au changement d'outil
deg_4_axes  		= 0             # Degagement au changement de position en 4 axes ET RENVOI D'ANGLE
                                    	# 0 = VALEURS MC DE L'OPERATION
deg_fin             : 3             # Degagement en fin de programme									
deg_inspection_plaq = 1             # Degagement l'outil lors de l'inspection de l'état de l'outil

deg_apres_outil     = 0             # >0 = Affichage des dégagements EGALEMENT apres l'appel de l'outil "sécurité" lors du démarrage à X outil
                                    # type = idem au "deg_outil"
deg_palette_deb_fin = 4             # dEgagements au debut et fin prog pour rotation des palettes
                                        # s'il y a un élément génant pour la rotation, ex: bloc du 4ème axe
# en 3 axes
degageX    : 0                      # Valeur de degagement en X pour l'appel d'outil
degageY    : 0                      # "    Y "
degageZ    : 0                      # "    Z "

# FIN
degageX_fin = 0						# Valeur de degagement en X UNIQUEMENT EN FIN DE PROGRAMME 
degageY_fin = 0  					# "    Y "
degageZ_fin = 0 					# "    Z "

# en 4 axes    --> ENTRE 2 opérations        SI "deg_4_axes" = 0 valeur X/Y & Z = à la valeur SECURITE de l'opération MASTERCAM
# et TETE A RENVOI
degageX4   = 0                      # Valeur de degagement en X avant rotation
degageY4   = 0                      # "    Y "
degageZ4   = 0                      # "    Z "

# dEgagements palettes              # si palettes actives "dEgagements au debut et fin prog pour rotation des palettes
degageX_pal = 0                     # Valeur de degagement en X avant rotation
degageY_pal = 0                     # "    Y "
degageZ_pal = 0                     # "    Z "

# SI "deg_inspection_plaq " = 0 valeur X/Y & Z = à la valeur SECURITE de l'opération MASTERCAM
deg_insp_X = 0                      # Valeur de degagement en X avant inspection de l'état de la plaquette
deg_insp_Y = 0                      # "    Y "
deg_insp_Z = 0                      # "    Z "

#------------------------------------------------------------------------------------------------------------------
Cycles_palpage_YN   = 0     # activation ou pas de l'utilisation des cycles de palpages "BASICs" (en perCages)
change_nom          = 0     # 1 = nomination des programmes avec un préfix "PF" + "numARTICLE" + "INDICE" + "CODE_CN"  = PF15662-A-2-HE.H ////    0 = NOM DANS MC
F_variables         = 0  	# utiliser les avances F en variables ...
output_z            = 0     # Output Z Min and Z Max des parcours (1 ou 0)
program_stop        = 22    # Stop M00 ou M01
							# 1 = M00 AVANT le changement d'outil
							# 2 = M01 AVANT le changement d'outil
							# 11 = M00 APRES le changement d'outil
							# 22 = M01 APRES le changement d'outil
entete_questions    = 2     # 0 = pas d'entEte
                            # 1 = entEte suivant OP MC TEXTE
                            # 2 = Nouvelle entEte questions
                            # 3 = Ancienne entEte questions
affiche_ori_entete  = 1   	# Affiche les origines du programme en entête
                            # 0 = NON
                            # 1 = APRES LA LISTE D'OUTILS
                            # 11 = APRES LA LISTE D'OUTILS SI > 54
                            # 2 = DANS UN FICHIER A PART
                            # 22 = DANS UN FICHIER A PART si > 54
#Outils ----------------------------------------
Type_appel_outil    = 1     # 1 = NUMERO de l'outil                     "Txx
                            # 2 = NOM de l'outil                        "FRAISE D..."	HURCO -->T1234 et D1,2,3...
                            # 3 = VARIABLE suivie du NUMERO de l'outil  "T#xx=yy (FR. CA. D=8.)

Type_infos_outil    = 4     # 1 = NOM de l'outil "texte NOM" --> strtool$
                            # 2 = Infos géométrique réelle de l'outil
                            # 3 = NOM MC de l'outil et Infos géométrique réelle de l'outil
                            # 4 = NOM de l'outil "texte NOM" & Infos géométrique réelle de l'outil --> = 1 + 2

Position_info_outil = 1     # 1 = Affichage AVANT l'appel de l'outil
                            #        Nxx T2 M6
                            # 2 = Affichage APRES l'appel de l'outil

utilise_palette 	= 0     # Affiche la gestion des palettes, codes M début et fin pour rotations et degagements outils avant rotations
                            # 1 = Fonctions M uniquement sans dEgagements spécifiques
                            # 11 = Fonctions M ET dEgagements spécifiques

#prEparation de l'outil SUIVANT
bldnxtool$          = 1     # 0 = n'affiche pas la préparation de l'outil suivant
                            # 1 = affiche				
type_prep_outil     = 0     # 0 = Pas de prEparation du 1er outil
                            # 1 = PrEparation A chaque outil (ptlchg$)
                            # 2 = PrEparation A chaque outil et A LA FIN (peof)
# Déchargement de l'outil en broche
decharge_outil_fin  = 1     # 1 = affiche un "T0 M6" à la fin

# Fin de programme
fin_programme		= 1		# 1 = M30	2 = M02 	3 = M99

affiche_G43_H		= 1		# 1 = 1 er Z/outil
							# 2 = 1 er Z/outil & 1 er Z après rotations ( avec dégagements en G53 )
							# 0 = SANS --> ex: certaines Hurco

# RENVOI D'ANGLE
S_maxi_renvoi_angle = 2000	#
prepa_out_renvoi	= 1		# 1 = préparation de l'outil avec le renvoi d'angle	
							
lire_def_machine    = 1     # 1 = Lire les valeurs de la def machine / armoire --> AXES/ARCs/cycles ...
                            # 0 = suivant les données du PP

Systeme_rot_plans   = 0     # SystEme de gestion des différentes valeurs lors d'une rotation
                                # 0  = pas de calculs --> origine gEnEralement au centre de la palette
                                # 1  = calculs AUTO "G68" --> origine oU on veut
                                # 2X =	Calcul suivant une transition de l'origine CALCULé
									# 21 = utilise le sous-programme O8000 pour calculer automatiquement les origines pour chaque face
                                    	# utilise_O8000 --> G54 au dEbut et ensuite G55 calculE, Exemple : G54 G90 B122.; M98 P8000 ...
                                    	# Fichier contenant le O8000 à integrer dans la CN et valider
									# 22 = suivant un décalage d'origine G52/92 calculé
									# 23 = création du G54 depuis un G55 ou G59 avec les coordonnées de l'axe de rotation 
										# rotation en A info de Y et Z
										# rotation en B info de X et Z
                                # 3  = un origine par angle de rotation dEfini par l'opérateur --> G54,G55 ...
                                # 4  = FONCTION "M" en ABSOLU module de rotation à part "automate" (1 ORIGINE PAR ANGLE)
                                # 5  = FONCTION "M" en RELATIF **chaque M=90°** module de rotation à part "capteur automate" (1 ORIGINE PAR ANGLE)
#
rot_AB_un_sens      = 0     # sens AB     0 = libre (en +/-)     1 = SEULEMENT dans le sens + pour certaines CNs

Affiche_temps_dll	: 0	# 1 = YES / 0 = NO							 
#string de reference	 654321								
s_Types_Temps_DLL 		"111111.00000000"	# configuration des différents affichages
					# OPTIMISES  
					# 	"100000.00000000" = Uniquement à la fin du programme 
					# 	"010000.00000000" = A chaque outil 
					# 	"001000.00000000" = A chaque Opération 
					# 	"110000.00000000" = 6+5
					# 	"111000.00000000" = 6+5+4
					# EN ENTETE --> NON optimisEs
					# 	"000100.00000000" = TOTAL 
					# 	"000010.00000000" = par OUTIL
					# 	"000001.00000000" = par OPERATION							

affiche_groupe      : no$   # 0/no$ = pas d'affichage des groupes d'usinage, 1/yes$ = affichage
numcoment           : 0     # Numeroter les lignes de commentaire 0 = nom 1 = oui
info_corr           : 1     # afficher le type de correction
info_surep          : 1     # afficher les surepaisseurs xy et z
#entete              : 0     # Poser les questions pour l'entete
Liste_outils        : yes$  # A préviligier pour activer la liste d'outils au "tooltable$"
tooltable$          : 1     # creation liste outil en entete
                            # Toujours ACTIVE pour lire d'autres infos depuis le PWRTT$
                            # Output tool table  0=no, 1=before header, 2=after header
                            # 3= Pre-read, call the pwrtt postblock
Type_progno         = 2 	# 1 = "Oxxxx"    2 = ":xxxx"

outils_param        = 0     # pour Valider / dévalider l'affichage des outils en parametres
util_x_ori          = 0     # utiliser les origines par orientation 0 = NON, 1 = OUI
Type_UGV            = 3    	# si UGV = 0 --> NON utilisé 
								# 1 = G8 P1/P0
								# 2 = G5.1 P1 					Hurco: précision /P2 standard /P3 performance /P0 annulation
								# 3 = G5.1 Q1/Q0				Hurco: Le paramètre Q_ définit le segment cordal pour la finition, où Q est la valeur d'erreur acceptable
								# 4 = G5.2 Q0.02 mm /Q0			Hurco: tolérance de Lissage doit être comprise entre 0 à 0,02 mm inclus
								# 5 = G5.3 P1-100/Q0 			Hurco: est utilisée avec l'option de sélection de surface. P1 donne une surface plus lisse
								# 6 = G5 P2/P0					Mazak Option
								# 7 = G61.1/G64					Mazak Option	A TESTER
									# K = coefficient de forme 30=30% de l'avance
									# P = Contrôle de l'usinage lisse
									# R = Contrôle de coin lisse
								# 8 = G61.1/G5 P2 & G5 P0/G64	Mazak Option	A TESTER --> fichier en exemple
								
CN_textes           = 1     # Autorise les commentaires texte

Nom_porte_outil_entete  = 3 # Affiche le nom du porte outil avec la liste des outils en entête, s'il y en a un
                                # 1 = porte outil & longueur de sortie
                                # 2 = assemblage & longueur de sortie
                                # 3 = porte outil & assemblage & longueur de sortie

affiche_num_op_MC       = 2 # affiche le numéro de l'OP Masctercam extraite
                                # 1 = depuis la DLL
                                # 2 = prmcode$

affiche_type_op_MC		= 1		# affiche le type de l'opération MC

groupe_descripteur      = 0 # Affiche en ENTETE 0 = NON
                                # 1 Nom de la Machine
                                # 2 Nom du groupe PRINCIPAL d'opErations
                                # 3 Nom du groupe 1
                                # 4 Descripteur de fichier
                                # 5 Les 4

nom_programmeur_PC 		= 0 # Affiche le nom du programmeur
								# 1 = Nom du programmeur
								# 2 = Non de l'ORDI
								# 3 = Les deux

type_dec_4x_percage     = 0 # Type de gestion du perçage 4/5 axes
                                # 0 perçage en absolu, classique
                                # 1 perçage en relatif depuis le nouveau pt XYZ passé à 0

block_form              = 1 # Sortie du TYPE de BRUT et DIMENSIONS 

convoyeur				= 1 #

compteur_pieces			= 1	#

percages_formats_Q		= 1	#Format d'affichage pour Q
								# 1 = Q --> 1.234 mm
									# 2 = Q --> 10
									# 3 = Q --> 100
								# 4 = Q --> 1234

dwell_tempo				= 1 # Format pour les temporisations
								# 1 = G4 X	
								# 2 = G4 U
								# 3 = G4 P	

type_avance            	= 0 # Type d'avance
	                            # 0 = G94 mm/mn
	                            # 1 = G94 force l'affichage
	                            # 2 = G95 mm/tour de broche

fmt_pas_tap				= 1	# Format d'affichage du pas 
								# 0 = 1.	(1mm)
								# 1 = 1000			
													
# QUESTIONS ENTETE ----------------------------------------------------
# Questions UNIQUEMENT des STRINGS NON VIDES !!
s_texte_question_1 : "CLIENT"
s_texte_question_2 : "DESIGNATION PIECE"
s_texte_question_3 : "NUMERO DU PLAN"
s_texte_question_4 : "INDICE DU PLAN"
s_texte_question_5 : "NUM. PHASE :"
s_texte_question_6 : "ORIGINE PIECE"
s_texte_question_7 : "X :"
s_texte_question_8 : "Y :"
s_texte_question_9 : "Z :"
s_texte_question_10 : "COMMENTAIRE :"
s_texte_question_11 : ""
s_texte_question_12 : ""
s_texte_question_13 : ""
s_texte_question_14 : ""
s_texte_question_15 : ""
s_texte_question_16 : "NOMBRE DE PIECES EN PALETTE A :"     # ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M..."
s_texte_question_17 : "NOMBRE DE PIECES EN PALETTE B :"    # ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
s_texte_question_18 : "Numero de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"
s_texte_question_19 : ""    # exemple : "TOLERANCE CORDALE POUR DEVELOPPE"    #plus utilisé
s_texte_question_20 : "VEUILLEZ ENTRER UN NUMERO DE PROGRAMME"

# CODES M -------------------------------------------------------------

# Coolant output code selection for X style coolant
# Note: To enable X style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, disable first check box
#   Output of X style coolant commands in this post is controlled by pcan, pcan1, & pcan2
scool50    : "M8 ( BUSE ON)"                    #Coolant 1 on value
scool51    : "M9"                             	#Coolant 1 off value
scool52    : "M51 ( AIR ON)"                    #Coolant 2 on value
scool53    : "M9"                            	#Coolant 2 off value
scool54    : "M7 ( ARROSAGE AU CENTRE ON)"      #Coolant 3 on value
scool55    : "M9"                             	#Coolant 3 off value
scool56    : "M8(Coolant4=ON)"                  #Coolant 4 on value
scool57    : "M9"                               #Coolant 4 off value
scool58    : "M8(Coolant5=ON)"                  #Coolant 5 on value
scool59    : "M9"                               #Coolant 5 off value
scool60    : "M8(Coolant6=ON)"                  #Coolant 6 on value
scool61    : "M9"                               #Coolant 6 off value
scool62    : "M8(Coolant7=ON)"                  #Coolant 7 on value
scool63    : "M9(Coolant7=OFF)"                 #Coolant 7 off value
scool64    : "M8(Coolant8=ON)"                  #Coolant 8 on value
scool65    : "M9(Coolant8=OFF)"                 #Coolant 8 off value
scool66    : "M8(Coolant9=ON)"                  #Coolant 9 on value
scool67    : "M9(Coolant9=OFF)"                 #Coolant 9 off value
scool68    : "M8(Coolant10=ON)"                 #Coolant 10 on value
scool69    : "M9(Coolant10=OFF)"                #Coolant 10 off value
scoolantx : ""                                  #Target for string

fstrsel scool50 coolantx scoolantx 20 -1

#X coolant has the option - First coolant off command shuts off ALL coolant options
sall_cool_off  : "M09" #Coolant off command output with all_cool_off
# --------------------------------------------------------------------------
# Blocage déblocage 4ieme Axe
sblo0   : ""        # pour pas de blocage ni deblocage
sblo1   : "M10"     # blocage axe A
sblo2   : "M11"     # déblocage axe A
sblo3   : ""        # pour Frein axe A
sbloque : ""
fstrsel sblo0 bloque sbloque 4 -1
#-------------------------------------------------------
# Rotation broche
sm_00    : "M4"
sm_01    : "M5"
sm_02    : "M3"
sm_03    : "M14"
sm_04    : "M15"
sm_05    : "M13"
sm_06    : "M24"
sm_07    : "M25"
sm_08    : "M23"
sm_09    : "M34"
sm_10    : "M35"
sm_11    : "M33"
spdlon     : ""
spdlsel = fsg3(ss$)
#spdlsel = fsg3(ss)+(coolant*3)
fstrsel  sm_00 spdlsel spdlon 12 -1
#-------------------------------------------------------
# GESTION DES TEXTES OPTIONNELS
s_texte_0     : ""
s_texte_1    : "M0"                     	#N° 1
s_texte_2    : "M1"                     	#N° 2
s_texte_3    : "( BLOC OPTIONNEL ON"
s_texte_4    : "( BLOC OPTIONNEL OFF"
s_texte_5    : "( REPRISE"
s_texte_6    : "( ZONE 1"
s_texte_7    : "( ZONE 2"
s_texte_8    : "( EBAUCHE"
s_texte_9    : "( FINITION"
s_texte_10   : "( AJOUTER LES BRIDES"
s_texte_11   : "( ENLEVER LES BRIDES"     	#N° 11
s_liste_textes : ""

fstrsel s_texte_0 liste_textes s_liste_textes 11 -1

#s_texte_12   : "BLOC OPTIONNEL ON"        	#N° 1101
#s_texte_13   : "BLOC OPTIONNEL OFF"    	#N° 1102
#s_texte_14   : "REPRISE"
#s_texte_15   : "BLOC OPTIONNEL OFF"
#s_texte_16   : "REPRISE"
#s_texte_17   : "ZONE 1"
#s_texte_18   : "ZONE 2"
#s_texte_19   : "EBAUCHE"
#s_texte_20   : "FINITION"                	#N° 1109
#s_texte_20   : "FINITION"                	#N° 1110 ... 1119
# --------------------------------------------------------------------------
s_convoyeur_ON		: "M35 (CONVOYEUR ON)"
s_convoyeur_OFF		: "M36 (CONVOYEUR OFF)"
#
s_compteur_piece	: "G950 (COMPTEUR PIECE)"
#
s_taraudage_rigide	: "M29"	#M29/329 ##(TARAUDAGE RIGIDE) VIDE = SANS --> ""
# Remise à ZERO de la valeur du A/B pour éviter les déroulés d'axes
s_reset_AB			: ""	#"M31 (REMISE A ZERO AXE A-B)"		# HURCO M31
# --------------------------------------------------------------------------

[STARTBIN]
#property of FICAM, Eric Dauvilliers, e.dauvilliers@ficam.com, +33 (0)2 37 26 28 10

#aide PPs
#if prmcode$ = 20005, perc_prof = rpar(sparameter$, 1)  #affecte la valeur de la ligne NCI 20005 - colonne 1 A  la variable "perc_prof"
#nextdc$ --> retourne la valeur du prochain type de perCage de 0 A  ....

#region autres switches
#infos communes AVEC LECTURE DEFINITION de la CN             et SWITCH sans lecture de la DEFINITION de la CN
useaxe          : -999    	# -999 = mode AUTO (DEF MACHINE) -- (utiliser l'axe A/B 1=oui 0=non)
sens_AB        	: 1     	# pour inverser les calculs de l'axe A/B -1
diviseur        : -1    	# diviseur tourne autour de X=1-->A autour de Y=2-->B // DEF MACHINE=-1

# ZONE de FORMULES  si : uniquement au dédut si = constante
no$         	= 0
yes$        	: 1

get_1004$   	: 1     # Find gcode 1004 with getnextop?
cant_tlchng$    : 1  	# Ignorer entrée de texte programmé au changement avec tlchng_aft?
rpd_typ_v7$ 	: 0     # Use Version 7 style contour flags?
getnextop$  	: 1     # autorise la commande nextop nextccomp etc
#spaces$     	= 1     # nbr d'espace entre les mots --> REplage dans PPREP
strtool_v7$ 	: 2     # autorise la lecture des commentaires de la bibiotheque outil
skp_lead_flgs$  : 1 	# Do NOT use v9 style contour flags
ncldr$      	: 20    # nbr de zero de queue utilisés pour la fonction "fleader"
ldrcode$    	: 65
nobrk$      	: no$   # ne pas décomposer en xy pui z les mouvements en rapide
cc_1013$    	: 0     # pour connaitre cc dans appel outil
opcode$     	: 1
gcode$      	: -1
no_updprv$  	: no$   # no$ = utilise / yes$ = non(message)

#----------fichier-prog
sextnc$     	: "nc"  # extension des fichiers nc
progname$   	: 1     # force le nom du nci en majuscule
#----------Sous-prog
sub_level$  	: 2     # Enable automatic subprogram support
subprg$     	: yes$
mergesub$   	: no$
extprg$     	: 1     #'extprg$' doit Etre à  1 pour (remplacer/écraser)
                        #ou 2 (ajouter au fichier existant) pour ouvrir un fichier auxiliaire.
#auxprg$     	: 1
sextext$    	: ".ext"
spathext$     	= spathnc$
sextsub$     	: ".sub"
spathsub$     	= spathnc$
sextaux$     	: ".aux"	# Sous-programme interne /passes en Z ..
spathaux$     	= spathnc$

# POUR INFOS
type_test_bris_outils   : 0 # test de bris outil --> mi5$
                                # 0 = non
                                # 1 = ecriture en cycle "AXIAL - FORET",
                                # 2 = appel sous programme qui est dans "sbris_outil" a configurer plus bas
                                # 3 = "TCH PROB 586"
Test_bris_outils        : 0 # Valeur depuis     --> mi6$
                                # 1 = A la fin de chaque outil  --> ptlchg
                                #     A chaque opération --> ptlchg0
#endregion

#region REGLAGE_DEBUG
Mode_reglage_PP 	= 1         # 1= affiche toutes les valeurs pour info
affiche_prmcodes 	= 1         # 1= Affiche les prmcode$

# ----------------------------- Restrictions
# 1=actif    0=inactif
num_clEe_DEALER    : 104632     # Sergio = 104632    --> débloque toutes les restrictions
#
restric_version_MC      : 0   	# 0/1    1=actif    0=inactif
restric_version_num     : 21 	# 21=2019    22=2020
restric_num_clEe        : 0     # 0/1    1=actif    0=inactif
num_clEe_client         : 0     # numEro de la clEe atribuEe
#
restric_durEe           : 0     # 0/1    1=actif    0=inactif
jour_                   : 23    # jour limite
mois_                   : 10    # mois limite
annEe_                  : 19    # annEe limite --> 20= 2020
#
#region Historique_modifs_versions
# -   DESCRIPTION DES MODIFICATIONS
# Cycle d'ébavurage à la brosse
# Avances en DEG/mn en substitution et 4axes continus
# Palettes sur A/B
# correction affichage du 1er Z pour G1 après rotation
# 27/01/25	- suppression de l'appel du ploc "p_ori_usi_nul" au changement d'outil nul
# 24/04/25	- Gestion du M0 entre 2 OPs avec la rotation de broche et lub
#endregion
#endregion

#region formats
# - FORMATS DES VARIABLES
# --------------------------------------------------------------------------
# Format statements - n=non modale, l=leading(devant), t=trailing(derriEre), i=inc, d=delta
# --------------------------------------------------------------------------
fs  1  1.9lt    # Format avec toute la precision pour les variableS internes de mp
fs  2  1.3      # format d'affichage a 3 chiffres max pour les variables affichées
fs  3  1.3n     # idem mais non modale
fs  4  1 0      # 1 chiffre mini avant virgule  pas de virgule pas de chiffre apres
fs  5  1 0n     # idem mais non modale
fs  6  4 0ln    # 4 chiffres avant pas de virgule pas de chiffre apres non modal force 0 de tete
fs  7  1 3t     # 1 chiffre avant la vigule met 1 chiffres apres virgule non modal force 0 de tete 	x1
fs  8  1.3ln    # 1 chiffre avant la vigule met . 3 chiffres apres virgule non modal force 0 de tete
fs  9  1 0n     # pour liste outil
fs  10 1.3n     # pour liste outil
fs  11 1.3i     # force 1 chiffre avant virgule met . 3 chiffres apres virgule en incremental
fs  12 1.3ni
fs  13 3 0ln

fs  15 1.9l
fs  16 6.6n 

fs  28  1 2t	# 1 chiffre avant la vigule met 2 chiffres apres virgule non modal force 0 de tete	x10	
fs  29  1 3t	# 1 chiffre avant la vigule met 3 chiffres apres virgule non modal force 0 de tete	x100
#endregion

#region fmt AFFECTATIONS_FORMATS
#brut
# --------------------------------------------------------------------------
fmt         3  stck_crnr$  #Origin corner of stock (0 - 8)
fmt "X"     2  stck_x$     #X origin of block
fmt "Y"     2  stck_y$     #Y origin of block
fmt "Z"     2  stck_z$     #Z origin of block
fmt "LX"    2  stck_ht$    #X - Stock Height
fmt "LY"    2  stck_wdth$  #Y - Stock Width
fmt "LZ"    2  stck_thck$  #Z - Stock Thickness
fmt "X"     2  stck_x_min  #Minimum stock block position (X)
fmt "Y"     2  stck_y_min  #Minimum stock block position (Y)
fmt "Z"     2  stck_z_min  #Minimum stock block position (Z)
fmt "X"     2  stck_x_max  #Maximum stock block position (X)
fmt "Y"     2  stck_y_max  #Maximum stock block position (Y)
fmt "Z"     2  stck_z_max  #Maximum stock block position (Z)

fmt  "SUREP. FACE:" 2  bottomz          #Bottom of stock
fmt  "LG T.:"		2  topz             #Top of stock
fmt  ""       		2  stck_ll_x        #Stock lower left corner X value
fmt  ""       		2  stck_ll_y        #Stock lower left corner Y value
fmt  ""       		2  stck_ur_x        #Stock upper right corner X value
fmt  ""       		2  stck_ur_y        #Stock upper right corner Y value
fmt  "DIAM. EXTER:" 2  stck_cyl_dia     #Stock diameter for Cylindrical stock
fmt  "DIAM. INTER:" 2  stck_cyl_dia_inter     #Stock diameter for Cylindrical stock
#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES FLAG
fmt         4 numcoment         # flag pour Numeroter les lignes de commentaire
fmt         1 CN_textes         # flag pour textes
fmt         1 nbr_car           # nombre de carracteres maxi dans les connemtaires
fmt         1 old_comm_cnt      # nombre d'enregistrement dans buffeur commentaires
fmt         1 info_corr         # flag pour correction outil
fmt         1 info_surep        # flag pour surep_XY_2D
fmt         1 old_spaces        # memo de spaces
fmt         1 old_omitseq       # memo de omiseq
fmt         4 entete            # Variable utilisée pour générer l'entete
fmt         4 numerote          # Variable numerote utilisée pour numéroter ou non les lignes
fmt         4 Type_appel_outil
fmt         3 entete_
fmt         3 entete_questions
fmt         2 change_nom
fmt         2 affiche_groupe
fmt         4 affiche_ori_entete
fmt         4 liste_textes
fmt         4 deg_debut
fmt         4 deg_outil
fmt         4 deg_4_axes
fmt         4 deg_fin
fmt         4 deg_inspection_plaq
fmt  "X"    3 degageX
fmt  "Y"    3 degageY
fmt  "Z"    3 degageZ
fmt  "X"    3 degageX_fin
fmt  "Y"    3 degageY_fin
fmt  "Z"    3 degageZ_fin
fmt  "X"    3 degageX4
fmt  "Y"    3 degageY4
fmt  "Z"    3 degageZ4
fmt  "X"    3 degageX_pal
fmt  "Y"    3 degageY_pal
fmt  "Z"    3 degageZ_pal
fmt  "X"    3 deg_insp_X
fmt  "Y"    3 deg_insp_Y
fmt  "Z"    3 deg_insp_Z
fmt  "X"    3 old_degageX
fmt  "Y"    3 old_degageY
fmt  "Z"    3 old_degageZ
fmt  "X"    3 old_degageX4
fmt  "Y"    3 old_degageY4
fmt  "Z"    3 old_degageZ4
fmt         4 deg_apres_outil
fmt         4 deg_palette_deb_fin
fmt         4 type_deg
fmt         4 old_type_deg    #memo old_deg
fmt         4 old_op_id    # Memo de l'operation
fmt			4 output_z
fmt			4 Cycles_palpage_YN
fmt			4 program_stop
fmt			4 Type_infos_outil
fmt			4 Position_info_outil
fmt			4 utilise_palette
fmt			4 type_prep_outil
fmt			4 decharge_outil_fin
fmt			4 fin_programme
fmt			4 affiche_G43_H
fmt			4 S_maxi_renvoi_angle
fmt			4 Systeme_rot_plans   
fmt			4 rot_AB_un_sens
#fmt			16 Types_Temps_DLL_INI
fmt			4 Liste_outils
fmt			4 Nom_porte_outil_entete
fmt			4 affiche_num_op_MC
fmt			4 affiche_type_op_MC
fmt			4 old_affiche_type_op_MC
fmt			4 groupe_descripteur
fmt			4 nom_programmeur_PC
fmt			4 type_dec_4x_percage
fmt			4 block_form
fmt			4 convoyeur
fmt			4 compteur_pieces
fmt			4 percages_formats_Q
#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES MP
fmt         1 gcode$        # Gcode pst
fmt         1 x$            # XYZ pst
fmt         1 y$
fmt         1 z$
fmt         1 xr$           # XYZ rapide pst
fmt         1 yr$
fmt         1 zr$
fmt         1 i$            # IJK centre des arcs pst
fmt         1 j$
fmt         1 k$
fmt         1 arcrad$       # Valeur du rayon pst
fmt         5 t$            # numéro d'outil pst
fmt         4 next_tool$    # numéro suivant pst
fmt         1 nom_outil
fmt         1 first_tool$   # numéro du premier outil pst
fmt         1 tloffno$      # Correcteur de Diamentre pst
fmt         1 tlngno$       # Correcteur de Longueur pst
fmt         1 tldia$        # diamétre outil pst
fmt         1 fr$           # avance pst
fmt  "F"    4 fr_pos$       # AVANCE TRAVAIL au point pst
fmt         1 ss$           # vitesse de broche pst
fmt  "N"    4 n$            # numérotation des blocs a chaque ligne
fmt  "O"    6 progno$       # Numéro de programme pst
fmt  ":"    4 progno_       # Numéro de programme pst
fmt  "G"    4 cc$           # valeur de la correction dans NCI
fmt         1 coolant$      # Lubrification 0 1 2 3 arret axe buse les deux
fmt         4 mi2$          # 
fmt         4 Type_UGV           # flag pour ecriture de G8 P1 ou G8 P0 ...
fmt         4 old_Type_UGV
fmt         1 op_id$        # Numero de l'operation du gestionaire PST
fmt  "opcode: "   4 opcode$
#------------------- PERCAGES ------------------------------------------
fmt         1 depth$        # profondeur percage pst
fmt         1 refht$        # Garde pour percage pst
fmt         1 initht$       # Plan de sécu percage pst
fmt         1 frplunge$     # Avance percage pst
fmt         1 dwell$        # Tempo pour percage pst
fmt      	3 dwell       	# Tempo pour percage PROFOND pst
fmt  "P"    3 dwell_       	# Tempo pour percage PROFOND pst
fmt  "D"    3 peckclr$     	# garde d'approche rapide dans les débourrage pst
fmt  "Q"    3 peck1$        # Pas Z du premier débourrage pst
fmt  "Q"    3 peck2$        # Pas Z des débourrages suivants
fmt  "Q"    3 shftdrl$      # valeur de retrait du grain de la barre d'alésage
fmt  "Q"    3 retr$         # valeur de remonté relative en rapide dans les debourrages en G1 G0
fmt         4 drill_4_axes  # percage 5axes O/N
#---------------- PERCAGE 4 AXES *CYCLE CONTINU*-----------------------
fmt         1 rotdia$       # diam de substitution
fmt         1 rotaxis$      # type de substitution
fmt "u"     1 u$
fmt "v"     1 v$
fmt "w"     1 w$
fmt "old_w" 1 old_w_
fmt "X"     2 tox4$
fmt "Y"     2 toy4$
fmt "Z"     2 toz4$
fmt "X"     2 tox4_
fmt "Y"     2 toy4_
fmt "Z"     2 toz4_
fmt "VX"    1 vx
fmt "VY"    1 vy
fmt "VZ"    1 vz
fmt "VX2_"  1 vx2
fmt "VX2_"  1 vx2_h
fmt "VY2_"  1 vy2
fmt "VZ2_"  1 vz2
fmt "Z"     2 zinitht
fmt "VEC"   1 longvec
fmt "OX"    2 old_tox4
fmt "OY"    2 old_toy4
fmt "OZ"    2 old_toz4

fmt  "X"    8 xrp
fmt  "Y"    8 yrp
fmt  "Z"    8 zrp
fmt  "Z"    8 zp

fmt  "X"    8 x_h
fmt  "Z"    8 y_h
fmt  "Y"    8 z_h
fmt  "X"    8 xr_h
fmt  "Z"    8 yr_h
fmt  "Y"    8 zr_h

fmt  "X"    1 old_x_h
fmt  "Z"    1 old_y_h
fmt  "Y"    1 old_z_h
fmt  "Z"	2 zr_
#------------------- SOUS PROG ------------------------------------------
fmt         1 sub_prg_no$   # Numéro de sous-programe interne en Z
fmt         1 main_prg_no$  # Numéro de sous prog interne en transformation
fmt         4 sub_sec_no$   # numero de passe de sous prog
fmt         4 sub_totl_no$  # nombre total de passes
fmt  "X"    2 sub_trnsx$    # decalage en X pour G52 en usinage transformer translation
fmt  "Y"    2 sub_trnsy$    # decalage en Y pour G52 en usinage transformer translation
fmt  "Z"    2 sub_trnsz$    # decalage en Z pour G52 en usinage transformer translation
#------------------------------------------------------------------------------------------------------------------
#   AFFECTATION DES VARIABLES NC
#------------------- POSITIONS ------------------------------------------
fmt  "X"    2 xabs         # XYZ en Absolue pour NC
fmt  "Y"    2 yabs
fmt  "Z"    2 zabs
fmt  "Z"    2 zabs_deb_fin_secu_p_5x

fmt  "X"    11 xinc        # XYZ en incremental pour NC
fmt  "Y"    11 yinc
fmt  "Z"    11 zinc

fmt "px"    2 old_x        # ancien XYZ du NC
fmt "py"    2 old_y
fmt "pz"    2 old_z
fmt 		2 old_zabs

fmt  "I"    2 iabs         # IJK centre des arcs pour NC en G90
fmt  "J"    2 jabs
fmt  "K"    2 kabs

fmt  "I"    2 iinc         # ijk centre des arcs pour NC en G91
fmt  "J"    2 jinc
fmt  "K"    2 kinc
fmt  "R"    3 rayon        # valeur de rayon de l'arc pour NC
#------------------- OUTILS ------------------------------------------
fmt  "T"        5 outil                	# numéro d'outil appele pour NC
fmt  "T"        5 outil_suivant        	# numéro de l'outil suivant pour NC
fmt  "D"        4 correcteur_D         	# Correcteur de Diametre pour NC
fmt             4 correcteur_H      	# Correcteur de Longueur pour NC
fmt  "H"        4 old_correcteur_H
fmt             2 old_t

fmt             5 outil_param
fmt             5 outil_suiv_param
fmt             4 correcteur_D_param
fmt             4 old_correcteur_D_param
fmt             4 old_correcteur_D
fmt             4 correcteur_H_param
#
fmt  "DIAM "    2 diam_outil       		# diamétre outil pour NC
fmt  "F"        4 avance           		# avance pour NC

fmt  "S"        4 ssa              		# Vitesse de broche affiché
#ssa = abs(ss$)                 		# vitesse de broche en valeur absolue
fmt             4 posi_p_prof
fmt  "S"        4 old_ssa           	# memo de la vitesse de broche précédente
fmt             4 lubrif        		# gestion de la lubrification pour NC
fmt             4 old_lubrif    		# gestion de la lubrification pour NC
# -------------------------LECTURE DES PARAMETRES DE surep_XY_2D ET DE TYPE DE CORRECTION--------------------------------------------
fmt "Type correc "  2 cc_computer$  	# Type correction G41/G42/0
fmt "1=G41-2=G42"   2 cc_pos$       	# correction 1= G41(G) 2= G42(D) 0= OFF
fmt                 2 type_comp     	# type de correction

fmt "SUREP. XY 2D = "   8 surep_XY_2D
fmt                     8 old_surep_XY_2D
fmt "SUREP. Z 2D = "    8 surep_Z_2D
fmt                     8 old_surep_Z_2D
fmt "SUREP. Z SURF = "  8 surep_Z_surf_2D
fmt                     8 old_surep_Z_surf_2D
fmt "SUREP. XY 3D = "   8 surep_XY_3D
fmt                     8 old_surep_XY_3D
fmt "SUREP. Z 3D = "    8 surep_Z_3D
fmt                     8 old_surep_Z_3D
#
fmt "R"         	2 result
fmt             	5 prognosav     # Mémo du Numéro de programe
fmt             	1 debut         # flag pour debut de programme
fmt             	5 degage_ap_out
fmt             	4 rot_tlchg_zero

fmt  "X"         	2 x_
fmt  "Y"         	2 y_
fmt  "Z"         	2 z_
#------------------- NUMEROTATION ------------------------------------------
fmt  "N"         	4 num           # numero de bloc sur ligne appel outil si pas de numerotation des lignes

#------------------- ORIGINES D'USINAGE ------------------------------------------
fmt "G"         	4 origine       # origine d'usinage G54 a G59 pour NC
fmt "G54.1 P"      	4 origine_bis    # origine d'usinage G54.1 P1 à G54.1 P49 pour NC
fmt "G"         	4 old_origine   # Stocage de la valeur precedente de origine d'usinage
fmt                	4 workofs$
fmt                	4 workofs_
fmt                 4 workofs_pwrtt
fmt                	4 old_workofs
fmt "G"         	4 g_wcs         # WCS G address
fmt " "         	2 mi4$
fmt                	4 compteur_workofs
fmt    				4 workofs_dec
fmt             	2 Val_origine_Z
fmt             	2 Val_origine_Y
fmt             	2 Val_origine_X
fmt             	2 Old_Val_origine_Z
fmt             	2 Old_Val_origine_Y
fmt             	2 Old_Val_origine_X
#---------------------- SOUS PROG ------------------------------------
fmt "inc"       1 incremental       # mode incremental ou Absolue
fmt             1 memo_incremental  # memeo du mode incremental ou Absolue
fmt "O"         6 debsousprog       # Numéro du premier sous programme
fmt "#100="     4 nprincipal        # memo du numero de ligne du prog principal
fmt "P"         5 subprognum        # numero du sous-programe pour l'appel
fmt "O"         4 numsubprog        # Numéro entete de sous-programme
fmt ":"         4 numsubprog_       # Numéro entete de sous-programme
fmt             5 nomsubprog        # Numéro n'entete de sous-programe
fmt "DEC"       2 decalage          # flag pour savoir si on a ecrit un G52
fmt             4 Type_progno
fmt     		4 old_sub_trnstyp 
old_sub_trnstyp : -1
#------------------- PERCAGES/PALPAGES ------------------------------------------
fmt  "Z"        2 prof_abs         	# profondeur de percage en ABS
fmt  "Z"        2 prof_inc         	# profondeur de percage en INC
fmt  "R"        2 garde_abs        	# Garde pour percage en ABS
fmt  "s_R"      2 old_garde_abs     # sauve Garde pour percage en ABS
fmt  "R"        2 garde_inc        	# Garde pour percage en INC
fmt  "F"        3 pas              	# valeur calculé du pas pour taraudage rigide
fmt             2 typcycle          # variable mise a 1 lors des percages pour afficher l'intitulé du cycle
#cycle de percage profond
fmt "F"         9 f_p_profond
fmt "Z"         2 z_dep_p_prof
fmt "Z"         2 depth_
fmt "Z"         2 tosz_
fmt "Z"         2 initht_
fmt "Z"         2 refht_
fmt             2 drlcst7
#palpages
#fmt            3 var_palp
fmt  "U"        2 u_palpage
fmt  "V"        2 v_palpage
fmt  "X"        2 x_palpage
fmt  "Y"        2 y_palpage
fmt  "Z"        2 z_palpage
fmt  "W"        4 w_palpage
fmt  "D"        2 d_palpage
fmt  "A"        2 a_palpage
fmt  "B"        2 b_palpage
fmt  "K"        2 k_palpage
fmt             4 palpage
fmt  "F"        3 erreur_pas
fmt  "P"        4 tempo
#-------------------- Axe A  ------------------------------------------
fmt         	3 useaxe        # flag pour utiliser le 4eme axe
fmt  ""     	2 axe_AB        # POSITION pour rotation plateau en ABS
fmt  "B"       11 axe_ABi         # POSITION pour rotation plateau en INCREMENTAL
fmt  "S"     	2 sens_AB      	# pour inverser le sens de l'axe
fmt  ""     	2 axeAB_subs    # rotation pour continue substitution en ABS
fmt  "A"       11 A_posi        # rotation pour continue substitution en INCREMENTAL
fmt  "MAB"     	2 memo_AB_subs  # Memo du A/B du plan pour Ajout/soustraire
fmt         	1 bloque        # pour gestion M10 M11
fmt         	4 outils_param
fmt         	9 outil_paramT1
fmt  "Z"     	2 zdev          # Z pour continue substitution en ABS
fmt  "Z"		11 zdevi        # Z pour continue substitution en INCREMENTAL
fmt         	1 old_rotaxis   # memo de rotaxis$
fmt 	"A"     2 old_axe_AB      # memo de l ancien A
fmt "Sens"     	2 sensA         # sens de rotation de A
fmt  "A"     	2 epsi          # Delta de rotation de l'axe A
fmt  "Ntr"  	2 nbrtour       # nombre de tour realise
fmt  "A"     	1 axeA_cont
fmt  "A"     	1 axeA1
fmt  "A"     	1 axeA2
fmt  "X"     	2 new_x
fmt  "Y"     	2 new_y
fmt  "Z"     	2 new_z
fmt  "A"     	1 delta_axeA1
fmt  "A"     	1 axeA1_dep
fmt  "A"     	11 axeA1_depi
fmt  "A"     	1 old_axeA1
fmt         	1 debutpmx      # flag debut prog pmx
fmt         	9 util_x_ori

fmt     		2 pas_filetage
# -----------------------------------------------
fmt  "X" 2 x_tmin           # Total x_min
fmt  "X" 2 x_tmax           # Total x_max
fmt  "Y" 2 y_tmin           # Total y_min
fmt  "Y" 2 y_tmax           # Total y_max
fmt  "Z" 2 z_tmin           # Total z_min
fmt  "Z" 2 z_tmax           # Total z_max
fmt  "Z" 2 min_depth        # Tool z_min
fmt  "Z" 2 max_depth        # Tool z_max
# Parametres de DEF MACHINE-------------------------------
fmt    1 type_composant     # type de composant
fmt    1 compt_axes_rot     # compteur d'axes rotatif
fmt    3 erreur             # numero d'erreur
fmt    3 testerreur4        # flag pour erreur 4
fmt    1 diviseur           # Axe de l'axe rotatif
fmt    1 old_syncaxis       # memo du numero de combinaison d'axes
fmt    1 nbr_combi          # Nombre de combinaison d'axes
fmt    1 palette            # flag pour machine avec palette
fmt    1 fmaxi              # avance maxi de la machine
fmt    1 fmini              # avance mini de la machine
fmt    1 nbr_outil          # nombre d'outils maxi
# Axes Pwrtt$ --> lecture avant traitement parcours
fmt    2 rotation_axe
fmt    2 rotation_A
fmt    2 rotation_B

fmt    4 zone_secu
fmt    4 premier_cc_5x
#
fmt        	2 Angle_PLAN_MC_renvoie_angle
fmt        	2 old_Angle_PLAN_MC_renvoie_angle
fmt        	2 ANGLE_XY_renvoie_angle
fmt        	2 ANGLE_Z_renvoie_angle
fmt       	4 type_renvoie_angle
fmt  "X" 	2 decX                  		# decalage d'origine en X pour G52
fmt  "Y" 	2 decY                     		# decalage d'origine en Y pour G52
fmt  "Z" 	2 decZ                     		# decalage d'origine en Z pour G52
fmt     	4 renvoi_d_angle
fmt       	4 ra_block$                		# NUM. du BLOCK
fmt       	4 sauve_ra_block_
fmt       	4 ra_tc_type$                	# type changement, auto, fixe, manuel
fmt       	4 sauve_ra_tc_type_
fmt       	3 ra_rot_head$                	# Rotation ou pas NCI line 1029/11 0=fixe 1=rotatif
fmt       	4 ra_type$                    	# type de bloc
fmt      	3 lg_port_out_outil_block    	# longueur du porte outil avec l'outil
fmt       	4 prepa_out_renvoi
fmt 		4 posi_nom_programmeur

fmt 		4 old_usecandrill
fmt 		4 old_usecanpeck
fmt 		4 old_usecanchip
fmt 		4 old_usecantap
fmt 		4 old_usecanbore1
fmt 		4 old_usecanbore2
fmt 		4 old_usecanmisc1
fmt 		4 old_usecanmisc2

fmt 	 	4 usecanDRILL
fmt 	 	4 usecanPECK
fmt 	 	4 usecanCHIP 
fmt 	 	4 perc_1er_perc_pour_C_ou_mm
fmt 	 	2 perc_Val_pour_Cent_mm
fmt 	 	2 perc_AVANCE_pour_Cent_mm
fmt 		2 P_er_perc_0
fmt 		2 P_er_perc_1
fmt "Z"		2 P_er_perc_2
fmt 		2 angle_foret
#endregion

#region debug_tolerances
#--------------------------------------------------------------------------------------------------------
#   DEBUG POST PRO
fastmode$   	: yes$
bug1$     		: 2     # 0 = pas voir le NC  1 = Visu du NC en lecture - 2 = visu du NC en edit
bug2$     		: 60    # numéro de colonne pour l'affichage du bloc en cour de traitement
bug4$     		: 1     # numero de ligne du nci traité
whatno$   		: yes$  # Ignore whatline branches to plin1 etc.?
newglobal$      : 0 	# Activer la vérification d'erreur pour les variables globales?
#--------------------------------------------------------------------------------------------------------
linktolvar$     : 1 # Associer les variables de tolérance X metrique au variable english
linkplnvar$     : 1 # Associer les variables spécifiques plan Xy POUR TOUS LES PLAN YZ XZ
linklvar$       : 1 # Associer les variables spécifiques X Tournage AU FRAISAGE UTILISE LES USECANDRIL POUR LES LCANDRILL
#endregion

#region valeurs_initiales
# valeurs init ---------------
z_min$          : 999
z_tmin          : 999
z_max$          : -999
z_tmax          : -999
longTexte       : 0        
incremental     : 0     # init en Absolue
decalage        : 0
erreur          : 0
nbr_combi       : 0
compt_axes_rot  : 0
palette         : 0
axe_AB            : 999   # Inint de A
axeA1_dep       : -99999
old_axe_AB      : 0     # Init de old_axe_AB
nbrtour         : 0     # Init du nombre de tour realise
degage_ap_out   : 1
rot_tlchg_zero  : 0
num             : 0
old_op_id       : -99999
palpeur         : 0
palpage         : 0
increment_op_outil     : 1
rotation_axe    : -9999
rotation_A      : -9999
rotation_B      : -9999
write_ops       : 0     #Write NC operation information (True/False)

Z_dir           : 0     #Z Axis direction flag
axis_label      : 0     #Axis label - 1=X,2=Y,3=Z
rot_zero        : 0     #Rotary zero degree position
rot_dir         : 0     #Rotary direction
rot_index       : 0     #Index or continuous
rot_angle       : 0     #Index step
rot_type        : 0     #Rotary type
min_speed       : 50    #Minimum spindle speed
maxfrinv_m      : 0     #Maximum feedrate - inverse time - metric - Minimum value from MD as this is inverse time
maxfrdeg        : 0     #Maximum feedrate deg/min
maxfeedpm_m     : 0     #Limit for feed in mm/min

# WORKPIECE variables - used to define the stock for FANUC graphics / simulation on control
stock_cyl_axis  : 0     #Stock cylinder axis 0=X,1=Y,2=Z
stock_shape     : 0     #Stock shape from toolpath group parameters. 0=Rectangular/Box, 1=Cylinder

srot_label      : ""    #Rotary Axis label (Generally A, B or C) - Not yet available.
s_axe_brut_cyl  : ""    #Axe du brut cylindrique

#temps
fr_rapid_mach   : 12000 # Machine Rapid feedrate
tlchg_time      : 0     # Tool Change Time (Minutes) OK VALEUR DANS LA CN

#temps DLL
fmt             1 last_op_id_pwrtt     # Derniere operation
fmt             2 timeTT
fmt             2 timeOp
fmt          	15 Heure "H "
fmt          	15 min	 "M "
fmt          	15 sec	 "S "
fmt             4 Affiche_temps_dll
fmt "time_OP :"     15 Tot_time_op         	# Total operation time
fmt "total_time :"  15 time_total        	# Total time programme
fmt "OPs_time :"    15 time_OPs            	# Time operations
fmt            		15 Time_hrs             # Time in hours
fmt            		15 Time_min             # Time in minutes
fmt            		15 Time_sec             # Time in seconds
fmt            		8  F_USI_prmcode        # Feedrate
fmt "time_OUT :"    15 Tot_time_Out
fmt 				15 nbr_correct_XY_G0_time
fmt 				15 correc_dwell_time
fmt					4 Nbr_outils
fmt					4 Temps_chang_outil
fmt             	4 info_temps
fmt             	4 prof_temps
fmt             	4 div_prof_temps
sdllTimeOp      	: ""
sOpId           	: ""
stimeTT         	: ""
reste           	: 0
sNcPath         	: ""
last_op_id_pwrtt 	: 0
Types_Temps_DLL  	: -1	# Temps depuis la DLL	
Types_Temps_DLL_1  	: -1
Nbr_outils 			: 0
time_correction_op	: 0

ori_1 : 0
ori_2 : 0
ori_3 : 0
ori_4 : 0
ori_5 : 0
ori_6 : 0
ori_7 : 0
ori_8 : 0
ori_9 : 0
#endregion

#region affectations_valeurs
xp          = u$
yp          = v$
zp          = w$          		# Pour 1ère position en 5x c.
xrp         = xr$
yrp         = yr$
zrp         = zr$
xinc        = xabs
yinc        = yabs
zinc        = zabs
axeA1_depi  = axeA1_dep
axe_ABi       = axe_AB            # A absolue en substitution
A_posi      = axeAB_subs      # A incremental en substitution
zdevi       = zdev            # Z pour continue substitutuion en INCREMENTAL
sub_trnsx$  : -99999
sub_trnsy$  : -99999
sub_trnsz$  : -99999
m7$         : 999
m8$         : 999
old_t 		: -9999
Test_bris_outils = mi6$
#endregion

#region Buffer
# --------------------------------------------------------------------------
# Buffer 5 - Min / Max
# --------------------------------------------------------------------------
b5_gcode     : 0
b5_zmin      : 0
b5_zmax      : 0
rc5         : 2
wc5         : 1
size5       : 0
fbuf 5 0 3 0 0          #Min / Max
#endregion

#region TYPE de categories d'OPERATIONS
#Définir les opérations à inclure dans les qualités de finition technique du CYCLE832 - Ebauche
fmt	4	OP_ebauche
fmt	4	OP_finition
fmt	4	OP_percage

hs_surf_style : 0    #High-speed Surface Toolpaths, Style
OP_ebauche =				# 0 ou 1
      (
      tool_op$ = 5   |  # Multisurface rough parallel
      tool_op$ = 6   |  # Multisurface rough radial
      tool_op$ = 7   |  # Multisurface rough project
      tool_op$ = 8   |  # Multisurface rough flowline
      tool_op$ = 9   |  # Multisurface rough contour
      tool_op$ = 10  |  # Multisurface rough pocket
      tool_op$ = 44  |  # Multisurface rough plunge
      tool_op$ = 107 |  # Multi-surface rough restmill
      tool_op$ = 110 |  # Multi-surface 5axis, rough
      tool_op$ = 131 |  # Multi-surface rough pocket, light
      (tool_op$ = 132 & hs_surf_style = 0) |  # High-speed surface toolpaths - Roughing, Area Roughing
      (tool_op$ = 132 & hs_surf_style = 1) |  # High-speed surface toolpaths - Roughing, Dynamic OptiRough
      tool_op$ = 305 |  # Router surface rough pocket (obsolete)
      tool_op$ = 446    # Advanced multiaxis—roughing
      )

#Définir les opérations à inclure dans les qualités de finition technique du CYCLE832 - Finition
OP_finition =				# 0 ou 1
      (
      tool_op$ = 11  |  # Multisurface finish parallel
      tool_op$ = 12  |  # Multisurface finish radial
      tool_op$ = 13  |  # Multisurface finish project
      tool_op$ = 14  |  # Multisurface finish flowline
      tool_op$ = 15  |  # Multisurface finish contour
      tool_op$ = 39  |  # Multisurface finish pencil trace
      tool_op$ = 40  |  # Multisurface finish leftover stock
      tool_op$ = 41  |  # Multisurface finish steep
      tool_op$ = 42  |  # Multisurface finish shallow
      tool_op$ = 43  |  # Multisurface finish constant scallop
      tool_op$ = 45  |  # Multisurface finish 5-axis flowline
      tool_op$ = 46  |  # Multisurface finish 4-axis
      tool_op$ = 109 |  # Multi-surface finish blend
      (tool_op$ = 132 & hs_surf_style = 2)  |  # High-speed surface toolpaths - Finishing, Waterline
      (tool_op$ = 132 & hs_surf_style = 3)  |  # High-speed surface toolpaths - Finishing, Scallop
      (tool_op$ = 132 & hs_surf_style = 4)  |  # High-speed surface toolpaths - Finishing, Horizonal Area
      (tool_op$ = 132 & hs_surf_style = 5)  |  # High-speed surface toolpaths - Finishing, Raster
      (tool_op$ = 132 & hs_surf_style = 6)  |  # High-speed surface toolpaths - Finishing, Pencil
      (tool_op$ = 132 & hs_surf_style = 7)  |  # High-speed surface toolpaths - Finishing, Hybrid
      (tool_op$ = 132 & hs_surf_style = 9)  |  # High-speed surface toolpaths - Finishing, Spiral
      (tool_op$ = 132 & hs_surf_style = 10) |  # High-speed surface toolpaths - Finishing, Radial
      (tool_op$ = 132 & hs_surf_style = 15)    # High-speed surface toolpaths - Finishing, Project
      )

#Définir les opérations à inclure dans la catégorie Perçage
OP_percage =				# 0 ou 1
      (
      tool_op$ = 2   |  # Drill
      tool_op$ = 28  |  # 5-axis drilling
      tool_op$ = 37  |  # Non-associative drilling
      tool_op$ = 104 |  # Solid drill control operation
      tool_op$ = 136 |  # FBM drill control operation
      tool_op$ = 306    # Block drill
      )
#endregion

#region strings
#--------- DEFINITION DES STRING -----------------------
svide                 	: ""        # STRING Vide utilisée pour faire des comparaisons
space                 	: " "       # STRING pour forcer un espace
s_com_open            	: "("       # STRING de debut de commentaire
s_com_close           	: ")"       # STRING de fin de commentaire
sg43                	: "G43"     # STRING de prise de correction en Z
snomgroupe_op         	: ""        # STRING du nom du groupe d'opération
snomgroupe_op_old     	: ""        # STRING de l'ancien nom du groupe d'opération
s_nom_machine_entete	: ""		# STRING du nom de la machine ****VALEUR DANS MC****
spalette             	: "PALETTE" # STRING du nom palette
s_axe_rot_label     	: ""        # Nom de l'axe rotatif (ABC)
s_axe_rot_A         	: "A"
s_axe_rot_B         	: "B"
scomentsprog         	: ""    	# STRING du commentaire pour le titre du sous prog
sguillemet             	: ""
Sold_snom_RUD         	: ""
snom_RUD             	: ""
sinfo_origine         	: ""
sguillemet             	= no2asc(34)
s_old_spost_arg_2    	: ""
s_old_sinfo_origine 	: ""
s_nom_ORDI				: ""
s_nom_ORDI2				: ""
s_nom_programmeur		: ""
s_slash					: "\"
s_tempo					: "G04 "
s_tempo_X				: "X"
s_tempo_U				: "U"
s_tempo_P				: "P"
s_avance_mm_mn			: "G94"
s_avance_mm_tr			: "G95"
#endregion

#region questions_NOUVEAU_ANCIEN
#region NOUVEAU
# QUESTIONS ENTETE ----------------------------------------------------
svide2 : ""
#----
s_question_1 : s_texte_question_1
s_question_2 : s_texte_question_2
s_question_3 : s_texte_question_3
s_question_4 : s_texte_question_4
s_question_5 : s_texte_question_5
s_question_6 : s_texte_question_6
s_question_7 : s_texte_question_7
s_question_8 : s_texte_question_8
s_question_9 : s_texte_question_9
s_question_10 : s_texte_question_10
s_question_11 : s_texte_question_11
s_question_12 : s_texte_question_12
s_question_13 : s_texte_question_13
s_question_14 : s_texte_question_14
s_question_15 : s_texte_question_15
s_question_16 : s_texte_question_16
s_question_17 : s_texte_question_17
s_question_18 : s_texte_question_18
s_question_19 : s_texte_question_19
s_question_20 : s_texte_question_20

#----
fq 1 s_question_1 "//s_texte_question_1//"
fq 2 s_question_2 "//s_texte_question_2//"
fq 3 s_question_3 "//s_texte_question_3//"
fq 4 s_question_4 "//s_texte_question_4//"
fq 5 s_question_5 "//s_texte_question_5//"
fq 6 s_question_6 "//s_texte_question_6//"
fq 7 s_question_7 "//s_texte_question_7//"
fq 8 s_question_8 "//s_texte_question_8//"
fq 9 s_question_9 "//s_texte_question_9//"
fq 10 s_question_10 "//s_texte_question_10//"
fq 11 s_question_11 "//s_texte_question_11//"
fq 12 s_question_12 "//s_texte_question_12//"
fq 13 s_question_13 "//s_texte_question_13//"
fq 14 s_question_14 "//s_texte_question_14//"
fq 15 s_question_15 "//s_texte_question_15//"
fq 16 s_question_16 "//s_texte_question_16//"
fq 17 s_question_17 "//s_texte_question_17//"
fq 18 s_question_18 "//s_texte_question_18//"
fq 19 s_question_19 "//s_texte_question_19//"
fq 20 Var_20_question "//s_texte_question_20//"
#
#fq 25 Var_20_question "Numero de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"
# Nombre de questions jusqu'a  25 maxi

# ICI Questions avec valeurs numériques
fmt 2 Var_1_question
#
fmt 2 Var_16_question
fmt 2 Var_17_question
fmt 2 Var_20_question
Var_1_question : -1
Var_20_question : 1
#...

p_questions_entete
    # A enrichir si besoin --> apres Q13
    if s_texte_question_1 <> svide2, q1
    if s_texte_question_2 <> svide2, q2
    if s_texte_question_3 <> svide2, q3
    if s_texte_question_4 <> svide2, q4
    if s_texte_question_5 <> svide2, q5
    if s_texte_question_6 <> svide2, q6
    if s_texte_question_7 <> svide2, q7
    if s_texte_question_8 <> svide2, q8
    if s_texte_question_9 <> svide2, q9
    if s_texte_question_10 <> svide2, q10
    if s_texte_question_11 <> svide2, q11
    if s_texte_question_12 <> svide2, q12
    if s_texte_question_13 <> svide2, q13
    #
    if palette = 1, if s_texte_question_16 <> svide2, q16
    if palette = 1, if s_texte_question_17 <> svide2, q17

    s_question_1 = ucase(s_question_1)
    s_question_2 = ucase(s_question_2)
    s_question_3 = ucase(s_question_3)
    s_question_4 = ucase(s_question_4)
    s_question_5 = ucase(s_question_5)
    s_question_6 = ucase(s_question_6)
    s_question_7 = ucase(s_question_7)
    s_question_8 = ucase(s_question_8)
    s_question_9 = ucase(s_question_9)
    s_question_10 = ucase(s_question_10)
    s_question_11 = ucase(s_question_11)
    s_question_12 = ucase(s_question_12)
    s_question_13 = ucase(s_question_13)
    #
    if palette = 1, s_question_16 = ucase(s_question_16)
    if palette = 1, s_question_17 = ucase(s_question_17)

    # Pour toute string a convertir en valeur numerique --> faire la meme chose pour d'autres si besoin
    Var_16_question = rpar(s_question_16, 1)
    Var_17_question = rpar(s_question_17, 1)
    #Var_19_question = rpar(s_question_19, 1)    # convertir la valeur texte en valeur numerique
    Var_20_question = rpar(s_question_20, 1)    # convertir la valeur texte en valeur numerique

    schange_nom_fichier = s_question_20    # dans le "Pbloc" --> "pnom_nc" peut-etre modifier le nom de la string --> test si fichier existant

    spathnc$ = ucase(spathnc$)
    stck_matl$ = ucase(stck_matl$)
    snamenc$ = ucase(snamenc$)

    #s_com_open, "DATE LE ", date$," A ", time$, s_com_close, e$
    #s_com_open, "DESSIN MASTERCAM - ", smcname$, s_com_close, e$
    #s_com_open, "NC FILE - ", *spathnc$, *snamenc$, *sextnc$, s_com_close, e$
    #s_com_open, "MATIERE - ", *stck_matl$, s_com_close, e$
    #s_com_open, "NOM DU PROGRAMME - ", sprogname$, s_com_close, e$
    #n$, " ", e$
    if s_texte_question_1 <> s_question_1, n$, s_com_open, s_texte_question_1, "-", s_question_1, s_com_close, e$, longTexte = 1
    if s_texte_question_2 <> s_question_2, n$, s_com_open, s_texte_question_2, "-", s_question_2, s_com_close, e$, longTexte = 1
    if s_texte_question_3 <> s_question_3, n$, s_com_open, s_texte_question_3, "-", s_question_3, s_com_close, e$, longTexte = 1
    if s_texte_question_4 <> s_question_4, n$, s_com_open, s_texte_question_4, "-", s_question_4, s_com_close, e$, longTexte = 1
    if s_texte_question_5 <> s_question_5, n$, s_com_open, s_texte_question_5, "-", s_question_5, s_com_close, e$, longTexte = 1
    if s_texte_question_6 <> s_question_6, n$, s_com_open, s_texte_question_6, "-", s_question_6, s_com_close, e$, longTexte = 1
    if s_texte_question_7 <> s_question_7, n$, s_com_open, s_texte_question_7, "-", s_question_7, s_com_close, e$, longTexte = 1
    if s_texte_question_8 <> s_question_8, n$, s_com_open, s_texte_question_8, "-", s_question_8, s_com_close, e$, longTexte = 1
    if s_texte_question_9 <> s_question_9, n$, s_com_open, s_texte_question_9, "-", s_question_9, s_com_close, e$, longTexte = 1
    if s_texte_question_10 <> s_question_10, n$, s_com_open, s_texte_question_10, "-", s_question_10, s_com_close, e$, longTexte = 1
    if s_texte_question_11 <> s_question_11, n$, s_com_open, s_texte_question_11, "-", s_question_11, s_com_close, e$, longTexte = 1
    if s_texte_question_12 <> s_question_12, n$, s_com_open, s_texte_question_12, "-", s_question_12, s_com_close, e$, longTexte = 1
    if s_texte_question_13 <> s_question_13, n$, s_com_open, s_texte_question_13, "-", s_question_13, s_com_close, e$, longTexte = 1
    #
    if s_texte_question_16 <> s_question_16, n$, s_com_open, s_texte_question_16, s_question_16, s_com_close, e$, longTexte = 1
    if s_texte_question_17 <> s_question_17, n$, s_com_open, s_texte_question_17, s_question_17, s_com_close, e$, longTexte = 1
    #n$, s_com_open, "*****************************", s_com_close, e$

#endregion
#region ANCIEN
#  ----------QUESTIONS------------------
spiece      	: ""
snumplan     	: ""
sindiceplan 	: ""
squi         	: ""
sclient     	: ""
sorx         	: ""
sory        	: ""
sorz         	: ""
sor_A_B     	: ""
sorc         	: ""
remplace     	: 1
use_axeA     	: 0

fmt 2 remplace

sclient = ucase(sclient)
spiece = ucase(spiece)
snumplan = ucase(snumplan)
sindiceplan = ucase(sindiceplan)
sorx = ucase(sorx)
sory = ucase(sory)
sorz = ucase(sorz)
sor_A_B = ucase(sor_A_B)

#fq 1 spiece "Nom de la piece"
#fq 2 snumplan "Numero du plan"
#fq 3 squi "Nom du programmeur"
#fq 4 sclient "Nom du client"
#fq 5 sorx "Origine en X"
#fq 6 sory "Origine en Y"
#fq 7 sorz "Origine en Z"
#fq 8 sor_A_B "Origine en A"
#fq 9 sorc "Origine en C"
#fq 10 schange_nom_fichier "Numéro de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"    # progno
#fq 11 remplace "Numéro de programme //snouv_nom// existant, LE REMPLACER ?      0 pour NON - 1 pour OUI"
#fq 12 use_axeA "UTILISER L'AXE A (0=NON 1=OUI)"
#fq 13 sindiceplan "Indice du plan"
#fq 14 useaxe "(pour OP modif) UTILISER L'AXE A ?  0 pour NON 1 pour OUI"

p_entete_questions_3
	q2, q3, q4, #, q8
    n$, "( PAR . xxxx )", e$
    n$, "( CLIENT  .", sclient, s_com_close, e$
    n$, "( PIECE   .", spiece, s_com_close, e$
    n$, "( NUMERO  .", snumplan, s_com_close, e$
    n$, "( INDICE PLAN  :", sindiceplan, s_com_close, e$
    n$, "( ORIGINE :             )", e$
    n$, "( X .", sorx, s_com_close, e$
    n$, "( Y .", sory, s_com_close, e$
    n$, "( Z .", sorz, s_com_close, e$
    n$, "( A_B .", sor_A_B, s_com_close, e$
    n$, "( ORIENTATION PIECE )", e$
    n$, "( )", e$
    n$, "( *****************************)", e$
    n$, "( )", e$

#endregion
#endregion

#region tableaux
#--------- DEFINITION DES TABLEAUX DE STRING -----------------------
# erreurs
serr0   : "err0"
serr1   : "ERREUR - LA FONCTION Ecriture de l'information CN d'opération DOIT ETRE VALIDE DANS LA DEFINITION D'ARMOIRE"
serr2   : "ERREUR - CE POST PRO NE SUPPORTE Q'UN SEUL AXE ROTATIF - VERIFIER LA DEF MACHINE ET LA COMBINAISON D'AXE"
serr3   : "ERREUR - CE POST PRO NE SUPPORTE Q'UNE SEULE COMBINAISON D'AXE PAR PROGRAMME - VERIFIER LA COMBINAISON D'AXE DES OPERATIONS"
serreur : ""
fstrsel serr0 erreur serreur 4 -1
#-------------------------------------------------------
# Mode Absolue ou incremental
sinc00  : "G90"       # Mode Absolue
sinc01  : "G91"       # Mode incremental
sinc02  : ""
sinc_abs : ""
fstrsel sinc00 incremental sinc_abs 3 -1
#-------------------------------------------------------
# Affectation de G0 ... dans sgcode en fonction du GCODE
sg00    : "G0"       # Rapide
sg01    : "G1"       # travail
sg02    : "G2"       # arc horaire
sg03    : "G3"       # arc trigo
sq04    : "G4"       # tempo
sg05    : "G80"      # annulation Cycle Fixes
sgcode  : ""
fstrsel  sg00 gcode$ sgcode 6 -1
#-------------------------------------------------------
# Affectation des plans d'usinage
spl00   : "G17"     # plan XY
spl01   : "G19"     # plan YZ
spl02   : "G18"     # plan XZ
spl03   : ""
splcode : ""
fstrsel  spl00 plane$ splcode 4 -1
#-------------------------------------------------------
# Table de l'affichage du type de corection
stc0        : "CORREC. AUCUNE "
stc1        : "CORREC. ARMOIRE D. "
stc2        : "CORREC. ARMOIRE G. "
stc3        : "CORREC. ORDI. D. "
stc4        : "CORREC. ORDI. G. "
stc5        : "CORREC. USURE D. "
stc6        : "CORREC. USURE G. "
stc7        : "CORREC. USURE INVERSE D. "
stc8        : "CORREC. USURE INVERSE G. "
stc9        : "CORREC. ORDI. 3D "
stype_comp  : ""
fstrsel  stc0 type_comp stype_comp 10 -1
#-------------------------------------------------------
#Drill variables
drlgsel     : -1   #Drill Select Initialize
drillref    : 0     #Select drill reference
peckacel$   : 0     #Fractional percent to reduce peck2 when usecan.. : no
drlgcode    : 0     #Save Gcode in drill
sav_dgcode  : 0     #Drill gcode saved
# Canned drill cycle string select
sg81 : "G81"        #drill      - no dwell
sg81d : "G82"       #drill      - with dwell
sg83 : "G83"        #peck drill - no dwell
sg83d : "G83"       #peck drill - with dwell
sg73 : "G73"        #chip break - no dwell
sg73d : "G73"       #chip break - with dwell
sg84 : "G84"        #tap        - right hand
sg84d : "G74"       #tap        - left hand
sg85 : "G85"        #bore #1    - no dwell
sg85d : "G89"       #bore #1    - with dwell
sg86 : "G86"        #bore #2    - no dwell
sg86d : "G86"       #bore #2    - with dwell
sgm1 : "G76"        #misc #1    - no dwell
sgm1d : "G76"       #misc #1    - with dwell
sgm2 : "G81"        #misc #2    - no dwell
sgm2d : "G82"       #misc #2    - with dwell
sgdrill : ""        #Target for string

fstrsel sg81 drlgsel sgdrill 16 -1
#-------------------------------------------------------
# Reference dEpart de perCages
sg98    : "G98"     #Reference INIT/SECU
sg99    : "G99"     #Reference DEPART
sgdrlref : ""

fstrsel sg98 drillref sgdrlref 2 -1
#-------------------------------------------------------
#   Tables de parametres
# POUR GERER CES PARAMETRES EN VX IL FAUT VALIDER L ECRITURE DANS LA DEF ARMOIRE
# DANS FICHIERS - ECRITURE DE L'INFO CN D'OPERATION
# --------------------------------------------------------------------------
fprmtbl 1    4   # lecture des parametres de surep_XY_2D pour contour et 3D
    10010    surep_XY_2D
    10068    surep_Z_2D
    12665    surep_XY_3D
    12666    surep_Z_3D
    #12068      surep_Z_surf_2D

fprmtbl 19000   2    #Table Number, Size
    19133   stock_shape     #0=RECTANG. 1=CYLIND. 2=SOLIDE 3=FICHIER STL
    19135   stock_cyl_axis  #Stock cylinder axis 0=X,1=Y,2=Z
#endregion

#region commentaires
#------------------- GESTION DES COMMENTAIRES ---------------------------------------
sm0 		: "M0"
fmt	4 affiche_m0
affiche_m0 : -1

pcomment$   # Gestion des commentaires dans le prog
    pcomment2

#pcomment_end$  # post traitement des commentaires
    #if entete = 1, comm_cnt$ = old_comm_cnt                            # pour pouvoir relire les commentaires apres appel de comment dans pheader

pcomment2       #Affichage des commentaire des usinages
    scomm$ = ucase (scomm$)                                             # focer en majuscules
    scomentsprog = svide                                                # mise a zero du commentaire de sous prog
    if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1                                  # si pas de numero de bloc pour commentaires enlever les numeros de bloc
        if debut = 1 & groupe_descripteur > 0, pcomment3
        if gcode$ = 1005, n$, s_com_open, scomm$, s_com_close, e$       # Usinage commentaire - en commentaire
		if entete_ = 0 & gcode$ = 1006, [								# Usinage commentaire - FONCTION CN AVEC NUM. BLOC       
			if scomm$ = sm0 | scomm$ = sm00 & affiche_m0 = 1, 
				[
				n$, scomm$, e$ 
				n$, *spdlon, *ssa, e$
    			old_lubrif = -1
				n$, *scoolantx, e$
				affiche_m0 = 0
				]
			else, n$, scomm$, e$
			]	
		if entete_ = 1 & gcode$ = 1006 & scomm$ <> svide, ptextentete   # pour informer l'entete prog.
        if gcode$ = 1007, n$, s_com_open, scomm$, s_com_close           # Entree Manuelle - en commentaire avec le mouvement sans e$
        #if gcode$ = 1008, scomentsprog = scomm$                        # Nom du sous-prog.
        #if gcode$ = 1008, n$, s_com_open, *op_number, scomm$, s_com_close, e$  #Operation comment using MSG("")
		if gcode$ = 1008, n$, s_com_open, scomm$, s_com_close, e$  			#Operation comment using MSG("") *op_number, 
        if gcode$ = 1026, scomm$										# Entrée manuelle - code avec mouvement - pas de "e$"
        #spaces$ = old_spaces                                           # rappel des espaces
        omitseq$ = old_omitseq                                          # rappel des numero de bloc
        ]

pcomment3   # Affichage des commentaires d'entete de prog /GROUPES/DESCRIPTEUR
    scomm$ = ucase (scomm$)
    if gcode$ = 1051 & (groupe_descripteur = 1 | groupe_descripteur = 5), n$, s_com_open, "MACHINE : ", scomm$, s_com_close, e$     # Nom Machine
    if gcode$ = 1052 & (groupe_descripteur = 2 | groupe_descripteur = 5), n$, s_com_open, scomm$, s_com_close, e$                   # Commentaire de groupe Machine
    if gcode$ = 1053 & (groupe_descripteur = 3 | groupe_descripteur = 5), n$, s_com_open, "GROUPE : ", scomm$, s_com_close, e$      # Nom du Groupe PRINCIPAL Machine
    if gcode$ = 1054 & (groupe_descripteur = 4 | groupe_descripteur = 5), n$, s_com_open, scomm$, s_com_close, e$                   # Descripteur de fichier
    old_comm_cnt = comm_cnt$

pnomgroupe  # Affichage du nom du groupe d'operation
    if affiche_groupe = 1,    [
        if snomgroupe_op <> svide & CN_textes <> 0 & snomgroupe_op <> snomgroupe_op_old,
            [                                       
            if numcoment = 0, omitseq$ = 1                      # si pas de numero de bloc pour commentaires enlever les numeros de bloc
            n$, s_com_open, "*", snomgroupe_op, "*", s_com_close, e$       # nom du groupe d'operation
            omitseq$ = old_omitseq                              # rappel des numero de bloc
            snomgroupe_op_old = snomgroupe_op                   # memo du nom du groupe d'operation
            ]
        ]
#endregion

#region restrictions
#strings
s_coordonnees           : "VEUILLEZ CONTACTER LA SOCIETE FICAM M. Dauvilliers Eric, e.dauvilliers@ficam.com, +33 (0)2 37 26 28 10"
s_erreur_version_MC     : "Ce POST-PROCESSEUR NE PEUT ETRE UTILISE AVEC CETTE VERSION DE MASTERCAM "
s_limite_utilisation    : "ATTENTION **CE POST-PRO n'est valide que jusqu'au :"
s_erreur_num_clee       : "VOTRE NUMERO DE CLEE NE PERMET PAS D'UTILISER CE POST-PROCESSEUR, VEUILLEZ CONTACTER "
s_annEe                 : ""

#pour calculs
Val_annEe_limite        : 0
Val_mois_limite         : 0
Val_Jour_limite         : 0
Val_year_               : 0
Val_month_              : 0
Val_day_                : 0

#formats
fmt         4    restric_version_MC        	# 0/1
fmt         4    restric_num_clEe        	# 0/1
fmt         4    restric_durEe            	# 0/1
fmt "-"     4    jour_                    	# jour limite
fmt "-"     4    mois_                    	# mois limite
fmt "-"     4    annEe_                    	# annEe limite
fmt         4    num_clEe_client

p_restriction_PP
    if sim_no$ <> num_clEe_DEALER,   # CLEE autorisEe
        [
        #restriction VERSION MASTERCAM
        if restric_version_MC = 1, [    #pour info 21 = version MC2019
            if vers_no$ <> restric_version_num, [
                result = mprint(vers_no$)
                result = mprint(restric_version_num)
                result = mprint(s_erreur_version_MC)
                result = mprint(s_coordonnees)
                exitpost$
                ]
            ]
        #restriction en durEe
        #year$ --> 20= 2020
        if restric_durEe = 1,    [
            # "VOIR: ", *year$, *annEe_, *month$, *mois_, *day$, *jour_, e$
            # calcul en jours "du jour ACTUEL"
            Val_year_ = year$ * 100
            Val_month_ = month$ * 30
            Val_day_ = Val_year_ + Val_month_ + day$ # totaux en jours du jour actuel
            # calcul en jours "du jour LIMITE"
            Val_annEe_limite = annEe_    * 100
            Val_mois_limite    = mois_ * 30
            Val_Jour_limite = Val_annEe_limite + Val_mois_limite + jour_

            if Val_day_ > Val_Jour_limite, [
                result = mprint(s_limite_utilisation)
                result = mprint(jour_)
                result = mprint(mois_)
                annEe_ = annEe_ + 2000
                result = mprint(annEe_)
                result = mprint(s_coordonnees)
                exitpost$
                ]
            ]
        #restriction en numero de clEe
        #sim_type$
        if sim_no$ = num_clEe_DEALER, ex$   # CLEE autorisEe
        if sim_no$ <> num_clEe_client & restric_num_clEe = 1, [
            result = mprint(s_erreur_num_clee)
            result = mprint(s_coordonnees)
            exitpost$
            ]
        ]
#endregion

#region pprep_ lecture def armoire et traitememt au debut
pprep$      # affectation des variables avant debut traitememt post pro
    #seqmax$ = seqmax$ - 200        # se reserver les 200 dernier numero de ligne pour faire les sous prog
    #debsousprog = seqmax$          # memo du num de premier sous prog
    rd_mch_ent_no$ = -1             # forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    rd_cd$                          # lecture de la definition armoire
    rd_md$                          # lecture de la definition machine
    rd_tlpathgrp$                   # Lecture des éléments dans "param_read$. outils- BRUT"
    if write_ops = 0, erreur = 1    # Write NC Operation information MUST be enabled in CD
      !erreur
      !serreur
    if erreur <> 0, [
        result = mprint(serreur, 2)
        exitpost$
        ]
    # bloc init post-pro en remplacement de la def armoire
    #pdebug
    if lire_def_machine = 0, p_force_config_pp, p_cycles_valides
    smcpath$ = ucase (smcpath$)     # convertir en MAJUSCULES les noms
    smcname$ = ucase (smcname$)
    smcext$ = ucase(smcext$)
    snamepst$ = ucase (snamepst$)
    snamenc$ = ucase (snamenc$)
	spaces$ = 1
	#Blocs
    seqmax$         = 99999
    omitseq$        = yes$    # no$ = forcer la numerotation des blocs de 10 en 10    yes$ = pas de numérotation
	p_type_tempo

p_cycles_valides    #pour réactivation après renvoie d'angle
    #   UTILISER LES CYCLES MACHINE ou DECOMPOSITION en G1 G0
    # ATTENTION !!!!! PRENDS LE DESSSUS SUR LA DEFINITION DE L'ARMOIRE
    usecandrill$ = yes$       # utiliser cycle percage lamage
    usecanpeck$  = yes$       # utiliser cycle debourrage
    usecanchip$  = yes$       # utiliser cycle brise copeaux
    usecantap$   = yes$       # utiliser cycle taraudage
    usecanbore1$ = yes$       # utiliser cycle alesage a l'alesoir
    usecanbore2$ = yes$       # utiliser cycle alesage a la barre
    usecanmisc1$ = yes$       # utiliser cycle divers 1
    usecanmisc2$ = yes$       # utiliser cycle divers 2

pdebug
    err_file$ = 4
    bug2$ = 60
    fastmode$ =0

psynclath$      #Read NCI Axis-Combination (950) line
    #if lire_def_machine = 1, p_lire_axes    # axes valeur de la def_machine
    p_lire_axes   #Set rotary switches by reading machine def parameters
    #Rotaxtyp$ = 1 sets initial matrix to top
    #Rotaxtyp$ = -2 sets initial matrix to front
    #rotaxtyp$ = 4 donne les valeurs XYZ par rapport au RUD utilisé QUEL QUE SOIT LE PLAN
    #                    XYZ A plat
    #                    XZY EN FACE...
    #if vmc, rotaxtyp$ = one
    #else, rotaxtyp$ = -2

p_force_config_pp
    #REGLAGE ARCS
    # The following three initializations are used for full arc and helix arc output when the CD
    # is set to output R or signed R for arcs
    # 2 = IJ(DELTA DEPART-->Centre du Cercle) ou 5 = R(Rayon du Cercle)
    arctype$        = 2    #Arc center type XY plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé
    arctypexz$      = 2    #Arc center type XZ plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé
    arctypeyz$      = 2    #Arc center type YZ plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé

    breakarcs$      = 1    # Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
    do_full_arc$    = 0    # Allow full circle output? 0=no, 1=yes; 1 POUR LE FILETAGE A LA FRAISE (SUR 360DEG)
    helix_arc$      = 1    # Support helix arc output, 0=no, 1=all planes, 2=XY plane only
    arccheck$       = 1
#endregion

#region lubrifications
sav_coolant     : 0 # Coolant saved
sav_coolant_on  : 0 # XCoolant saved
# --------------------------------------------------------------------------
# Define coolant binary value for X style coolant
flktbl  2       20      #Lookup table definition - table no. - no. entries
        1       50      #Coolant 1 on value
        2       51      #Coolant 1 off value
        4       52      #Coolant 2 on value
        8       53      #Coolant 2 off value
        16      54      #Coolant 3 on value
        32      55      #Coolant 3 off value
        64      56      #Coolant 4 on value
        128     57      #Coolant 4 off value
        256     58      #Coolant 5 on value
        512     59      #Coolant 5 off value
        1024    60      #Coolant 6 on value
        2048    61      #Coolant 6 off value
        4096    62      #Coolant 7 on value
        8192    63      #Coolant 7 off value
        16384   64      #Coolant 8 on value
        32768   65      #Coolant 8 off value
        65536   66      #Coolant 9 on value
        131072  67      #Coolant 9 off value
        262144  68      #Coolant 10 on value
        524288  69      #Coolant 10 off value

#Lubrification Classique et VX
#   Gestion lubrif -0 arret -1 axe outil -2 buse -3 les deux separés du M3 M4
p_lubrif_ON
    lubrif = coolant$
    if v9_coolant & tool_op$ <> 114,     [
        if lubrif > 0,    [
            #if old_lubrif = 0, "M8"
            if lubrif = 1 & old_lubrif <> 1, coolantx = 0, *scoolantx
            if lubrif = 2 & old_lubrif <> 2, coolantx = 2, *scoolantx
            if lubrif = 3 & old_lubrif <> 3, coolantx = 4, *scoolantx
            old_lubrif = lubrif
            ]
        else, if old_lubrif = -1, scool50, lubrif = 1, old_lubrif = 1  #FORCE M08 si pas de lubrif d'actif
        ]
    if v9_coolant = 0, pcan1_cool #X style coolant

pinsp_cool_on   # LUBRIFICATION APRES l' "INSPECTION OUTIL"
      coolant_on = sav_coolant_on
      if v9_coolant, [coolant$ = sav_coolant], e$
      if coolant_on,
        [
        local_int = zero
        coolantx = zero
        while local_int < 20 & coolant_on > 0,
          [
          coolantx = and(2^local_int, coolant_on)
          local_int = local_int + one
          if coolantx > zero,
            [
            coolantx = local_int - one
            p_bloc_O, n$, *scoolantx, e$ #X style coolant on after tool inspection
            ]
          coolantx = zero
          ]
        ]

p_lubrif_OFF
    #if lubrif_complex_on = 1 | tool_op$ = 114, p_lubrif_OFF_VX   # on arrete tout les arrosages
    if v9_coolant & tool_op$ <> 114,     [
        if old_lubrif = 1, coolantx = 1, n$, scoolantx, e$
        if old_lubrif = 2, coolantx = 3, n$, scoolantx, e$
        if old_lubrif = 3, coolantx = 5, n$, scoolantx, e$
        old_lubrif = 0
        ]
    if v9_coolant = 0, pcool_off

pcool_off  #All Coolant off
      sav_coolant = coolant$ #Save V9 coolant
      sav_coolant_on = coolant_on #Save X coolant
      coolant$ = zero
#      if nextop$ = 1003, #Uncomment this line to leave coolant on until eof unless
        [                 #  explicitely turned off through a canned text edit
        if all_cool_off, [
          #all coolant off with a single off code here
          if coolant_on, p_bloc_O, n$, sall_cool_off, e$
          coolant_on = zero
          ]
        else, [
          local_int = zero
          coolantx = zero
          while local_int < 20 & coolant_on > 0, [
            coolantx = and(2^local_int, coolant_on)
            local_int = local_int + one
            if coolantx > zero, [
              coolantx = local_int
              p_bloc_O, n$, scoolantx, e$
              ]
            coolantx = zero
            ]
          coolant_on = zero
          ]
        ]
#endregion

#region Motion output components
# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
bloc_O         : 0      #Block delete active

p_bloc_O                #Canned text - bloc OPTIONNEL
      if bloc_O, '/'

p_f_bloc_O              #Force - le bloc OPTIONNEL
      "/"
#endregion

#region Textes_et_arrosages
#Define Constants
m_one        = -1
zero         = 0
one          = 1
two          = 2
three        = 3
four         = 4
five         = 5
c9k          = 9999

#Coolant variables for X style coolant
cant_pos     : 0     #Read from current canned text (cant_pos1 - cant_pos20)
coolant_bin  : 0     #Binary value for current coolant command
coolant_on   : 0     #Binary value holding the sum of all coolants currently on
coolantx     : 0     #Selector variable for coolant string selector
local_int    : 0     #Local variable for output of coolant off commands
result2      : 0     #Return value for functions
suppress     : 0     #Flag used to suppress redundant coolant on commands
all_cool_off : 0     #SET_BY_MD - First coolant off command shuts off ALL coolant options
v9_coolant   : 0     #SET_BY_MD - Use V9 coolant options - read from General Machine Parameters

#-------------------------------------------------------
#String and string selector definitions for NC output
#-------------------------------------------------------
#Address string definitions
strm         : "M"
strn         : "N"
stro         : "O"
strp         : "P"
srad         : "R"
srminus      : "R-"
sblank       : ""

#Cantext string definitions (spaces must be padded here)
sm00         : "M00"
sm01         : "M01"
strtextno    : ""
strcantext   : ""

# --------------------------------------------------------------------------
# Insertion des Textes / ARROSAGES
# --------------------------------------------------------------------------
pcan            #Insertion des Textes - LIGNE D'AVANT
      strcantext = sblank
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "PCAN : ", *cant_no$, e$
        if cant_pos1$ = zero | cant_pos1$ = three, pcant_1
        if cant_pos2$ = zero | cant_pos2$ = three, pcant_2
        if cant_pos3$ = zero | cant_pos3$ = three, pcant_3
        if cant_pos4$ = zero | cant_pos4$ = three, pcant_4
        if cant_pos5$ = zero | cant_pos5$ = three, pcant_5
        if cant_pos6$ = zero | cant_pos6$ = three, pcant_6
        if cant_pos7$ = zero | cant_pos7$ = three, pcant_7
        if cant_pos8$ = zero | cant_pos8$ = three, pcant_8
        if cant_pos9$ = zero | cant_pos9$ = three, pcant_9
        if cant_pos10$ = zero | cant_pos10$ = three, pcant_10
        if cant_pos11$ = zero | cant_pos11$ = three, pcant_11
        if cant_pos12$ = zero | cant_pos12$ = three, pcant_12
        if cant_pos13$ = zero | cant_pos13$ = three, pcant_13
        if cant_pos14$ = zero | cant_pos14$ = three, pcant_14
        if cant_pos15$ = zero | cant_pos15$ = three, pcant_15
        if cant_pos16$ = zero | cant_pos16$ = three, pcant_16
        if cant_pos17$ = zero | cant_pos17$ = three, pcant_17
        if cant_pos18$ = zero | cant_pos18$ = three, pcant_18
        if cant_pos19$ = zero | cant_pos19$ = three, pcant_19
        if cant_pos20$ = zero | cant_pos20$ = three, pcant_20
        if strcantext <> sblank, p_bloc_O, n$, strcantext, e$
        strcantext = sblank
        ]

pcan1           #Insertion des Textes - AVEC LA LIGNE
      strcantext = sblank
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "PCAN1 1: " *cant_no$, ": ",
        if cant_pos1$  = one, pcant_1
        if cant_pos2$  = one, pcant_2
        if cant_pos3$  = one, pcant_3
        if cant_pos4$  = one, pcant_4
        if cant_pos5$  = one, pcant_5
        if cant_pos6$  = one, pcant_6
        if cant_pos7$  = one, pcant_7
        if cant_pos8$  = one, pcant_8
        if cant_pos9$  = one, pcant_9
        if cant_pos10$ = one, pcant_10
        if cant_pos11$ = one, pcant_11
        if cant_pos12$ = one, pcant_12
        if cant_pos13$ = one, pcant_13
        if cant_pos14$ = one, pcant_14
        if cant_pos15$ = one, pcant_15
        if cant_pos16$ = one, pcant_16
        if cant_pos17$ = one, pcant_17
        if cant_pos18$ = one, pcant_18
        if cant_pos19$ = one, pcant_19
        if cant_pos20$ = one, pcant_20
        ]
      if cstop$, strcantext = strcantext + sm00
      if cgstop$, strcantext = strcantext + sm01
      #Output of strcantext occurs at the end of the output line

pcan1_cool      #Insertion des Textes AVEC l'ARROSAGE - ***SUR LA LIGNE***
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "pcan1_cool : ", *cant_no$, *cant_pos1$, "--", *cantext$, *tool_op$,
        if cant_pos1$  = four, pcant_1
        if cant_pos2$  = four, pcant_2
        if cant_pos3$  = four, pcant_3
        if cant_pos4$  = four, pcant_4
        if cant_pos5$  = four, pcant_5
        if cant_pos6$  = four, pcant_6
        if cant_pos7$  = four, pcant_7
        if cant_pos8$  = four, pcant_8
        if cant_pos9$  = four, pcant_9
        if cant_pos10$ = four, pcant_10
        if cant_pos11$ = four, pcant_11
        if cant_pos12$ = four, pcant_12
        if cant_pos13$ = four, pcant_13
        if cant_pos14$ = four, pcant_14
        if cant_pos15$ = four, pcant_15
        if cant_pos16$ = four, pcant_16
        if cant_pos17$ = four, pcant_17
        if cant_pos18$ = four, pcant_18
        if cant_pos19$ = four, pcant_19
        if cant_pos20$ = four, pcant_20
        ]

pcan2           #Insertion des Textes - APRES LA LIGNE
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two | cant_pos1$ = five, pcant_1
        if cant_pos2$ = two | cant_pos2$ = five, pcant_2
        if cant_pos3$ = two | cant_pos3$ = five, pcant_3
        if cant_pos4$ = two | cant_pos4$ = five, pcant_4
        if cant_pos5$ = two | cant_pos5$ = five, pcant_5
        if cant_pos6$ = two | cant_pos6$ = five, pcant_6
        if cant_pos7$ = two | cant_pos7$ = five, pcant_7
        if cant_pos8$ = two | cant_pos8$ = five, pcant_8
        if cant_pos9$ = two | cant_pos9$ = five, pcant_9
        if cant_pos10$ = two | cant_pos10$ = five, pcant_10
        if cant_pos11$ = two | cant_pos11$ = five, pcant_11
        if cant_pos12$ = two | cant_pos12$ = five, pcant_12
        if cant_pos13$ = two | cant_pos13$ = five, pcant_13
        if cant_pos14$ = two | cant_pos14$ = five, pcant_14
        if cant_pos15$ = two | cant_pos15$ = five, pcant_15
        if cant_pos16$ = two | cant_pos16$ = five, pcant_16
        if cant_pos17$ = two | cant_pos17$ = five, pcant_17
        if cant_pos18$ = two | cant_pos18$ = five, pcant_18
        if cant_pos19$ = two | cant_pos19$ = five, pcant_19
        if cant_pos20$ = two | cant_pos20$ = five, pcant_20
        if Mode_reglage_PP = 0, "pcan2 ", *cant_no$, e$
        if strcantext <> sblank, p_bloc_O, n$, strcantext, e$
        strcantext = sblank
        ]

pcant_1         #Insertion du Texte
      cant_pos = cant_pos1$
      cantext$ = cant_val1$
      pcant_out

pcant_2         #Insertion du Texte
      cant_pos = cant_pos2$
      cantext$ = cant_val2$
      pcant_out

pcant_3         #Insertion du Texte
      cant_pos = cant_pos3$
      cantext$ = cant_val3$
      pcant_out

pcant_4         #Insertion du Texte
      cant_pos = cant_pos4$
      cantext$ = cant_val4$
      pcant_out

pcant_5         #Insertion du Texte
      cant_pos = cant_pos5$
      cantext$ = cant_val5$
      pcant_out

pcant_6         #Insertion du Texte
      cant_pos = cant_pos6$
      cantext$ = cant_val6$
      pcant_out

pcant_7         #Insertion du Texte
      cant_pos = cant_pos7$
      cantext$ = cant_val7$
      pcant_out

pcant_8         #Insertion du Texte
      cant_pos = cant_pos8$
      cantext$ = cant_val8$
      pcant_out

pcant_9         #Insertion du Texte
      cant_pos = cant_pos9$
      cantext$ = cant_val9$
      pcant_out

pcant_10        #Insertion du Texte
      cant_pos = cant_pos10$
      cantext$ = cant_val10$
      pcant_out

pcant_11        #Insertion du Texte
      cant_pos = cant_pos11$
      cantext$ = cant_val11$
      pcant_out

pcant_12        #Insertion du Texte
      cant_pos = cant_pos12$
      cantext$ = cant_val12$
      pcant_out

pcant_13        #Insertion du Texte
      cant_pos = cant_pos13$
      cantext$ = cant_val13$
      pcant_out

pcant_14        #Insertion du Texte
      cant_pos = cant_pos14$
      cantext$ = cant_val14$
      pcant_out

pcant_15        #Insertion du Texte
      cant_pos = cant_pos15$
      cantext$ = cant_val15$
      pcant_out

pcant_16        #Insertion du Texte
      cant_pos = cant_pos16$
      cantext$ = cant_val16$
      pcant_out

pcant_17        #Insertion du Texte
      cant_pos = cant_pos17$
      cantext$ = cant_val17$
      pcant_out

pcant_18        #Insertion du Texte
      cant_pos = cant_pos18$
      cantext$ = cant_val18$
      pcant_out

pcant_19        #Insertion du Texte
      cant_pos = cant_pos19$
      cantext$ = cant_val19$
      pcant_out

pcant_20        #Insertion du Texte
      cant_pos = cant_pos20$
      cantext$ = cant_val20$
      pcant_out

pcant_out       #Canned text - build the string for output
    #Assign string select type outputs
    if Mode_reglage_PP = 0, "cantext 1 : ", *cantext$, " : ", *cant_pos, e$
    if cant_pos < three, #cant_pos indicates canned text output
        [
        if cantext$ = three, bloc_O = one
        if cantext$ = four, bloc_O = zero
        #Build the cantext string
        if cantext$ = one, strcantext = strcantext + sm00
        if cantext$ = two, strcantext = strcantext + sm01
        if cantext$ > four, [                                #-----------LISTE DE TEXTES
          strtextno = no2str(cantext$)
          #strcantext = strcantext + strm + strtextno
          liste_textes = cantext$ #strtextno
          strcantext = s_liste_textes #LISTE DE TEXTES
          #strcantext
          #*cant_pos, "XXXX",
          if cant_pos = 1, s_liste_textes                                        #AVEC
          if cant_pos = 0 | cant_pos = 2, n$, s_liste_textes, s_com_close, e$    #AVANT et APRES
          ]
        ]
    else, #cant_pos indicates coolant output --> ARROSAGES SI cant_pos > 2
        [
        #"ici1 ", e$
        coolant_bin = flook (two, cantext$) #Create binary value for each coolant using lookup table
        if frac(cantext$/two),  # ARROSAGES **OFF**
            [
            if all_cool_off, [
                if coolant_on, p_bloc_O, n$, sall_cool_off, e$
                coolant_on = zero
                ]
            else, [
                #"ici2 ", e$
                if coolant_on > 0, [
                      #"ici3 ", e$
                      coolant_on = coolant_on - coolant_bin/2 #Odd = off command, subtract appropriate binary value.
                      coolantx = cantext$ - 50                #Create a coolantx value for string select
                      p_bloc_O, n$, *scoolantx, e$
                      ]
                ]
            ]
        else, [                    # ARROSAGES **ON**         #Even = on command
            #Determine if this coolant is already on
            local_int = zero
            coolantx = zero
            suppress = zero
            while local_int < 20 & coolant_on > 0, [
                result2 = and(2^local_int, coolant_on)
                local_int = local_int + one
                if result2 = coolant_bin, suppress = one
                ]
            if suppress <> 1, [ #Don't output an on code for a coolant that is already on
                if Mode_reglage_PP = 0, "cantext 2: ", *cantext$, e$
                #"ici4 ", e$
                coolant_on = coolant_on + coolant_bin     #Maintain binary sum of all coolants currently on
                coolantx = cantext$ - 50                  #Create a coolantx value for string select
                if cant_pos = four, *scoolantx            #Coolant "AVEC"
                else, p_bloc_O, n$, *scoolantx, e$      #Coolant "AVANT" ou "APRES"
                ]
            ]
        ]

#endregion

#region Temps
p_temps_affectation
	Types_Temps_DLL_1 = plcval (s_Types_Temps_DLL, info_temps) 
	if Types_Temps_DLL_1 = 1, Types_Temps_DLL = info_temps	# pour rester dans le format 654321

p_temps_dll		#temps DLL
	if Affiche_temps_dll = 1, [	#évite également les messages si pas de DLL
	    sOpId = no2str(op_id$)
	    result = dll(sdllTimeOp,sOpId)
	    timeOp = rpar(spost_arg_1$,1)
	    #timeTT = timeTT + timeOp
	    strtool$ = ucase(strtool$)
		]

p_Convert_time_dll
    # pour info "timeTT" est en secondes
	# tlchg_time = temps de changement d'outil dans la def machine
	@Types_Temps_DLL
		
	if Types_Temps_DLL > 3, [
		# / OUTIL ne pas additionner juste avant l'affichage	
		if Types_Temps_DLL <> 5, Tot_time_Out = Tot_time_Out + timeOp			
		# / TOTAL FIN 
		if Types_Temps_DLL <> 5 & Types_Temps_DLL <> 6, time_total = time_total + timeOp
		]	
	
	# NON CORRIGE EN ENTETE
	if Types_Temps_DLL < 4, [
		
		]
	
	if Types_Temps_DLL = 3, Tot_time_op = timeTT 		# / TOTAL 
	if Types_Temps_DLL = 2, Tot_time_op = Tot_time_Out	# / par OUTIL 	
	if Types_Temps_DLL = 1, Tot_time_op = timeOp		# / par OPERATION
	#
	
	# CORRIGE DANS LE CORPS
	time_correction_op = (coefficient_G0/10) * nbr_correct_XY_G0_time	# nbr de G0
	time_correction_op = time_correction_op  + correc_dwell_time		# ajout des tempos 
	#"VOIR : " *time_correction_op, e$
	if Types_Temps_DLL = 4, [							# / OP
		Tot_time_op = timeOp
		Tot_time_op = Tot_time_op + time_correction_op
		#"VOIR OP en S: ", *timeOp, e$ 
		]	
	if Types_Temps_DLL = 5, [							# / OUTIL
		Tot_time_op = Tot_time_Out + Temps_chang_outil + time_correction_op
		Tot_time_Out = 0
		#"VOIR OUTIL en S: ", *Tot_time_op, *Tot_time_Out, *Temps_chang_outil, e$  
		]
	if Types_Temps_DLL = 6, [							# / FIN					
		Temps_chang_outil = Temps_chang_outil * Nbr_outils 
		Tot_time_op = (time_total + time_correction_op) + Temps_chang_outil
		#"VOIR : ", *time_total, " ", *Tot_time_op, "Nbr de passages :", *nbr_correct_XY_G0_time, *time_correction_op, " T CH out :", *Temps_chang_outil, e$
		#"VOIR TOTAL en S: ", *Tot_time_op, e$ 
		]	
		
	Time_hrs = Tot_time_op / 3600	#xx.yy
	Time_min = Time_hrs 			# --> mem
	Time_hrs = int(Time_hrs)		#xx		H
	
	Time_min = frac(Time_min)		#0.xx	M
	Time_min = Time_min * 60		#xx.yy 	M
	Time_min = int(Time_min)		#xx		M	
	
	Time_sec = Tot_time_op / 60		#yy.xx 	S
	Time_sec = frac(Time_sec)		#0.xx 	S
	Time_sec = Time_sec * 60		#xx.yy	S
	Time_sec = int(Time_sec)		#xx		S
	    	
	Heure = Time_hrs
	Heure = int(Heure)
	min = Time_min
	min = int(min)
	sec = Time_sec
	sec = int(sec)

p_correc_time_G0
	if drillcyc$ < 0, nbr_correct_XY_G0_time = nbr_correct_XY_G0_time + 1
	if drillcyc$ >= 0, [
		prof_temps = drl_depth_z$ - drl_sel_ref$	# Z matière -->drl_sel_tos$	# Profondeur
		prof_temps = abs(prof_temps)
		if peck1$ > 0, div_prof_temps = int(prof_temps/peck1$) 
		if peck1$ > 0, nbr_correct_XY_G0_time = nbr_correct_XY_G0_time + int(prof_temps/peck1$) 
		if dwell$ <> 0, correc_dwell_time = correc_dwell_time + (dwell$ * div_prof_temps) 	# temps en plus par profondeur de débourrage/brise-copeaux tempo
		#"VOIR :", *prof_temps, " ", *nbr_correct_XY_G0_time, " ", *correc_dwell_time, " ", *dwell$, e$
		]	
		
#endregion

#region pmachineinfo_ lecture des parametres de def armoire et def machine
# Machine Definition Parameters
fprmtbl 17000   11   #13 Table Number, Size
#   Param   Variable to load value into
    17391   axis_label   #Axis label - 1=X,2=Y,3=Z
    17397   srot_label   #Rotary Axis label (Generally A, B or C) - Not yet available.
    17401   rot_zero     #Rotary zero degree position
    17402   rot_dir      #Rotary direction
    17408   rot_index    #Index or continuous
    17409   rot_angle    #Index step
    17410   rot_type     #M3/M4 Rotary type
    17605   min_speed    #50 tr/min Minimum spindle speed
    #17066   maxfrinv_m  #Maximum feedrate - inverse time - metric - Minimum value from MD as this is inverse time
    #17933   maxfrdeg    #Maximum feedrate deg/min
    17063   maxfeedpm_m  #Limit for feed in mm/min
    17101   all_cool_off #First coolant off command shuts off ALL coolant options
    17102   v9_coolant   #Use V9 coolant option

fprmtbl 18000   2           # Lecture des Param de def armoire
    18171   write_ops       # Autoriser l'ecriture de l'information CN d'operation
    18458   CN_textes       # Nombre de caracteres pour les commentaires
    #18713   sous_prog_type  # type de merge des sous prog (0 apres prog principal 1 avant)
    #18705   cor_arc         # compensation sur les arcs autorisee

#---------------- BLOCS DE DEF MACHINE ET DEF ARMOIRE ---------------------------------
pmachineinfo$    # lecture des parametre de def armoire et def machine
    #rd_md is used to call pmachineinfo postblock and read the parameters of the selected axis
    #combination machine entity set in rd_mch_ent_no
    #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
    #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters

    if affiche_prmcodes = 0, "-->pmachineinfo DONNEES MACHINE ", ~prmcode$, "=", sparameter$, e$        # pour afficher tous les parametres

    #if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$
    #if prmcode$ = 18458, "nombre de caracteres de commentaire",  sparameter$, e$
    #if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$         # Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$
    #if prmcode$ = 17201, *prmcode$, "nom de l'element =", sparameter$, e$

    if prmcode$ = 17063, fmaxi = rpar(sparameter$, 1)               # avance maxi en G1
    if prmcode$ = 17062, fmini = rpar(sparameter$, 1)               # avance mini en G1
    if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000)   # Run the parameter table for Machine Definition Parameters
    if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000)   # Lecture de la table de parametre Control Definition
    if prmcode$ >= 19000 & prmcode$ < 19900, result = fprm(19000)   # Run the parameter table for Toolpath Group Parameters
    if prmcode$ = 17012, s_nom_machine_entete = ucase(sparameter$)  # Nom de la machine
    #if prmcode$ = 17201,        [                                   # nom du composant
        #if ucase(sparameter$) = spalette, palette = 1               # si c'est une palette, activer la gestion de palette
        #]
    if prmcode$ = 19958,        [                                   # type de composant  5 = axe rotatif
        type_composant = rpar(sparameter$, 1)
            if type_composant = 5,  [                               # si c'est un axe rotatif
            #useaxe = 1                                                #--> oui mais pas forcément utilisé
            compt_axes_rot  = compt_axes_rot + 1                    # compter le nombre d'axes rotatif
            ]
        ]
    # AXE DE ROTATION UTILISé --> la configuration machine doit Etre dEfinie correctement
    #Direction de l'axe Z - Vers Y = ROTATION AXE A / Vers X = ROTATION AXE B
      if prmcode$ = 17392 & axis_label = 3, [
        Z_dir = rpar(sparameter$, 1)  #Z axis direction - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
        if Z_dir <> 3 & Z_dir <> 9, #vmc = 0   #0 = Horizontal Machine, 1 = Vertical Mill
        else, #vmc = 1
        ]
    if prmcode$ = 17399,    [                                       # AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
        diviseur = rpar(sparameter$, 1)
        if diviseur > 3, diviseur = diviseur - 6                    # ne garder que x y z
        ]
    if prmcode$ = 17402,    [                                       # sens de l'axe rotatif -1=trigo 1=horaire
        sens_AB = rpar(sparameter$, 1)
        if sens_AB = 0, sens_AB = 1                               # variable sens pour le post pro
        else, sens_AB = -1
        ]
	if prmcode$ = 17598, nbr_outil = rpar(sparameter$, 1)           # nombre d'outils du changeur de la def machine
    if prmcode$ = 17932, s_axe_rot_label = sparameter$              # 17391 AXE rotatif (ABC) (NOM DE L'axe -- PAS le LABEL)	
	if prmcode$ = 17921, fr_rapid_mach = rpar(sparameter$, 1)     	# ou 17925 avance rapide de la machine     
	if prmcode$ = 17597, tlchg_time = rpar(sparameter$, 1)    		# temps de changement d'outil de la machine
	
p_lire_axes   # Lecture des parametres de la combinaison d'axes uniquement
    #"p_lire_axes", e$
    if syncaxis$ <> old_syncaxis, [
        compt_axes_rot = 0
        erreur = 0
        ]
    rd_mch_ent_no$ = syncaxis$                  # pour avoir les infos de la conbinaison d'axe utilisée
    #rd_mch_ent_no$ = -2                        # forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    #rd_cd$                                     # lecture de la def armoire
    if lire_def_machine = 1, rd_md$             # lecture de la def machine
    result = nwadrs(s_axe_rot_label, axe_AB)      # affectation du nom de l'axe rotatif en ABS
    #s_axe_rot_label = "I" + s_axe_rot_label    # affectation du nom de l'axe rotatif en INC
    #result = nwadrs(s_axe_rot_label, axe_ABi)    # affectation du nom de l'axe rotatif en INC
    p_test_machine
    old_syncaxis = syncaxis$

p_test_machine    # verif de la def machine
    #*nbr_combi, "---------", e$
    if nbr_combi > 1, erreur = 3            	# le pst ne supporte q'une combinaison d'axe par programme
    if compt_axes_rot > 1, erreur = 2       	# le pst ne supporte q'un axe rotaif
    #if write_ops = 0, erreur = 1            	# Write NC Operation information MUST be enabled in CD
    #p_erreur

p_erreur
    !erreur
    !serreur
    if erreur <> 0, [
        if erreur = 4 & testerreur4 = 0, [
            serreur2 = serreur + no2str(increment_op_outil)
            result = mprint(serreur2, 3)
            if result = 3, serreur2 , e$, exitpost$     # abandonner
            if result = 4, serreur2                     # recommencer
            if result = 5, testerreur4 = 1              # ignorer
            ]
        if erreur <> 4, [
            result = mprint(s_erreur_nbr_axes_rot, 2)
            exitpost$
            ]
        ]

p_affiche_infos_config_armoire
    #affichage des prmcode$
    if Mode_reglage_PP = 0, [
        "***INFOS DONNEES -CONFIG DE LA MACHINE-***", e$
        "fmaxi: ", *fmaxi, e$
        "fmini: ", *fmini, e$
        "smachine: ", s_nom_machine_entete, e$
        "spalette: ", spalette, e$
        "type_composant ", *type_composant, e$
        "INFOS CONFIG GROUPE MACHINE : diviseur +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9: : ", *diviseur, e$
        "sens de l'axe rotatif 0=trigo 1=horaire: ", *sens_AB, e$
        "nbr_outil: ", *nbr_outil, e$
        "s_axe_rot_label NOM: ", s_axe_rot_label, e$
        ]
#endregion

#region pparameter_ lecture parametres d'OP
pparameter$
    #rd_params is used to call pparameter postblock and read the parameters of the operation specified in rd_param_op_no
    if affiche_prmcodes = 0, "-->pparameter DONNEES OPERATIONS ", ~prmcode$, "=", ~sparameter$, e$        # pour afficher tous les parametres

    #if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$
    #if prmcode$ = 18458, "nombre de caracteres de commentaire",  sparameter$, e$
    #if prmcode$ = 19958, *prmcode$, "type de composant", "=", sparameter$, e$      # type de composant 5 = axe rotatif
    #if prmcode$ = 17399, *prmcode$, "AXE DE L'AXE ROTATIF", "=", sparameter$, e$   # AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17402, *prmcode$, "sens de laxe", "=", sparameter$, e$           # sens de l'axe rotatif 0=trigo 1=horaire
    #if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$             # Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$
    #if prmcode$ = 17201, *prmcode$, "nom de l'element =", sparameter$, e$

    if prmcode$ = 10030, F_USI_prmcode = rpar(sparameter$, 1)
	if prmcode$ = 10031, F_plongee = rpar(sparameter$, 1) 
    #if prmcode$ = 10100, _scycle = rpar(sparameter$, 1)
    if prmcode$ = 12068, surep_Z_surf_2D  = rpar(sparameter$, 1)
	if prmcode$ = 15140, F_retract = rpar(sparameter$, 1)
	if prmcode$ = 12718, F_G1_ugv_2D   = rpar(sparameter$, 1)
	if prmcode$ = 12662, F_G1_ugv_3D   = rpar(sparameter$, 1)
    if prmcode$ = 12194, pas_filetage = rpar(sparameter$, 1)    # "valeur du pas du filetage à la fraise"
    if prmcode$ = 15163, Val_origine_Z = rpar(sparameter$, 1)   # "valeur de l'origine MC en Z"
    if prmcode$ = 15164, Val_origine_Y = rpar(sparameter$, 1)   # "valeur de l'origine MC en Y"
    if prmcode$ = 15165, Val_origine_X = rpar(sparameter$, 1)   # "valeur de l'origine MC en X"
    if prmcode$ = 15166, workofs_ = rpar(sparameter$, 1)        # 15166=Val origine de base
                                                                # 15181=Val Numéro de l'origine actif
                                                                # 15333=Val départ incrément, op transformation
    if prmcode$ = 15334, workofs_dec = rpar(sparameter$, 1)		# 15334=Val incrément, op transformation 
    if prmcode$ = 15240, op_number = rparsngl(sparameter$, 1)   # Numéro OP MC réelle
    #if prmcode$ = 15346, Type_Comp_OP = rpar(sparameter$, 1)   # Type de compensation outil par OP / 0=ORDI 1=ARMOIRE 2=USURE 3=USURE inverse 4=SANS
    if prmcode$ = 15887, zone_secu = rpar(sparameter$, 1)		# zone de transition 
	if prmcode$ = 20002, smanu = sparameter$
    if prmcode$ = 20002, long_smanu = strlen(smanu)
    if prmcode$ = 20003, smand = ucase(sparameter$)             # smontage
    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)        # lecture des parametres d'outil
    if prmcode$ = 20007, paramT20 = rpar(sparameter$, 11)       # lit les param. avec l'épaisseur
    if prmcode$ = 20018, snomgroupe_op = ucase (sparameter$)    # Lecture du nom de groupe d'usinage
    if prmcode$ = 20011, sinfo_origine = sparameter$
    if prmcode$ = 20014, snom_RUD = sparameter$
	if prmcode$ = 40270, F_micro_remontee = rpar(sparameter$, 1)#
	if prmcode$ = 15071, usecanDRILL = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGE
	if prmcode$ = 15072, usecanPECK = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGE/deb
    if prmcode$ = 15073, usecanCHIP = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGES/brise copeaux
	if prmcode$ = 15074, perc_1er_perc_pour_C_ou_mm = rpar(sparameter$, 1)	# CHOIX DU MODE - Valeur de la 1ère plongée en % ou MM (& décomposé) 
	if prmcode$ = 15075, perc_Val_pour_Cent_mm = rpar(sparameter$, 1)		# VALEUR de la 1ère plongée en % ou MM (& décomposé) 	
	if prmcode$ = 15076, perc_AVANCE_pour_Cent_mm = rpar(sparameter$, 1)	# VALEUR de l'avance de la 1ère plongée en % ou MM (& décomposé) 
	
	if opcode$ <> 19, result = fprm (1)                         # lecture des parametres de surep_XY_2D pour surfacage
    if opcode$ = 19, result = fprm (2)                          # lecture des parametres de surep_XY_2D pour contour et 3D

#endregion

#region sous_programmes
p_info_sous_prog
    if Mode_reglage_PP = 0, [
        n$, "num du sous-prog. : ", *main_prg_no$, e$
		n$, "NOM du sous-prog. : ", *sub_prg_no$, e$ 
		n$, "ID du sous-prog. : ", *sub_trns_id$, e$ 
		n$, "num de la chaine : ", *sub_chn_no$, e$ 
		n$, "Absolu ou relatif : ", *sub_inc$, e$
        n$, "(PASSE ", *sub_sec_no$, "SUR ", *sub_totl_no$, ")", e$
        "Subprogram number :", *sub_op_id$, e$
        "Actual operation ID :", *sub_grp_id$, e$
        "Transform/non-transform indicator :", *sub_ref_id$, e$
        "Iteration counter :", *sub_sec_no$, e$
        "Total number of instances :", sub_totl_no$, e$
        "0=mirror, 1=rotate, 2=scale, 3=translate :", *sub_trnstyp$, e$
        "(mirror) - 0=X axis, 1=Y axis, 2=line :", *sub_trnmthd$, e$
        "(rotate) - 0=tplane, 1=tplane origin only, 2=coordinates :", *sub_trnmthd$, e$
        *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, *sub_nxt_t$, *sub_nxt_h$, *sub_nxt_tid$, *sub_mny_t$, e$
        *wdum3$, "----", *rcc_flg$, *sub_prg_no$, *subout$, *sub_level$, *absinc$, e$
        ]

#---------------- BLOCS DE TRAITEMENT DES SOUS-PROG EN Z ---------------------------------
psub_call_s$       # appel sous prog en Z
    !sub_prg_no$                            	# mise a jour du numero interne de sous prog en Z
    subprognum = debsousprog + sub_prg_no$  	# affectation du numero de sous prog en Z
    nprincipal = n$  + seqinc$              	# memo du numero de ligne pour le rappel dans le sous-programme
    #*nprincipal, e$                        	# affecation du parametre CN pour memo du numéro de ligne
    subprognum = (progno_ *100) + subprognum
	if sub_sec_no$ = 1, n$, s_com_open, "APPEL SOUS-PROGRAMME", s_com_close, e$
    if sub_sec_no$ = 1, n$, s_com_open, "PASSES EN Z", s_com_close, e$
	n$, s_com_open, "PASSE ", sub_sec_no$, "SUR ", sub_totl_no$, "EN Z", s_com_close, e$
	n$, "M98", subprognum, e$               	# appel du sous prog
    nprincipal = n$                         	# memo du numero de ligne pour le prog principal

psub_st_s$    # écriture de l'entete de sous prog en Z
    !sub_prg_no$                            	# mise a jour du numero interne de sous prog en Z
    numsubprog = debsousprog + sub_prg_no$  	# affectation du numero de sous prog en Z
    nomsubprog = numsubprog                 	# affectation du nom de sous prog en Z
    memo_incremental = incremental          	# memorisation du mode ABS INC Actuel
    incremental = sub_inc$                  	# Sous prog en incremental ou absolue
    numsubprog = (progno_ *100) + numsubprog
    #n$ = 10                                 	# numero de ligne de sous prog
    #"%", e$
    numsubprog_ = numsubprog
    if incremental = 1, p_casse_modalite    	# casser la modalité xyz pour les sous prog en relatif
    p_casse_modalite_avance                		# casser la modalité le l'avance pour les sous prog
    omitseq$ = 1                            	# pas du numero de ligne pour les sous prog
    if CN_textes <> 0,   [                  	# entete avec commentaires
        #old_spaces = spaces$
        #spaces$ = 0
        if scomentsprog <> svide, [
            if Type_progno = 1, *numsubprog     # Oxxxx
            if Type_progno = 2, *numsubprog_    # :xxxx
                space, s_com_open, scomentsprog, s_com_close, e$
            ]
        else, [                               	# entete sans commentaires
            if Type_progno = 1, *numsubprog, e$ # Oxxxx
            if Type_progno = 2, *numsubprog_, e$# :xxxx
            ]
        #spaces$ = old_spaces
        n$, s_com_open, "DE : ", *progno_, s_com_close, e$
        n$, s_com_open, "FICHIER : ", *smcname$, s_com_close, e$
        n$, "( SOUS-PROGRAMME EN -Z-)", e$
        ]
    else,   [                               	# entete sans commentaires
        if Type_progno = 1, *numsubprog, e$     # Oxxxx
        if Type_progno = 2, *numsubprog_, e$    # :xxxx
        ]
    n$, s_com_open, strtool$, s_com_close, e$
    n$, *sinc_abs, e$                       	# écrire si sous prog en ABS ou INC
    gcode$ = 5                              	# pour forcer l'ecriture de code G du premier bloc du sous prog
    !gcode$

psub_end_s$    # fin sous prog en Z
    incremental = memo_incremental  			# rappel du mode INC ABS precedent
    n$, *sinc_abs, e$
    #n, "M99", "P#100", e$          			# fermeture de sous prog
    n$, "M99", e$                   			# fermeture de sous prog
    n$, " ", e$
    n$, " ", e$
    omitseq$ = old_omitseq
    n$ = nprincipal                 			# recuperation du numero de ligne pour prog principal

#-------------------------BLOCS DE TRAITEMENT DES SOUS PROG EN TRANSFORMER ---------------------------
ptranslation    # pour usinage transformer en translation
    if sub_trnsx$ = 0 & sub_trnsy$ = 0 & sub_trnsz$ = 0,   [   # si pas de decalage, ne rien faire
		# 										si pas de decalage, ne rien faire
        #n$ "; SANS TRANSLATION ADDITIVE", e$
        ]
    else, [                         			# si decalage, ecriture du G52
        memo_incremental = incremental
        incremental = 0
        n$, " ", e$
        n$, *sgcode, *sinc_abs, *xrp, *yrp, e$
        #n$, "(FAIRE UN DECALGE G52)", e$
        #n$, sinc_abs, "G52", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$   # ecriture des valeur de decalage d'origine
        decalage = 1                            # memo de mise en place de decalage pour l'annuler
        incremental= memo_incremental
        n$, sinc_abs, e$
        ]

psub_mirror     #Mirror start code, user
    #Mirror Y axis
    #if sub_trnmthd$, pbld, n$, *sgabsinc, strns_mir_on, *sub_trnsx$, e$
    #Mirror X axis
    #else, pbld, n$, *sgabsinc, strns_mir_on, *sub_trnsy$, e$
    n$, " A CREER -SOUS PROG MIRROIR-", e$

psub_rotate     #Rotate start code, user
    #n$, *sgcode, *sinc_abs, *sub_trnsx$, *sub_trnsy$,
    #[absinc$ = one], *sgabsinc, e$
    memo_incremental = incremental
    incremental = 0
    n$, " ", e$
    n$, *sgcode, *sinc_abs, *xrp, *yrp, e$
    #n$, "(FAIRE UN DECALGE G52)", e
    #n$, sinc_abs, "G52", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$   # ecriture des valeur de decalage d'origine
    decalage = 1                            	# memo de mise en place de decalage pour l'annuler
    incremental= memo_incremental
    n$, sinc_abs, e$

s_sous_p_en_ABSOLU_HS	: "ATTENTION ! Les sous-programmes doivent être en RELATIF autrement il va y avoir des parcours en trop ! PASSEZ EN mode RELATIF"
p_type_sous_prog
    if sub_trnstyp$ <> old_sub_trnstyp, [   	
		n$, s_com_open, "APPEL SOUS-PROGRAMME ", s_com_close, e$
		if sub_trnstyp$ = 0, n$, s_com_open, "TRANSFORMATION PAR MIRROIR ", s_com_close, e$
		if sub_trnstyp$ = 1, n$, s_com_open, "TRANSFORMATION PAR ROTATION ", s_com_close, e$
		if sub_trnstyp$ = 2, n$, s_com_open, "TRANSFORMATION PAR ECHELLE ", s_com_close, e$
		if sub_trnstyp$ = 3, n$, s_com_open, "TRANSFORMATION PAR TRANSLATION ", s_com_close, e$
		]
	if sub_inc$ = 0, result = mprint(s_sous_p_en_ABSOLU_HS)

psub_call_mm$     # appel sous prog en transformation pour outils multiples
    p_info_sous_prog
    #"appel sous prog en transformation pour outils multiples", e$
    !main_prg_no$                                   # mise a jour du numero interne de sous prog en transformation pour outils multiples
    subprognum = debsousprog + main_prg_no$ +100    # affectation du numero de sous prog
    nprincipal = n$  + seqinc$                      # memo du numero de ligne pour le rappel dans le sous-programme
    if sub_trnstyp$ = 3, ptranslation              	# si on fait de la translation aller avant dans bloc ecriture decalage origine
    if sub_trnstyp$ = 2, psub_mirror
    if sub_trnstyp$ = 1, psub_rotate
    p_type_sous_prog
    if sub_trnstyp$ <> old_sub_trnstyp, n$, "( AVEC OUTILS MULTIPLES )", e$
    n$, "M98", subprognum, e$                       # appel du sous prog
    nprincipal = n$                                 # memo du numero de ligne pour le prog principal
	old_sub_trnstyp = sub_trnstyp$               
	
psub_call_m$   # appel sous prog en transformation pour outil unique
    p_info_sous_prog
    #"appel sous prog en transformation", e$
    !main_prg_no$                                   # mise a jour du numero interne de sous prog en transformation pour outils multiples
    subprognum = debsousprog + main_prg_no$ +100    # affectation du numero de sous prog
    if sub_trnstyp$ = 3, ptranslation              	# si on fait de la translation aller avant dans bloc ecriture decalage orignie
    if sub_trnstyp$ = 2, psub_mirror
    if sub_trnstyp$ = 1, psub_rotate
    nprincipal = n$  + seqinc$                      # memo du numero de ligne pour le rappel dans le sous-programme
    p_type_sous_prog
    if sub_trnstyp$ <> old_sub_trnstyp, n$, "( AVEC UN SEUL OUTIL )", e$                # affecation du parametre CN pour memo du numéro de ligne
    n$, "M98", subprognum, e$                       # appel du sous prog
    nprincipal = n$                                 # memo du numero de ligne pour le prog principal
	old_sub_trnstyp = sub_trnstyp$                  

psub_end_m_r$    # bloc system non explique dans doc des PST (a voir)
	#NESTING
    #n$, "( TEST - psub_end_m_r$)", e$

psub_st_m$    # entete sous prog en transformation
    !main_prg_no$                           		# mise a jour du numero interne de sous prog en transformation pour outils multiples
    numsubprog = debsousprog + main_prg_no$ +100    # affectation du numero de sous prog
    nomsubprog = numsubprog                 		# affectation du nom de sous prog en Z
    memo_incremental = incremental          		# memorisation du mode ABS INC Actuel
	# **** VOLONTAIREMENT PAS DE DEPLACEMENTS EN MODE RELATIF **** UTILISE ET force en ABSOLU SUITE A un PROBLEME de REPETITION 
    #incremental = sub_inc$                  		# Sous prog en incremental ou absolue
	# ****
    #n$ = 10                                		# numero de ligne de sous prog
    #"%", e$
    numsubprog_ = numsubprog
    if incremental = 1, p_casse_modalite    		# casser la modalité pour les sous prog en relatif
    p_casse_modalite_avance                 		# casser la modalité le l'avance pour les sous prog
    omitseq$ = 1                            		# pas du numero de ligne pour les sous prog
    if CN_textes <> 0,   [                  		# entete avec commentaires
        #old_spaces = spaces$
        #spaces$ = 0
        if scomentsprog <> svide, [
            if Type_progno = 1, *numsubprog     	# Oxxxx
            if Type_progno = 2, *numsubprog_    	# :xxxx
                space, s_com_open, scomentsprog, s_com_close, e$
            ]
        else, [                               		# entete sans commentaires
            if Type_progno = 1, *numsubprog, e$     # Oxxxx
            if Type_progno = 2, *numsubprog_, e$    # :xxxx
            ]
        n$, s_com_open, "DE : ", *progno_, s_com_close, e$
        n$, s_com_open, "FICHIER : ", *smcname$, s_com_close, e$
        n$, "(SOUS-PROGRAMME PAR -TRANSFORMATION-)", e$
        #spaces$ = old_spaces
        ]
    else,       [                           		# entete sans commentaires
        if Type_progno = 1, *numsubprog, e$     	# Oxxxx
        if Type_progno = 2, *numsubprog_, e$    	# :xxxx
        ]
    n$, s_com_open, strtool$, s_com_close, e$
    n$, *sinc_abs, e$                       		# ecrire si sous prog en ABS ou INC
    gcode$ = 5                              		# pour forcer l'ecriture de code G du premier bloc du sous prog
    !gcode$

psub_end_m$   # fin sous prog en transformation
    incremental = memo_incremental          		# rappel du mode INC ABS precedent
    if incremental = 1 ,n$, "G90", e$
    #n, "M99", "P#100", e$                  		# fermeture de sous prog
    n$, "M99", e$                           		# fermeture de sous prog
    n$, " ", e$
    omitseq$ = old_omitseq
    n$ = nprincipal                         		# recuperation du numero de ligne pour prog principal
#endregion

#region CALCUL & AFFICHAGE EN POSITIONNE
prot0$  #   Tool plan view matrix du gcode 1014
prot$

p_calcul_rot_posit   # calcul de l'axe A en positionné
    @old_axe_AB, @nbrtour
    if diviseur = 1, axe_AB = atan2(m8$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de X
    if diviseur = 2, axe_AB = atan2(m7$,m9$) + (360 * nbrtour)    # pour diviseur tourne autour de Y
    axe_AB = axe_AB * sens_AB                                      # prise en compte du sens de rotation
    epsi = axe_AB - old_axe_AB                                      # variation angulaire
    sensA = 0
    if epsi > 0, sensA = 1                                      # sens de la variation
    if epsi < 0, sensA = -1
    if Mode_reglage_PP = 0, n$, "epsi", *epsi, "sensA", *sensA, "nbrtour", *nbrtour, e$
    epsi = abs(epsi)
    @epsi, @sensA                                               # mise a jour
    if epsi > 180,  [                                           # optimisation de l'angle
        axe_AB = axe_AB - (360 * sensA)
        epsi = axe_AB - old_axe_AB
        sensA = 0
        if epsi > 0, sensA = 1
        if epsi < 0, sensA = -1
        ]
    nbrtour = int (axe_AB / 360)                                  # Calcul du nombre de tour
    if axe_AB >90, axe_AB = axe_AB - 360
    memo_AB_subs = axe_AB
    if Mode_reglage_PP = 0,  "--> p_calcul_rot_posit div:", *diviseur, "old:", *old_axe_AB, "axe:", *axe_AB, "epsi:", *epsi, "sens:", *sensA, "nbrTour:", *nbrtour, *memo_AB_subs, e$

p_rot_ptlchg   # affichage de l'angle au changement d'outil pour positionné
    if Mode_reglage_PP = 0, n$, "--> p_rot_ptlchg", e$
    #Perreur_origine_plan
    Perreur_nom_RUD
    if ra_type$ = 0, perreur_transf_plan   # pas de broche à RENVOIE d'ANGLE
    if useaxe <> 0, [                                           # afficher les angles que si machine avec Axe A/B
        @old_axe_AB, @axe_AB                                        # rappel
        #epsi = old_axe_AB - axe_AB                                 # regarder si on tourne
        #epsi = abs(epsi)
        if Mode_reglage_PP = 0, n$, "--> p_rot_ptlchg", "old:", *old_axe_AB, "axe:", *axe_AB, "epsi:", *epsi, e$
        #if epsi <> 0,    [                                     # si ca tourne
            if mi7$ = 1, bloque = 2, n$, sbloque, e$            # déblocage de l'axe A/B
            p_affiche_type_rot
            if mi7$ = 1, bloque = 1, n$, sbloque, e$            # bloquer l'axe A/B
            #]
       ]
    old_axe_AB = axe_AB         # memo de la position de l'axe A affiché

p_rot_tlchg0   # affichage de l'angle au changement d'outil nul pour positionné
    #Perreur_origine_plan
    Perreur_nom_RUD
    if ra_type$ = 0, perreur_transf_plan   # pas de broche à RENVOIE d'ANGLE
    if useaxe <> 0 | opcode$ = 16, [                            # afficher les angles que si machine avec Axe A/B
        @old_axe_AB, @axe_AB                                    # rappel
        epsi = old_axe_AB - axe_AB                              # regarder si on tourne
        epsi = abs(epsi)
        if Mode_reglage_PP = 0, n$, "--> p_rot_tlchg0 ", "old:", *old_axe_AB, "axe:", *axe_AB, "epsi:", *epsi, *useaxe, e$
		if epsi <> 0,    [                                  	# si ca tourne
            rot_tlchg_zero = 1
            xabs = x$                                       	# reprendre les positions xyz avant le dégagement
            yabs = y$
            zabs = z$
            p_degage_4_axes                                 	# Dégagement machine avant la rotation de l'axe A
            if mi7$ = 1, bloque = 2, n$, sbloque, e$        	# déblocage de l'axe A/B
            p_affiche_type_rot
            if mi7$ = 1, bloque = 1, n$, sbloque, e$        	# blocage de l'axe A/B
            gcode$ = 0
            if incremental = 0, [                           	# Rappel des positions XYZ avant le dégagement         
				xabs = xr$
				yabs = yr$ 
				if xabs <> prv_xabs | yabs <> prv_yabs, n$, *sgcode, sinc_abs, *xabs, *yabs, e$
				if affiche_G43_H = 2 & deg_4_axes > 0 & mi2$ = 0, [
					zabs = nextz$ 
					n$, sgcode, sg43, "H", *correcteur_H, *zabs, e$
					old_zabs = zabs  
					]      
                !x$, !y$, !z$
                ]
            ]
        old_axe_AB = axe_AB                                     # memo de la position de l'axe A afficher
        ]

# POUR LE MODE DE ROTATION **5**
# ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M..."
s_M_ROT_PO_P1_1 : "M56 ( palette A )"    	# ROTATION POSITIVE PALETTE A(1)    type palette commandée "A"
s_M_ROT_PO_P1_2 : "M55 ( + 90DEG )"     	# ROTATION POSITIVE PALETTE A(1)    ROT en +
s_M_ROT_NE_P1_1 : "M56 ( palette A )"    	# ROTATION NEGATIVE PALETTE A(1)    type palette commandée "A"
s_M_ROT_NE_P1_2 : "M54 ( - 90DEG )"        	# ROTATION NEGATIVE PALETTE A(1)    ROT en -

# ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
s_M_ROT_PO_P2_1 : "M57 ( palette B )"    	# ROTATION POSITIVE PALETTE B(2)    type palette commandée "B"
s_M_ROT_PO_P2_2 : "M55 ( + 90DEG )"     	# ROTATION POSITIVE PALETTE B(2)    ROT en +
s_M_ROT_NE_P2_1 : "M57 ( palette B )"    	# ROTATION NEGATIVE PALETTE B(2)    type palette commandée "B"
s_M_ROT_NE_P2_2 : "M54 ( - 90DEG )"        	# ROTATION NEGATIVE PALETTE B(2)    ROT en -

s_M_ROT_PO_1 : ""
s_M_ROT_PO_2 : ""
s_M_ROT_NE_1 : ""
s_M_ROT_NE_2 : ""

p_affiche_type_rot
    if Systeme_rot_plans = 0, [    #pas de calculs "TOUJOURS EN G54"
        if incremental = 0, n$, sgcode, sinc_abs, *axe_AB, !axe_ABi, e$
        else, n$, sgcode, sinc_abs, !axe_AB, *axe_ABi, e$
        ]
    if Systeme_rot_plans = 1, [    #PLANS "G68..."
        if incremental = 0, n$, sgcode, sinc_abs, "G68", *axe_AB, !axe_ABi, e$
        else, n$, sgcode, sinc_abs, !axe_AB, "G68", *axe_ABi, e$
        n$, p_ori_usi, e$
        ]
    if Systeme_rot_plans = 2, [    #SOUS-PROGRAMME de calcul --> usi en G55
        if incremental = 0, n$, sgcode, sinc_abs, *axe_AB, !axe_ABi, e$
        else, n$, sgcode, sinc_abs, !axe_AB, *axe_ABi, e$
        n$, "M98 P8000", e$
        n$, s_com_open, "G55 ACTIF",  s_com_close, e$
        ]
    if Systeme_rot_plans = 3, [    #1 ORIGINE PAR ANGLE
        if incremental = 0, n$, sgcode, sinc_abs, s_com_open, *axe_AB, s_com_close, !axe_ABi, e$
        else, n$, sgcode, sinc_abs, !axe_AB, s_com_open, *axe_ABi, s_com_close, e$
        n$, p_ori_usi, e$
        ]
    if Systeme_rot_plans = 4, [    #MODULE DE ROTATION A PART "automate" --> FONCTION "M" -- 1 ORIGINE PAR ANGLE
        n$, "M21", s_com_open, , "ROTATION AXE A", s_com_close, e$
        if incremental = 0, n$, sgcode, sinc_abs, s_com_open, *axe_AB, s_com_close, !axe_ABi, e$
        else, n$, sgcode, sinc_abs, !axe_AB, s_com_open, *axe_ABi, s_com_close, e$
        n$, "G4 X2.", e$
        ]
    if Systeme_rot_plans = 5, [    # 5 = FONCTION "M" en RELATIF **chaque M=90°** module de rotation à part "capteu automate" (1 ORIGINE PAR ANGLE)
        if axe_AB = -270, axe_AB = -90
        if axe_AB = 270, axe_AB = -90
        if axe_AB = -180, axe_AB = 180
        if epsi <>0, n$, s_com_open, "ROTATION AXE :", *axe_AB, " ANCIEN :", *old_axe_AB , s_com_close, e$

        if Var_16_question > 0, [    # ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M"
            s_M_ROT_PO_1 = s_M_ROT_PO_P1_1
            s_M_ROT_PO_2 = s_M_ROT_PO_P1_2
            s_M_ROT_NE_1 = s_M_ROT_NE_P1_1
            s_M_ROT_NE_2 = s_M_ROT_NE_P1_2
            ]
        if Var_17_question > 0, [    # ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
            s_M_ROT_PO_1 = s_M_ROT_PO_P2_1
            s_M_ROT_PO_2 = s_M_ROT_PO_P2_2
            s_M_ROT_NE_1 = s_M_ROT_NE_P2_1
            s_M_ROT_NE_2 = s_M_ROT_NE_P2_2
            ]
        #ROTATION HORAIRE
        if old_axe_AB = 0 & axe_AB = 90, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$                                                 #0      --> 90
        if old_axe_AB = 0 & axe_AB = 180, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$    #0      --> 180
        if old_axe_AB = 90 & axe_AB = 180, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$                                               #90     --> 180
        if old_axe_AB = 180 & axe_AB = -90, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$                                              #180    --> -90
        if old_axe_AB = 180 & axe_AB = 0, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$    #180    --> 0
        if old_axe_AB = -90 & axe_AB = 0, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$                                                #-90    --> 0

        #ROTATION ANTI-HORAIRE
        if old_axe_AB = 0 & axe_AB = -90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$                                                #0      --> -90
        if old_axe_AB = -90 & axe_AB = 180, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$                                              #-90    --> -180
        if old_axe_AB = 90 & axe_AB = 0, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$                                                 #90     --> 0
        if old_axe_AB = 180 & axe_AB = 90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$                                               #180    --> 90
        if old_axe_AB = -90 & axe_AB = 90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$   #-90    --> 90
        if old_axe_AB <> axe_AB, n$, "G04", "P1000", e$
        old_axe_AB = axe_AB
        ]
#endregion

#region calculs_et_affichage_rotations_en_continu_et_substitution
#------------------- 4 Axes continue en substitution d'axe ---------------------------------------
p_calcul_AB_pos_Subs  # calcul de l'axe A/B en substitution
    @x$, @y$
    if diviseur = 1, axeAB_subs = (y$ * 360 / (pi$ * rotdia$)) * sens_AB       # pour 4eme axe autour de X (substituer Y)
    if diviseur = 2, axeAB_subs = (x$ * 360 / (pi$ * rotdia$)) * sens_AB       # pour 4eme axe autour de Y (substituer X)
    if diviseur = 1, result = nwadrs(s_axe_rot_A, axeAB_subs)
    if diviseur = 2, result = nwadrs(s_axe_rot_B, axeAB_subs)
    p_Z_dev

    # ---- pour Ajouter/Soustraire l angle du plan "en positionné"
    # ROTATION SUR X    & old_rotaxis <> 0,
    if rotaxis$ = -2, axeAB_subs = ((axeAB_subs +180) - memo_AB_subs)* -1       # TYPE MC : SENS TRIGO sur X
    if rotaxis$ = 2, axeAB_subs = axeAB_subs + memo_AB_subs                     # TYPE MC : SENS HORAIRE sur X
    # ROTATION SUR Y
    if rotaxis$ = -1, axeAB_subs = ((axeAB_subs +180) - memo_AB_subs)* -1       # TYPE MC : SENS TRIGO sur Y
    if rotaxis$ = 1, axeAB_subs = axeAB_subs - memo_AB_subs                     # TYPE MC : SENS HORAIRE sur Y
    if rot_AB_un_sens = 1, while axeAB_subs < 0, axeAB_subs = axeAB_subs +360
	delta_A_sub = old_axe_AB - axeAB_subs
    delta_A_sub = abs(delta_A_sub)
	
	if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0			            			# diviseur tourne autour de Y (X sbstitue)
    if rotaxis$ = -2 | rotaxis$ = 2, yabs = 0			                 		# diviseur tourne autour de X (Y sbstitue)
	
	if drillcyc$ >= 0, [
		# rotaxis$ = -2 OK avec les parcours --> les autres restent à définir
		if rotaxis$ = -1 | rotaxis$ = 1, axeAB_subs = (axeAB_subs + 360) * -1   # diviseur tourne autour de Y (X sbstitue)
		if rotaxis$ = -2, axeAB_subs = (axeAB_subs + 360) 						# diviseur tourne autour de X (Y sbstitue) ANTI-HORAIRE OK
		if rotaxis$ = 2, n$, "PROBLEME VEUILLEZ METTRE LE SENS EN ANTI-HORAIRE", e$
		]
		
p_Z_dev  # calcul du Z en substitution
    @z$, @rotdia$
    zdev  = z$ +(rotdia$ /2)    # Z pour continue substitution en ABS
    zabs = zdev

p_Apos_affiche_subs  # affichage de l'angle au chg outil nul pour continue
    if useaxe <> 0, [
        @old_axe_AB, @axe_AB
        epsi = old_axe_AB - axe_AB
        epsi = abs(epsi)
           if epsi <> 0,    [
            p_degage_4_axes
            if mi7$ = 1, bloque = 2, n$, sbloque, e$        # déblocage de l'axe A/B
            p_ori_usi
            if incremental = 0, n$, sgcode, sinc_abs, *axe_AB, !axe_ABi, e$
            else, n$, sgcode, sinc_abs, !axe_AB, *axe_ABi, e$
            ]
        ]
    old_axe_AB = axe_AB

#------------------- 4 Axes continue en fonctions 5 Axes ---------------------------------------
p_axeAB_pmx  # Affichage de l'axe A
    #*old_axeA1, *axeA1
    delta_axeA1 = axeA1 - old_axeA1
    if delta_axeA1 >  180, delta_axeA1 = delta_axeA1 - 360
    if delta_axeA1 <  -180,delta_axeA1 = delta_axeA1 + 360
    axeA1_dep = axeA1_dep + delta_axeA1
    old_axeA1 = axeA1
    axe_AB = axeA1_dep * sens_AB
    nbrtour = int (axe_AB / 360) * sens_AB
    if incremental = 0, if debutpmx = 1, *axe_AB, !axe_ABi, else, axe_AB, !axe_ABi
    if incremental = 1, if debutpmx = 1, !axe_AB, *axe_ABi, else, !axe_AB, axe_ABi

p_calcul_rot_pmx  # Calcul de l'axe A
    if Mode_reglage_PP = 0, "VOIR p_calcul_rot_pmx ", *x$, *y$, *z$, *u$, *v$, *w$, e$
    vx = u$ - x$
    vy = v$ - y$
    vz = w$ - z$
    if diviseur = 1, axeA1 = atan2(vy,vz) # on tourne autour de x
    if diviseur = 2, axeA1 = atan2(vx,vz) # on tourne autour de Y
    if axeA1 >  180, axeA2 = 360 - axeA1
    if axeA1 <= 180, axeA2 = axeA1 * -1
    if diviseur = 1, [          # on tourne autour de x
        new_x = x$
        new_y = z$*sin(axeA2) + y$*cos(axeA2)
        new_z = z$*cos(axeA2) - y$*sin(axeA2)
        ]
    if diviseur = 2, [          # on tourne autour de Y
        new_x = z$*sin(axeA2) + x$*cos(axeA2)
        new_y = y$
        new_z = z$*cos(axeA2) - x$*sin(axeA2)
        ]
    xabs = new_x
    yabs = new_y
    zabs = new_z
    epsi = old_axe_AB - axeA1      # regarder si on tourne
    epsi = abs(epsi)
    old_axe_AB = axeA1

#endregion

#region pmx_
p_corr_5x
	# Valable pour la correction de rayon uniquement en USURE :
	# tool_op$ = 106 --> alésage helicoidale 
	if type_comp = 5 | type_comp = 6, [
		if fr$ > 0 & cc$ = 41 | cc$ = 42 & (motst$ = 7), [
			#if premier_cc_5x = 1, *cc$, premier_cc_5x = 0
			if prv_gcode$ = 1 & prv_zabs = zabs, *cc$, premier_cc_5x = 1
			]	
		if fr$ = -2 & cc$ = 41 | cc$ = 42 & prv_zabs <> zabs & premier_cc_5x = 1, n$, "G40", e$, premier_cc_5x = 0
		] 
	#*fr$, *motst$, *cc$, 
	
pmx$        # Gestion 4 axes continues avec fonction 5 axes
    if Mode_reglage_PP = 0, n$, "--> pmx$", *x$, *y$, *z$, *zr$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$,
        *m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
	
	# ***** ATTENTION ! LE perçage 5 axes en 4AXES NE PASSE PAS ICI********
	# ***** PAS de gestion complète du perçage 5 axes ICI
	#		- pmx$ 
	# 		- p_debut_pmx pour le début XY/A/HZ/A ..
	# 		- p_drill_5axes 1er A
	# 		- p_drill_5axes_2  A suivants	 			
	if opcode$ = 16 & nextop$ = 81, drill_4_axes = 1, p_drill_5axes, ex$ 
	if opcode$ = 16 & nextop$ = 81 & debutpmx = 11, p_drill_5axes_2, ex$ # PAS de gestion du perçage 5 axes ICI
	
	if debutpmx = 1, p_debut_pmx, ex$
    # 5 AXES classique
    if debutpmx = 0 & opcode$ <> 16,    [
        if Mode_reglage_PP = 0, "pmx_ CONTOURS: ", e$
        p_calcul_rot_pmx
        if m1$ <> 1 & m5$ <> 1, p_erreur_inclinaison_OP_5axes     # TEST si mauvaise inclinaison
        if fr$ = -2, gcode$ = 0
        else, gcode$ = 1
        if gcode$ = 1,    [
            @xabs, @yabs, @old_x, @old_y
            if xabs <> old_x | yabs <> old_y, n$, p_ori_usi, e$, n$, sinc_abs, sgcode, p_corr_5x, xabs, yabs, zabs, p_axeAB_pmx, pcorrecteur_D, pfr, e$
            else, n$, p_ori_usi, e$, n$, sinc_abs, sgcode, p_corr_5x, xabs, yabs, zabs, p_axeAB_pmx, pcorrecteur_D, pfr, e$
            ]
        else, p_corr_5x, n$, sinc_abs, sgcode, xabs, yabs, zabs, p_axeAB_pmx, e$
        ]
    # Uniquement perçage 5 axes
    #if debutpmx = 0 & opcode$ = 16,    [
        #if Mode_reglage_PP = 1, "pmx_ PERCAGES: ", e$
		#p_calcul_rot_pmx
        #if mi7$ = 1, bloque = 2, n$, sbloque, e$        # déblocage de l'axe A/B
        #if fr$ = -2, gcode$ = 0, else, gcode$ = 1
        #n$, sgcode, *xabs, *yabs, *zabs, p_axeAB_pmx, pfr, e$
        #old_op_id = op_id$
        #]
    #if debutpmx = 0 & opcode$ = 16 & gcode$ = 11 & nextop$ = 1003, #FIN DE PERCAGES --> Z HAUT SECU
        #[
        #p_calcul_rot_pmx
        #gcode$ = 0
        #n$, *sgcode, *zabs, e$
        #]
    old_x = xabs
    old_y = yabs
    old_z = zabs

p_debut_pmx
	#spaces$ = 1
    if Mode_reglage_PP = 0, n$, "p_debut_pmx : ", e$
    p_calcul_rot_pmx
    if mi7$ = 1, bloque = 2, n$, sbloque, e$        # déblocage de l'axe A/B
    gcode$ = 0
	p_ori_usi
    n$, *sinc_abs, *sgcode, p_axeAB_pmx, e$ 
	if opcode$ = 16, if mi7$ = 1, bloque = 1, n$, sbloque, e$        # déblocage de l'axe A/B
	
	if diviseur = 1, new_y = z$*sin(axeA2) + y$*cos(axeA2)
	if diviseur = 2, new_x = z$*sin(axeA2) + x$*cos(axeA2)
	
	if diviseur = 1, n$, *sinc_abs, *sgcode, "G17", *xabs, *new_y, ssa, spdlon, e$ 	
	if diviseur = 2, n$, *sinc_abs, *sgcode, "G17", *new_x, *yabs, ssa, spdlon, e$ 
	zr_ = zr$ 
    if opcode$ <> 16, n$, pcorh, *zr_, p_lubrif_ON, e$
	if opcode$ = 16, new_z = old_z, n$, pcorh, *zabs, p_lubrif_ON, e$, zabs_deb_fin_secu_p_5x = zabs
    !x$, !y$, !z$, !xr$, !yr$, !zr$
	premier_cc_5x = 1
    old_x = xabs
    old_y = yabs
    old_z = zabs
    debutpmx = 0

pmx_end$    #FIN de chaque BLOC pmx$
    if Mode_reglage_PP = 0, "pmx_end_: ", e$
	if opcode$ = 16, gcode$ = 0, n$, *sgcode, *zabs_deb_fin_secu_p_5x, e$
#endregion

#region approches_degagements
#   Gestion du degagement de la machine au debut de prog
p_degage_debut       #   Gestion du degagement de la machine au debut de prog
    if deg_debut <> 0, [
        gcode$ = 0                          # Degagement en Rapide
        if deg_debut >= 1 & deg_debut < 6, n$, ptype_deg, *degageZ, e$       			# si degager en Z        	# degager en Z
        if deg_debut = 2 | deg_debut = 4, n$, ptype_deg, *degageX, e$       			# si degager en Z et X    	# degager en X
        if deg_debut = 3 | deg_debut = 4, n$, ptype_deg, *degageY, e$          			# si degager en Z et Y    	# degager en Y
        if deg_debut = 5, n$, ptype_deg, *degageX, *degageY, e$             			# si degager en Z et XY    	# degager en X Y
        if deg_debut = 6, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$  # si Mode degagement uniquement en MACRO
		ptype_deg_Fin
        ]

#   Gestion du degagement de la machine avant appel outil
p_degage_ptlchg     #   Gestion du degagement de la machine avant appel outil
    if deg_outil <> 0, [
        gcode$ = 0                          # Degagement en Rapide
        if deg_outil >= 1 & deg_outil < 6, n$, ptype_deg, *degageZ, e$                  # si degager en Z       # degager en Z
        if deg_outil = 2 | deg_outil = 4, n$, ptype_deg, *degageX, e$                 	# si degager en Z et X  # degager en X
        if deg_outil = 3 | deg_outil = 4, n$, ptype_deg, *degageY, e$     				# si degager en Z et Y  # degager en Y
        if deg_outil = 5, n$, ptype_deg, *degageX, *degageY, e$                         # si degager en Z et XY # degager en X Y
        if deg_outil = 6, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$  # si Mode degagement uniquement en MACRO
        ptype_deg_Fin
        ]

#   Gestion du degagement de la machine fin de prog
p_degage_fin #   Gestion du degagement de la machine fin de prog
       if deg_fin <> 0, [
        gcode$ = 0                          # Degagement en Rapide
        if deg_fin >= 1 & deg_fin < 6, n$, ptype_deg, *degageZ_fin, e$         			# si degager en Z       # degager en Z
        if deg_fin = 2 | deg_fin = 4, n$, ptype_deg, *degageX_fin, e$                   # si degager en Z et X  # degager en X
        if deg_fin = 3 | deg_fin = 4, n$, ptype_deg, *degageY_fin, e$     				# si degager en Z et Y  # degager en Y
        if deg_fin = 5, n$, ptype_deg, *degageX_fin, *degageY_fin, e$                   # si degager en Z et XY # degager en X Y
        if deg_fin = 6, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$	# si Mode degagement uniquement en MACRO
        ptype_deg_Fin
        ]

#   Gestion du degagement de la machine avant rotation plateau
p_degage_4_axes        #   Gestion du degagement de la machine avant rotation plateau
    if deg_4_axes <> 0, [
		gcode$ = 0                  # Degagement en Rapide
		if mi2$ = 0, [				# Si différent de "0" alors pas de passage suivant config PP --> utilise UNIQUEMENT le Z sécu de l'op	
	        #p_casse_modalite       # casser la modalite pour rappel des XYZ
	        if deg_4_axes >= 1 & deg_4_axes < 6, n$, ptype_deg, *degageZ4, e$    			# si degager en Z       # degager en Z
	        if deg_4_axes = 2 | deg_4_axes = 4, n$, ptype_deg, *degageX4, e$      			# si degager en Z et X  # degager en X
	        if deg_4_axes = 3 | deg_4_axes = 4, n$, ptype_deg, *degageY4, e$      			# si degager en Z et Y  # degager en Y
	        if deg_4_axes = 5, n$, ptype_deg, *degageX4, *degageY4, e$          			# si degager en Z et XY # degager en X Y
	        if deg_4_axes = 6, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$  # si Mode degagement uniquement en MACRO
	        ptype_deg_Fin
			]
		if mi2$ = 1, n$, *sgcode, *zrp, strcantext, e$		# FORCE le Z sécu de l'op si la config est remonter en Z HAUT 
		]
    #else, gcode$ = 0, n$, *sgcode, *zrp, strcantext, e$    	# Sinon valeur de sécu de la valeur de l'opération MC

#   Gestion du degagement de l'outil lors de l'inspection de l'état de la plaquette
pdeg_inspection_plaquette
    if deg_inspection_plaq <> 0, [
        gcode$ = 0                      # Degagement en Rapide
        #p_casse_modalite                # casser la modalite pour rappel des XYZ
        if deg_inspection_plaq = 1, n$, ptype_deg, *deg_insp_Z, e$                              # si degager en Z       # degager en Z
        if deg_inspection_plaq = 2 | deg_inspection_plaq = 4, n$, ptype_deg, *deg_insp_X, e$    # si degager en Z et X  # degager en X
        if deg_inspection_plaq = 3 | deg_inspection_plaq = 4, n$, ptype_deg, *deg_insp_Y, e$    # si degager en Z et Y  # degager en Y
        if deg_inspection_plaq = 5, n$, ptype_deg, *deg_insp_X, *deg_insp_Y, e$                 # si degager en Z et XY # degager en X Y
        if deg_inspection_plaq = 6, n$, S_macro_deg, e$ #n$, "autres fonctions apres MACRO", e$
        ptype_deg_Fin
        ]
    else, gcode$ = 0, n$, n$, *sgcode, *zrp, strcantext, e$    #Sinon valeur de sécu dans l'opération MC

ptype_deg
    @type_deg
	if type_deg = 1, "G0 G28 G91"
    if type_deg = 2, "G0 G53 G90"

ptype_deg_Fin
	@type_deg
    if type_deg = 1, n$, "G90", e$
    if type_deg = 6, n$, "G90 (A VALIDER)", e$
#endregion

#region decallages_origines
s_erreur_num_origine : "ATTENTION ERREUR de numéro d'origine Exemple 1=54 2=55 ..."
#   Gestion des Origine d'usinages G54 a G59 et G54.1 P1 à G54.1 P49
p_ori_usi
    # OPERATIONS TRANSFORMATIONS 
		# MODE 1 "AUTO ORIGINES" PASSENT A 1
		# MODE 2 
		# MODE 3 "INCREMENTAL" --> ok avec workofs$
	@workofs_,@old_workofs
    if workofs_ > 53, result = mprint(s_erreur_num_origine)
    if Mode_reglage_PP = 0, [
        n$, "gw", *g_wcs, e$
        n$, "workofs_", *workofs_, e$
        n$, "workofs$", *workofs$, e$
        n$, "old_workofs", *old_workofs, e$
		n$, "op_transformation :", *xform_op_id$, " ", *op_id$, "dec transf:", *workofs_dec, e$ 	
		# xform_op_id$ & op_id$ même numéro = pas de transformation
        ]
	# OPERATIONS TRANSFORMEES 
	if xform_op_id$ <> op_id$ & workofs$ <> old_workofs & workofs_dec > 0, workofs_ = workofs$	# G54 G55 ... Par défaut
	if workofs_ > 0 & workofs_ <> old_workofs & mi8$ < 2, [													# ET OP. TRANSFORMATION EN G54 G55 ... Par défaut 	
        g_wcs = workofs_ + 54
        if g_wcs <= 54, n$, *g_wcs, e$
        if g_wcs > 54 & g_wcs < 60, n$, *g_wcs, e$
        if g_wcs > 59 & g_wcs < 108, origine_bis = g_wcs - 59, n$, *origine_bis, e$
		old_workofs = workofs_
        ]
    if workofs_ <= 0 & workofs_ <> old_workofs, g_wcs = 54, n$, *g_wcs, e$, old_workofs = workofs_
    if tox4$ <> 0 | toy4$ <> 0 | toz4$ <> 0, [
        if tox4$ <> old_tox4 | toy4$ <> old_toy4 | toz4$ <> old_toz4, [
			#if mi8$ < 2 & workofs_dec < 2, n$, "G52", *tox4$, *toy4$, *toz4$, e$	# DECALLAGE CLASSIQUE --> DECALLAGE des VALEURS DANS LES G54/G55 ...
			if mi8$ = 2 & workofs_dec > 0, n$, "G52", *tox4$, *toy4$, *toz4$, e$	# G52 EN OP. TRANSFORMATION
			if mi8$ = 3 & workofs_dec > 0, n$, "G92", *tox4$, *toy4$, *toz4$, e$	# G92 EN OP. TRANSFORMATION (G92 ANNULE LE G52) G92 est parent sur les G54/G55...		
			]
        old_tox4 = tox4$
        old_toy4 = toy4$
        old_toz4 = toz4$
        ]
    # ANNULATIONS
	if (old_tox4 <> 0 & tox4$ = 0) | (old_toy4 <> 0 & toy4$ = 0) | (old_toz4 <> 0 & toz4$ = 0), [
		if mi8$ < 2 & workofs_dec < 2, n$, "G52 X0 Y0 Z0", e$	# DECALLAGE CLASSIQUE - M30 ou G92 ANNULE les valeurs du G52
		if mi8$ = 2 & workofs_dec > 0, n$, "G52 X0 Y0 Z0", e$	# G52 EN OP. TRANSFORMATION
		if mi8$ = 3 & workofs_dec > 0, n$, "G92 X0 Y0 Z0", e$	# G92 EN OP. TRANSFORMATION	
		]
    if sinfo_origine <> svide2 & sinfo_origine <> s_old_sinfo_origine,    [
        n$, s_com_open, "INFO DECALAGE :", *sinfo_origine, s_com_close, e$
        s_old_sinfo_origine = sinfo_origine
        ]
    
    if util_x_ori = 1, perreur_Aff_Ori

p_annule_decalage
    memo_incremental = incremental
    incremental = 0
    sub_trnsx$ = 0
    sub_trnsy$ = 0
    sub_trnsz$ = 0
    if mi8$ < 2 & workofs_dec < 2, n$, sinc_abs, "G52", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$		# DECALLAGE CLASSIQUE
	if mi8$ = 2 & workofs_dec > 0, n$, sinc_abs, "G52", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$		# G52 EN OP. TRANSFORMATION
	#if mi8$ = 3 & workofs_dec > 0, n$, sinc_abs, "G92", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$		# G92 EN OP. TRANSFORMATION	
    decalage = 0
    incremental = memo_incremental
#endregion

#region block_form
p_block_form
    if stock_shape <> zero & stock_shape <> one, result = mprint(s_erreur_stock_shape)  #Only Rectangular and Cylindrical are supported
    if block_form & stock_shape = zero,
        [
        if stck_crnr$ = 0,  #Top - Center
          [
          stck_x_min = stck_x$ - stck_ht$/2
          stck_y_min = stck_y$ - stck_wdth$/2
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$ + stck_ht$/2
          stck_y_max = stck_y$ + stck_wdth$/2
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 1,  #Top - Upper Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$ + stck_ht$
          stck_y_max = stck_y$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 2,  #Top - Upper Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 3,  #Top - Lower Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$
          stck_y_max = stck_y$ + stck_wdth$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 4,  #Top - Lower Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$ + stck_ht$
          stck_y_max = stck_y$ + stck_wdth$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 5, #Bottom - Upper Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$ + stck_thck$
          ]

        if stck_crnr$ = 6,  #Bottom - Upper Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$ + stck_thck$
          ]

        if stck_crnr$ = 7,  #Bottom Lower Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$
          stck_z_min = stck_z$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$ + stck_thck$
          ]

        if stck_crnr$ = 8,  #Bottom - Lower Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$
          stck_z_min = stck_z$
          stck_x_max = stck_x$ + stck_ht$
          stck_y_max = stck_y$ + stck_wdth$
          stck_z_max = stck_z$ + stck_thck$
          ]
        stck_x_min = vsub(stck_x_min, t_orgin_x$) #(add or) subtract the tool origin from the 1027 line
        stck_x_max = vsub(stck_x_max, t_orgin_x$) #(add or) subtract the tool origin from the 1027 line
        if stck_x_min = 0 & stck_y_min = 0 & stck_z_min = 0 & stck_x_max = 0 & stck_y_max = 0 & stck_z_max = 0,
			n$, s_com_open, "BRUT NON DEFINI", s_com_close, e$
		else, [
			n$, s_com_open, "DIM. BRUT 1/2", *stck_x_min, *stck_y_min, *stck_z_min, s_com_close, e$
	        n$, s_com_open, "DIM. BRUT 2/2", *stck_x_max, *stck_y_max, *stck_z_max, s_com_close, e$
			]
        ]

      if block_form & stock_shape = one,  # Cylinder
        [
        if stock_cyl_axis >= 0,  # Cylinder about Z or cylinder about same axis as rotary centerline
          [
          # Build & output the WORKPIECE line - "WORKPIECE(,"",,"CYLINDER", par2, ztop, zbottom, -80, diameter)"
          # Absolute stock length dim in Siemens
          if stock_cyl_axis = 0,  # Stock about X-axis
            [
            topz = stck_x$ + stck_wdth$  #Define X+ end of stock
            bottomz = stck_x$            #Define X- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          if stock_cyl_axis = 1,  # Stock about Y-axis
            [
            topz = stck_y$ + stck_wdth$  #Define Y+ end of stock
            bottomz = stck_y$            #Define Y- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          if stock_cyl_axis = 2,  # Stock about Z-axis
            [
            topz = stck_z$ + stck_wdth$  #Define Z+ end of stock
            bottomz = stck_z$            #Define Z- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          # Output WORKPIECE line using values determined above / Define the stock for graphics - Cylinder
          stck_cyl_dia = stck_cyl_dia / 2 # Ici valeur au rayon
          if stock_cyl_axis = 0, s_axe_brut_cyl = "X"
          if stock_cyl_axis = 1, s_axe_brut_cyl = "Y"
          if stock_cyl_axis = 2, s_axe_brut_cyl = "Z"
          stck_cyl_dia = stck_cyl_dia * 2
          stck_cyl_dia_inter = stck_cyl_dia_inter * 2
          topz = abs(topz) + abs(bottomz)
          bottomz = abs(bottomz)
          n$, s_com_open, "BRUT CYLINDRIQUE SUR L AXE", s_axe_brut_cyl, s_com_close, e$
          n$, s_com_open, *stck_cyl_dia, *topz, *bottomz, [if stck_cyl_dia_inter >0, *stck_cyl_dia_inter ], s_com_close, e$ # Z R50 L105 DIST+5 R110 = AXE DE BROCHE, RAYON, LONGUEUR, "DIST", RAYON INTER
          ]
        ]
    if block_form & stock_shape = two, n$, s_com_open, "Brut solide-Maillage utilisé dans MasterCam", s_com_close, e$            # Solide-Maillage
    if block_form & stock_shape = three, n$, s_com_open, "Brut depuis fichier STL utilisé dans MasterCam", s_com_close, e$    # Stl
#endregion

#region corps_Pheader_a_Peof

#region Pbloc_appelEs
fmt  "F#" 4 frQ
fmt  "R100=" 2 varq50   #AVANCE PLONGEE
fmt  "R101=" 2 varq51   #AVANCE TRAVAIL
fmt  "oldQ" 2 old_q50
fmt  "oldQ" 2 old_q51
fmt  "oldQ" 2 old_q52
fmt  "PRVZ" 2 prvz
fmt     	4 debut_out
fmt     	4 old_frq 
fmt     	7   F_variables 
fmt  "F" 	3   F_plongee
fmt  "F" 	3   F_micro_remontee 
fmt  "F" 	3   F_G1_ugv_3D  
fmt  "F" 	3   F_G1_ugv_2D 
fmt  "F" 	3   F_retract 

#   Gestion de la valeur de l'avance pour l'afficher
pfr     # avance sur contour
    #motst$ ="type de mouvement" 1=X 2=Y 3=X&Y 4=Z 5=X&Z 6=Y&Z 7=XY&Z
    #tool_op <> 2 pas au perçage
    #tool_op$ <> 102 pas au surfaçage
    #F_variables = 0 POUR LES QUESTIONS "fq1"
    #fr$ = -1 lorsque la valeur n'est pas différente
	@frQ
	if rotaxis$ <> 0 | nextop$ = 11, p_avances_avec_rot_A_B # SUBSTITUTION D'AXES --> EN DEGRES
    else, [
	    #"  ", *F_variables, *fr$, *nextop$, *mi4$, *tool_op$
	    if (F_variables = 1) & (nextop$ <> 11) & (mi4$ = 0) & (OP_percage <> 1) & (tool_op$ <> 102), [       
	        if fr$ <> -1, [	                        
				if fr_pos$ = F_plongee, frQ = 100, *frQ
				if (fr_pos$ = F_USI_prmcode) & (F_USI_prmcode <> F_plongee), frQ = 101, *frQ	
				if fr_pos$ <> F_plongee & fr_pos$ <> F_USI_prmcode, *fr_pos$ 
				#if fr_pos$ = F_G1_ugv_3D, F_G1_ugv_3D
				#if fr_pos$ = F_G1_ugv_2D, F_G1_ugv_2D
				#if fr_pos$ = F_retract, F_retract
				#if (fr_pos$ = F_micro_remontee) & ((F_G1_ugv_3D <> F_micro_remontee) | (F_G1_ugv_2D <> F_micro_remontee)), F_micro_remontee
	            ]
	        ]
	    if F_variables = 1 & tool_op$ = 102 & fr$ <> -1 & (mi4$ = 0), fr$ = 101, frQ = fr$, *frQ	# surfaçage
	    if fr_pos$ >= 0 & (nextop$ = 11 | mi4$ <> 0), fr_pos$  					# pas de F= -- OP 5 AXES
	    if F_variables = 0 & fr_pos$ <> -1, fr_pos$                				# pas de F=	  			
	    debut_out = 0
		]   
    p_erreur_avanceS    
    # gestion de l'avance entre 2 passes en surfaçage prmcode = 10116 avec tool_op = 102
        	
		#[
        #avance = fr_pos$
        #avance
        #]
    #result = newfs (4, avance)  # affectation en format modal

pfrvar   # ecriture des avances variables
	if F_variables = 1 & nextop$ <> 11 & mi4$ = 0 & (OP_percage <> 1) & rotaxis$ = 0, [
        varq51 = fr$
        if opcode$ = 4 | opcode$ = 13 | opcode$ = 14, varq50 = F_plongee, else, varq50 = varq51  #fr$/sqrt(tldia$*2) OPs de poches = avance MC
        @varq50,@varq51,@old_q50,@old_q51
		varq50 = F_plongee
        if debut_out = 1, [
			n$, *varq50, s_com_open, "AVANCE PLONGEE", s_com_close, e$
            n$, *varq51, s_com_open, "AVANCE TRAVAIL", s_com_close, e$
            ]
         if debut_out = 0, [       
			if old_q50 <> varq50, n$, *varq50, s_com_open, "AVANCE PLONGEE", s_com_close, e$
            if old_q51 <> varq51, n$, *varq51, s_com_open, "AVANCE TRAVAIL", s_com_close, e$
            ]
        old_q50 = varq50
        old_q51 = varq51
        ]

p_affiche_avance
	if type_avance = 0 | type_avance = 1, fr_pos$
	if type_avance = 2, [
		result = newfs(2,avance)
		avance = fr_pos$ / (paramT16 * ss$)
		avance
		] 
				
p_type_avance
	if type_avance = 1, s_avance_mm_mn
	if type_avance = 2, s_avance_mm_tr
			
#region Avances en "DEG/Minutes"
fmt "D"     2 deltaXYZ
fmt "Dx"    2 Delta_F_X
fmt "Dy"    2 Delta_F_Y
fmt "Dz"    2 Delta_F_Z
fmt         2 old_F_X
fmt         2 old_F_Y
fmt         2 old_F_Z
fmt "F"     2 fr_deg_inv
fmt         4 old_fr
fmt "DA"    2 Delta_Angle
fmt "A"     2 delta_A_sub
fmt ""      2 circum
fmt         2 ldelta
fmt         2 cldelta
fmt         2 cdelta
#Feedrate calculation variables
frdelta      : 0     #Calculation for deg/min
frinv        : 0     #Feedrate inverse time
frdeg        : 0     #Feedrate deg/min actual
prvfrdeg     : 0     #Feedrate deg/min actual
ldelta       : 0     #Calculation for deg/min, linear
cldelta      : 0     #Calculation for deg/min, linear and rotary

p_avances_avec_rot_A_B
    # calculs en "DEG/Minutes"
    #spaces$ = 1
    if rotaxis$ <> 0,    # SUBSTITUTION X/Y
        [
        #"1111", *memo_AB_subs, *epsi, *old_axe_AB, "delta_A_sub", *delta_A_sub, e$
		Delta_Angle = delta_A_sub
		#circum = sqrt(Delta_F_X) * 2 * pi$
        circum = zabs * 2 * pi$			# Calcul du périmètre
        if circum = 0, circum = 9999
		ldelta = sqrt((xabs-prv_xabs)^2+(yabs-prv_yabs)^2+(zabs-prv_zabs)^2)
        cdelta = Delta_Angle
        if ldelta = 0, cldelta = cdelta
        else, cldelta = sqrt(cdelta^2 + ldelta^2)
        if cldelta = 0, cldelta = 9999
        Delta_F_Z = 0			
        if rotaxis$ = -2 | rotaxis$ = 2,    # ROTATION SUR X SUBSTITUTION DE Y
            [          
            Delta_F_X = x$ - old_F_X
            Delta_F_Y = ((2*pi$*zabs)/360) * Delta_Angle
            if Delta_F_X > 0, deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y)
            else, deltaXYZ = Delta_F_Y 
            old_F_X = x$
            ]
        if rotaxis$ = -1 | rotaxis$ = 1,    # ROTATION SUR Y SUBSTITUTION DE X
            [			
            Delta_F_Y = y$ - old_F_Y
            Delta_F_X = ((2*pi$*zabs)/360) * Delta_Angle
            if Delta_F_Y > 0, deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y)
            else, deltaXYZ = Delta_F_X          		
            old_F_Y = y$
            ]
		#"uuu", *ldelta, *deltaXYZ, *Delta_Angle
              #Delta_Angle = ((abs(cabs - prvcabs))/360)*circum
        ]
    if nextop$ = 11,                       # si  4 axes avec fonction 5 axes
        [
        #"2222", *epsi, *old_axe_AB, *delta_axeA1
        Delta_Angle = abs(epsi)
        Delta_F_X = y$ - old_F_X
        Delta_F_Y = y$ - old_F_Y
        Delta_F_Z = y$ - old_F_Z
        deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y + Delta_F_Z * Delta_F_Z)
        Delta_Angle = sqrt(Delta_Angle^2 + deltaXYZ^2)
        circum = sqrt(deltaXYZ) * 2 * pi$
        old_F_X = x$
        old_F_Y = y$
        old_F_Z = z$
        ]
    #"Delta_Angle", *Delta_Angle, " deltaXYZ:", *ldelta, *deltaXYZ, "lcircum", *circum
	@Delta_Angle
    if Delta_Angle > 0 | (nextop$ = 11 & epsi > 0),
        [
        #" ", *Delta_F_Y, *zabs, *rotaxis$, e$
        #deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y + Delta_F_Z * Delta_F_Z)
        ##fr_deg_inv = abs(cdelta/cldelta) * abs(fr_pos$ * (360/circum))
        fr_deg_inv = abs(Delta_Angle/deltaXYZ) * abs(fr_pos$ * (360/circum))
        if abs(fr_deg_inv - prvfrdeg) > 10, prvfrdeg = fr_deg_inv
        if fmtrnd(fr_deg_inv) = 0, fr_deg_inv = fr_pos$
        if fr_deg_inv > 2000, fr_deg_inv = 2000
        if fr_deg_inv < 50, fr_deg_inv = 50
        fr_deg_inv = round(fr_deg_inv)
        #if inversefeed$, [  #Feedrate in seconds --> DEPUIS DEF MACHINE (valeurs très petites)
            #fr_deg_inv = (fr_pos$*(1/60))/cldelta
            #]
        ]
	# Avance sans rotation --> pas de calculs
	if Delta_Angle = 0, avance = fr_pos$, *avance  
    if rotaxis$ <> 0 & Delta_Angle > 0, [
        #if Delta_Angle > 0 & (Delta_F_X > 0 | Delta_F_Y > 0 | Delta_F_Z > 0) & fr_deg_inv < 10000, fr_deg_inv
        #else, avance = fr_pos$, if avance <> old_fr, avance
        if Delta_Angle > 0 & (Delta_F_X > 0 | Delta_F_Y > 0 | Delta_F_Z > 0) & fr_deg_inv < 10000, if fr_deg_inv <> prv_fr_deg_inv, *fr_deg_inv
        Delta_Angle = 0
        Delta_F_X = 0
        Delta_F_Y = 0
        Delta_F_Z = 0
        ]
    if nextop$ = 11,                       # si  4 axes avec fonction 5 axes
        [
        #"3333", *Delta_Angle, *epsi, *Delta_F_X, *Delta_F_Y, *Delta_F_Z, *old_fr#*fr_deg_inv
        if epsi = 0, avance = fr_pos$, avance
        if epsi > 0 & fr_deg_inv < 10000, fr_deg_inv, old_fr = -9999        # & (Delta_F_X <> 0 | Delta_F_Y <> 0 | Delta_F_Z <> 0)
		]
#endregion

pavanceperce    # Avance en percage
    #p_casse_modalite_avance                # pour forcer l'affichage de l'avance
    pfr                     # Affichage de l'avance

#   Gestion de la correction outil et du numéro de correcteur
pcorh       # Correction de longueur
    correcteur_H = tlngno$
    if outils_param = 0 & correcteur_H <> old_correcteur_H, [    # sans les parametres
        sg43, "H", *correcteur_H
        ]
    if outils_param = 1 & correcteur_H <> old_correcteur_H, [     # avec les parametres
        correcteur_H_param = correcteur_H
        correcteur_H_param = correcteur_H_param + 500
        sg43, "H", no_spc$, 35, *correcteur_H_param
        correcteur_H = correcteur_H_param
        ]
    old_correcteur_H = correcteur_H
    perreur_H

pcancelcc$  # Annulation de correction de rayon

#region correction_rayon
# -------------------------LECTURE DES PARAMETRES DE surep_XY_2D ET DE TYPE DE CORRECTION--------------------------------------------
param_comp   # Type de correction d'outil au changement d'operation    --- TEXTE
    if (info_corr = 1 & op_id$ <> old_op_id)  & CN_textes <> 0 | (info_corr = 1 & old_op_id = -99999), [     # si afficher les infos de compesation et changement d'operation et texte supporté
        #cc_comp 41 42 0
        #cc_pos   1  2 0
        @cc_computer$, @cc_pos$, @cc$                              # rappel des variables
        #*cc$, *cc_pos$, *cc_computer$, *opcode$, *tool_op$, e$
        if cc$ = 0 & cc_computer$ = 0, type_comp = 0    #AUCUNE
        if cc$ = 42 & cc_computer$ = 0, type_comp = 1   #ARMOIRE DROITE
        if cc$ = 41 & cc_computer$ = 0, type_comp = 2   #ARMOIRE GAUCHE
        if cc$ = 0 & cc_computer$ = 42, type_comp = 3   #ORDINATEUR DROITE
        if cc$ = 0 & cc_computer$ = 41, type_comp = 4   #ORDINATEUR GAUCHE
        if cc$ = 42 & cc_computer$ = 42, type_comp = 5  #USURE DROITE
        if cc$ = 41 & cc_computer$ = 41, type_comp = 6  #USURE GAUCHE
        if cc$ = 41 & cc_computer$ = 42, type_comp = 7  #USURE INVERSE DROITE
        if cc$ = 42 & cc_computer$ = 41, type_comp = 8  #USURE INVERSE GAUCHE
		# filetages à la fraise --> bricollage
		if cc$ = 41 & cc_computer$ = 42 & tool_op$ = 100, type_comp = 6	#USURE GAUCHE
		#
        if cc$ = 0 & opcode$ >= 5 & opcode$ <> 19, type_comp = 9    #CORREC. ORDI. 3D     15346=0 15326=1
        if opcode$ = 19, type_comp = 0                              # mis sur aucune a la place d'ordinateur pour surfacage (bug)
        if numcoment = 0, omitseq$ = 1                              # si pas de numero de bloc pour commentaires enlever les numeros de bloc
        if opcode$ <> 3 & opcode$ <> 16, n$, s_com_open, *stype_comp, s_com_close, e$   # pour ne pas afficher les infos si percage
        omitseq$ = old_omitseq                                      # rappel des numeros de bloc
        ]
#endregion

#region Surepaisseurs
param_surep  # Affichage des surep_XY_2D au changement d'opération
    if info_surep = 1 & CN_textes <> 0, [           # si afficher les infos de compensation et changement d'operation et texte supporté
        #spaces$ = 0
        if numcoment = 0, omitseq$ = 1              # si pas de numero de bloc pour commentaires enlever les numeros de bloc
        # surep XY & Z OPs 2D
        if opcode$ <> 3 & opcode$ < 5  & opcode$ <> 19,    [
            if (surep_XY_2D <> old_surep_XY_2D) | (surep_Z_2D <> old_surep_Z_2D), [
                n$, s_com_open, *surep_XY_2D, s_com_close, e$
                n$, s_com_open, *surep_Z_2D, s_com_close, e$
                old_surep_XY_2D = surep_XY_2D
                old_surep_Z_2D = surep_Z_2D
                ]
            ]
        # surep 3d
        if opcode$ <> 3 & opcode$ >= 5 & opcode$ <> 19, [
            if surep_XY_3D <> old_surep_XY_3D, n$, s_com_open, *surep_XY_3D, s_com_close, e$
            if surep_Z_3D <> 0, n$, s_com_open, *surep_Z_3D, s_com_close, e$
            old_surep_XY_3D = surep_XY_3D
            old_surep_Z_3D = surep_Z_3D
            ]
        # surep pour surfaçage
        if opcode$ = 19, [
            if surep_Z_surf_2D <> old_surep_Z_2D, n$, s_com_open, *surep_Z_surf_2D, s_com_close, e$
            old_surep_Z_2D = surep_Z_surf_2D
            ]
        ]
#endregion

#   Gestion des gammes de vitesse de broche
pgamme
    @ssa
    #if ssa < 1500, "M38"
    #else, "M39

#---------------------------------
P_f_val_origine_depart_idem
    Old_Val_origine_Z = Val_origine_Z
    Old_Val_origine_Y = Val_origine_Y
    Old_Val_origine_X = Val_origine_X
    Sold_snom_RUD = snom_RUD
	
p_ugv    # macro pour activation code ugv
	if opcode$ <> 3 & opcode$ <> 16 & Type_UGV > 0 & old_Type_UGV <> 1, [
        if Type_UGV = 1, n$, "G8 P1", e$
		if Type_UGV = 2, n$, "G5.1 P1", e$
		if Type_UGV = 3, n$, "G5.1 Q1", e$
		if Type_UGV = 4, n$, "G5.2 Q.01", e$	#Valeurs a définir dans un mrx$
		if Type_UGV = 5, n$, "G5.3 P1", e$		#Valeurs a définir dans un mrx$
		if Type_UGV = 6, n$, "G5 P2", e$
		old_Type_UGV = 1
        ]

p_ugv_off  # arret pacro ugv
	if opcode$ <> 3 & opcode$ <> 16 & Type_UGV > 0 | old_Type_UGV = 1, [
		if Type_UGV = 1, n$, "G8 P0", e$
		if Type_UGV = 2, n$, "G5.1 P0", e$
		if Type_UGV = 3, n$, "G5.1 Q0", e$
		if Type_UGV = 4, n$, "G5.2 Q0.002", e$	#Valeurs a définir dans un mrx$
		if Type_UGV = 5, n$, "G5.3 P50", e$		#Valeurs a définir dans un mrx$
		if Type_UGV = 6, n$, "G5 P0", e$
		old_Type_UGV = 0
		]
		
p_rot_perc_profond  # ROT BROCHE POUR PERCAGE PROFOND
   if posi_p_prof = 1,     # hors matière
        [
        ssa = ssa * 0.1
        if ssa > 500, ssa = 500
        ]
    if posi_p_prof = 2, ssa = ss$    # dans la matière

fmt  "OP. MC. :" 4 op_number  #Operation number as seen in the Operations Manager
p_num_op_MC
    if affiche_num_op_MC = 1, [
        sOpId = no2str(op_id$)
        result = dll(sdllTimeOp,sOpId)
        if spost_arg_2$ <> s_old_spost_arg_2, n$, s_com_open, "OP. MC. :", spost_arg_2$, s_com_close, e$
        s_old_spost_arg_2 = spost_arg_2$
        ]
    #if affiche_num_op_MC = 2, if comm_cnt$ = zero, n$, s_com_open, *op_number, scomm$, s_com_close, e$  #Comment using MSG("") - When no op comment was entered, output just the op number
	if affiche_num_op_MC = 2, n$, s_com_open, *op_number, s_com_close, e$  #Comment using MSG("") - When no op comment was entered, output just the op number

p_affiche_type_op_MC
	if affiche_type_op_MC = 1 & affiche_type_op_MC <> old_affiche_type_op_MC, 
		[
		if tool_op$ > 99 & tool_op$ < 109, tool_op$ = tool_op$ + 18
		if tool_op$ > 200 & tool_op$ < 240, tool_op$ = tool_op$ + 83
		if tool_op$ > 415 & tool_op$ < 462, tool_op$ = tool_op$ + 77
		n$, s_com_open, *s_too_lop, s_com_close, e$ 
		old_affiche_type_op_MC = affiche_type_op_MC	
		!tool_op$ 
		]
				
p_Z_mini_maxi_OP
    if output_z = 1, [
        preadbuf5
        n$, s_com_open, "MAX OUTIL ", *max_depth, s_com_close, e$
        n$, s_com_open, "MIN OUTIL ", *min_depth, s_com_close, e$
        ]

p_debut_renvoi_angle	
	if ra_type$ = 1 & ra_block$ >0, [	# 1 =renvoie d'angle actif et NUM choix du multibroche
        lg_port_out_outil_block = paramT49 + paramT22
        n$, "#599 =", *lg_port_out_outil_block,  s_com_open, "LONGUEUR TOTALE DU PORTE OUTIL ET OUTIL :RENVOIE D ANGLE ", s_com_close, e$
        n$, s_com_open, "DEPUIS L AXE BROCHE AU BOUT D OUTIL", s_com_close, e$
        n$, s_com_open, "POUR INFO: LONG. DE SORTIE OUTIL SOUS LA PINCE:", *paramT22, s_com_close, e$
        n$, s_com_open, "COTE DEPUIS L AXE Z A LA FACE DU PORTE OUTIL:", *paramT49, s_com_close, e$
        p_dec_renvoi_angle 
		]
		
p_dec_renvoi_angle
    #20001
    #135.00 / 90.00 - Numéro porte-outil    #valeurs suivant ANGLES-DROIT 1-Horizontal et 2-Vertical 90= à plat
    #135.00 / 30.00 - Numéro porte-outil    #valeurs suivant ANGLES-CIRCULAIRE 1-Horizontal et 2-Vertical "5 AXES"
    #20008
    #0. 0. 1. 0 0. 0. 0 0. 29.99    29.99--> longueur de L'AXE Z à la FACE du PORTE PINCE (TOUT ANGLES)
    #1028
    #1 1 0.8660254 -0.5 0. -0.70710678 0.70710678 0. 222 0 0 0
    #1029
    #0. 0. 0. 0. 0. 0. 1.999 2.999 3.999 0 0     decalage renvoie X1.999 Y2.999 Z3.999		val-->11	0=fixe 1=rotatif
    #20007
    #0. 13. 41.99 27. 8. 50. 25. 0 100. 100. 1 41.99 25.    41.99 longueur sortie outil
	# PRMCODE --> # Nci 1029 val 11	0=fixe 1=rotatif 15813 à 15829
    #rotaxtyp$ = 4    #POINTS depuis la vue de dessus NE FONCTIONNE PAS EN V2023 !
    if m8$ = 1, n$, "G52 Y#599", e$        	# suivant G18 XZ
    if m8$ = -1, n$, "G52 Y-#599", e$    	# suivant G18 XZ
    if m7$ = 1, n$, "G52 X#599", e$        	# suivant G19 YZ
    if m7$ = -1, n$, "G52 X-#599", e$    	# suivant G19 YZ
    #if m7$ <> 0 & m8$ <> 0, [
        Angle_PLAN_MC_renvoie_angle = atan2(-m8$,-m7$)
        decX = (cos(Angle_PLAN_MC_renvoie_angle)*50) * -1
        decY = (sin(Angle_PLAN_MC_renvoie_angle)*50) #* -1
        if ra_rot_head$ = 1, n$, s_com_open, "RENVOIE D ANGLE -CIRCULAIRE-", s_com_close, e$
		if ra_rot_head$ = 0, n$, s_com_open, "RENVOIE D ANGLE -FIXE-", s_com_close, e$
        n$, "#510 = ", *Angle_PLAN_MC_renvoie_angle, s_com_open, "ANGLE A plat MasterCam", s_com_close, e$
        n$, "#511 = (cos(#510)*#599) * -1", e$
        n$, "#512 = (sin(#510)*#599) ", e$
        n$, "G52 X#511 Y#512", e$
        n$, s_com_open, "DECALAGE CALCUL PP:", *decX, " ", *decY, s_com_close, e$
        n$, s_com_open, "ANGLE DU PLAN PP= ", *Angle_PLAN_MC_renvoie_angle, "DEG", s_com_close, e$
        n$, s_com_open, "INFOS DU PORTE OUTIL :", s_com_close, e$
        ANGLE_XY_renvoie_angle = atan2(ra_svecx$,-ra_svecy$)-90
        n$, s_com_open, "ANGLE PHYSIQUE XY PP= ", *ANGLE_XY_renvoie_angle, s_com_close, e$
        if ra_svecz$ = 0, ANGLE_Z_renvoie_angle = 90
        n$, s_com_open, "ANGLE PHYSIQUE A PLAT =90D MC:", *ANGLE_Z_renvoie_angle, s_com_close, e$
        n$, s_com_open, "NUM. du RENVOI MC= ", *ra_block$, s_com_close, e$
        n$, s_com_open, "0=FIXE 1=ROTATIF MC=", *ra_rot_head$, s_com_close, e$	# Nci 1029 val 11	0=fixe 1=rotatif
        n$, s_com_open, "TYPE DE RENVOI MC= ", *ra_type$, s_com_close, e$		# 0=No special HEAD 1= Right-Angle 2=Compound 3=Block drill 4=UST
		n$, " ", e$
        #]	
	# Sauvegarde de la configuration avant de forcer la config avec le renvoie d'angle 
	old_usecandrill = usecandrill$    	# utiliser cycle percage lamage
    old_usecanpeck  = usecanpeck$    	# utiliser cycle debourrage
    old_usecanchip  = usecanchip$    	# utiliser cycle brise copeaux
    old_usecantap   = usecantap$    	# utiliser cycle taraudage
    old_usecanbore1 = usecanbore1$    	# utiliser cycle alesage a l'alesoir
    old_usecanbore2 = usecanbore2$    	# utiliser cycle alesage a la barre
    old_usecanmisc1 = usecanmisc1$    	# utiliser cycle divers 1
    old_usecanmisc2 = usecanmisc2$    	# utiliser cycle divers 2
	# Forcer cette configuration avec le renvoie d'angle
	usecandrill$ = 0    # utiliser cycle percage lamage
    usecanpeck$  = 0    # utiliser cycle debourrage
    usecanchip$  = 0    # utiliser cycle brise copeaux
    usecantap$   = 0    # utiliser cycle taraudage
    usecanbore1$ = 0    # utiliser cycle alesage a l'alesoir
    usecanbore2$ = 0    # utiliser cycle alesage a la barre
    usecanmisc1$ = 0    # utiliser cycle divers 1
    usecanmisc2$ = 0    # utiliser cycle divers 2
	
	if ss$ > 2000, ss$ = S_maxi_renvoi_angle
    sauve_ra_tc_type_ = ra_tc_type$
    sauve_ra_block_ = ra_block$
    p_erreur_num_block_renvoie_angle
    if ra_rot_head$ = 0, p_erreur_angles_renvoie_angle
	#if type_renvoie_angle = 2, p_erreur_angles_renvoie_angle_2 # SI CONTRAINTE ANGULAIRE exemple 4*90deg .... 
	old_Angle_PLAN_MC_renvoie_angle = Angle_PLAN_MC_renvoie_angle

p_test_arcs_tete_renvoi
    if ra_type$ = 1 & ra_block$ >0, [
        if m8$ <> 1 & m8$ <> -1 & m7$ <> 1 & m7$ <> -1 & m9$ <> 1, linarc$ = 1        # Casse les arcs en lignes si pas G17-G18-G19
        else, linarc$ = 0
        ]

#endregion

#region pheader
p_Type_appel_outil
    if Type_appel_outil    = 1, [
        nom_outil            = 0        # Affiche le NOM de l'outil
        outils_param         = 0        # pour Valider / dévalider l'affichage des outils en parametres
        ]
    if Type_appel_outil    = 2, [
        nom_outil            = 1
        outils_param         = 0
        ]
    if Type_appel_outil    = 3, [
        nom_outil            = 0
        outils_param         = 1
        ]
pheader$     # ENTETE DE PROGRAMME
    if Mode_reglage_PP = 0, [
        n$, *axis_label, *srot_label, *rot_zero, *rot_dir, *rot_index, *rot_angle, *rot_type, *min_speed,
            *maxfrinv_m, *maxfrdeg, *maxfeedpm_m, *all_cool_off, *v9_coolant, e$
        ]
	compt_axes_rot = 0                                  # pour remetre a zero le nombre d'axe rotatif avant la lecture de la conbinaison d'axe
    if omitseq$ = 1, numcoment = 0                      # si pas de numero de bloc ne pas numeroter les commentaires
    debut = 1                                           # flag pour debut de prog
    p_Type_appel_outil
    old_omitseq = omitseq$                              # memo du mode de numerotation de ligne
    if progno$ = 0, [
        #Var_20_question = rpar(s_question_20, 1)       # convertir la valeur texte en valeur numerique
        #while Var_20_question = 0, q20                 # Question --> numéro de programme (MC=0)
        q20
        progno$ = Var_20_question
        ]
    progno_ = progno$
    entete_ = 1                                         # --> on passe dans ENTETE
    p_affiche_infos_config_armoire
    if utilise_palette = 1 | utilise_palette = 11, palette = 1
    "%", e$
    if CN_textes <> 0,  [                               # Si la machine accepte les commentaires
        if numcoment = 0, omitseq$ = 1                  # si pas de numero de bloc pour commentaires enlever les numeros de bloc
        if change_nom = 1, [
            pnom_nc
            ptest_nom
            snomprogentete = ucase(snomprogentete)
            if Type_progno = 1, progno$, e$     # Oxxxx
            if Type_progno = 2, *progno_, e$    # :xxxx
            n$, s_com_open, snomprogentete, s_com_close, e$
            s_com_open, *snom_entete, s_com_close, e$              
            ]
        else, [
            if Type_progno = 1, progno$     	# Oxxxx
            if Type_progno = 2, *progno_     	# :xxxx
                s_com_open, sprogname$, s_com_close, e$
            ]
        ]
    n$, s_com_open, "*************************************", s_com_close, e$
	s_nom_machine_entete = ucase (s_nom_machine_entete)
	n$, s_com_open, "MASTERCAM BY FICAM - POST V:", no_spc$, scustpost_revision, s_com_close, e$
	n$, s_com_open, "MACHINE:", s_nom_machine_entete, s_com_close, e$
	if rotation_A = 1 & diviseur = 1, n$, s_com_open, "EQUIPEE D UN AXE :", s_axe_rot_A, s_com_close, e$
	if rotation_B = 1 & diviseur = 2, n$, s_com_open, "EQUIPEE D UN AXE :", s_axe_rot_B, s_com_close, e$
	n$, s_com_open, "PROGRAMME CREE LE ", date$, " A ", time$, s_com_close, e$	
	if nom_programmeur_PC <> 0, [
		s_nom_ORDI = sysinfo(result, 2)
		posi_nom_programmeur = strstr(s_slash, s_nom_ORDI)
		posi_nom_programmeur = posi_nom_programmeur + 1
		s_nom_programmeur = brksps(posi_nom_programmeur, s_nom_ORDI)
		posi_nom_programmeur = posi_nom_programmeur - 2
		s_nom_ORDI2 = brksps(posi_nom_programmeur, s_nom_ORDI)
		s_nom_ORDI = ucase (s_nom_ORDI)
		s_nom_programmeur = ucase (s_nom_programmeur)
		if nom_programmeur_PC <> 1, n$, s_com_open, "NOM DE L'ORDINATEUR :", *s_nom_ORDI, s_com_close, e$
		if nom_programmeur_PC <> 2, n$, s_com_open, "NOM DU PROGRAMMEUR :", *s_nom_programmeur, s_com_close, e$		
		]
    n$, s_com_open, "*************************************", s_com_close, e$
	n$, s_com_open, "FICHIER MC: ", *smcname$, no_spc$, *smcext$, s_com_close, e$
    n$, s_com_open, "FICHIER ISO: ", *snamenc$, no_spc$, *sextnc$, s_com_close, e$
	if entete_questions = 2, p_questions_entete     # nouvelles questions d'entête
    if entete_questions = 3, p_entete_questions_3   # ANCIEN SYSTEME questions
    if entete_questions = 1,     [
        if entete_ = 1 & longTexte = 0,     [
            n$, "( ***************************** )", e$
            n$, "( *****OP POUR MODIF***** )", e$
            ]
        ]
    n$, " ", e$
    if tooltable$ <> 0, [
        n$, s_com_open, "LISTE OUTILS", s_com_close, e$
        if outils_param = 1,    [
            n$, s_com_open, "MODIFIER LES NUMEROS D OUTILS", s_com_close, e$
            n$, s_com_open, "UNIQUEMENT DANS LA LISTE D OUTILS APRES LE =", s_com_close, e$
            n$, s_com_open, "NE PAS MODIFIER LES -T H ET D- DANS LE PROGRAMME", s_com_close, e$
            n$, " ", e$
            ]
        ]
    omitseq$ = old_omitseq      			# rappel des nummeros de bloc
#endregion

#region prEparation outils en NOM
# Tool Preselect variables
next_tlchg_gcode    : 0
is_next_tlchg_phys  : no$
sinvalid            = "-99999"
read_counter        : 0     #Used as a counter in pstagetool
first_op_id         : 0     #op_id$ for first operation
#strings
stoolname           : ""    #Return string for functions
#sblank             : ""
s_plus_outil        : "-99999"
stoolname_err       : "ERREUR - OUTIL APPELE SANS NOM." + no2asc(13) + no2asc(13) +
                    	"See tool_as_name in pst to set tool call format and tool definition in operation to set tool name."
#endregion

#region appel_outils
pstagetool      #Pre-stage tools    # en plus pour afficher le NOM DE L'OUTIL SUIVANT
    if bldnxtool$ = 1, [
        if nom_outil = 1,  #Tool call uses tool name
          [
          if ttblend$,  #If this is the last toolchange of the program
            [
            if type_prep_outil = 1,  #stage first tool at last toolchange
              [
              first_op_id = streaminfo(1, 1)             #Get the operation ID for the first operation in the sequence
              stoolname = opinfo(10094, first_op_id, 1)  #Get the tool name for the first operation
              if stoolname = sblank, stoolname = "ERROR-BLANK_NAME"
              n$, "T", no_spc$, stoolname, e$  #Stage first tool
              ]
            ]
          #else,  #stage tool at every toolchange
            #[
            next_tlchg_gcode = opinfo(92, 1)
            if next_tlchg_gcode = 1002, stoolname = opinfo(10094, 1)
            else,    [
            read_counter = 1
              is_next_tlchg_phys = no$
              while is_next_tlchg_phys = no$,
              [
              read_counter = read_counter + 1
                next_tlchg_gcode = opinfo(92, read_counter)
                if next_tlchg_gcode = 1000, is_next_tlchg_phys = no$
                else,
                  [
                  stoolname = opinfo(10094, read_counter)
                  is_next_tlchg_phys = yes$
                  ]
                ]
              ]
            if stoolname = sblank, stoolname = "ERREUR-OUTIL SANS NOM"
            if stoolname <> s_plus_outil, n$, "T", no_spc$, stoolname, e$  #Stage first tool
            #]
          ]
        ]

p_info_outils
    strtool$ = ucase(strtool$)
    if Type_infos_outil    = 1, n$, s_com_open, strtool$, s_com_close, e$
    if Type_infos_outil    = 2, n$, s_com_open, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
    if Type_infos_outil    = 3, n$, s_com_open, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
    if Type_infos_outil    = 4, n$, s_com_open, strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$

p_affiche_outil    # ecriture de l'appel outil pour psof et ptlchg4	
    num = num + 1                                                           # Nom du groupe d'operation
    P_f_val_origine_depart_idem
    p_erreur_dif_T_H_D
    perreur_pas_fil
    if tool_typ$ = 5, ss$ = (abs(ss$))*-1                               # si taraud à gauche inverser le sens de broche
    ssa = abs(ss$)
	if ra_type$ = 1 & ra_block$ >0 & ssa > S_maxi_renvoi_angle, result = mprint(s_erreur_S_maxi_renvoi_angle), ssa = S_maxi_renvoi_angle
    n$, " ", e$
    pnomgroupe
    p_num_op_MC
	p_affiche_type_op_MC
    if sauve_ra_tc_type_ = 2 & sauve_ra_block_ = 2, n$, "M0", s_com_open, "VEUILLEZ RETIRER L'OUTIL MANUELLEMENT", s_com_close, e$, sauve_ra_block_ = -1
    if nextdc$ = 19, posi_p_prof = 1, p_rot_perc_profond     # ROT BROCHE POUR PERCAGE PROFOND
    comment$
    #pcan
    if Position_info_outil = 1, p_info_outils
    strtool$ = ucase (strtool$)                                     # convertir en MAJUSCULES le nom outil
    if ra_tc_type$ <> 2, [    #pas de renvois d'angle et mode de changemnt automatique
        if nom_outil = 1, [
            if strtool$ = svide, n$, s_com_open, "ERREUR-OUTIL SANS NOM", s_com_close, e$
            #else, num, "T-A DEFINIR ", '"', *strtool$, '"', "M6", e$
			else, num, "T", no_spc$, *strtool$,  "M6", e$	#HURCO -->T1234 (et D1,2,3...)
            if rpd_typ$ <> 7 & bldnxtool$ = 1, [	#pstagetool
				if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, pstagetool
				]
            ]
        if outils_param = 0 & nom_outil = 0, [  # sans les parametres
            outil = t$
            outil_suivant = next_tool$
            num, *outil, "M6", e$
            if rpd_typ$ <> 7 & bldnxtool$ = 1, [ 
				#(ra_type$ = 0 & outil_suivant < 61 & outil_suivant > 63), n$, *outil_suivant, e$
				if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, n$, *outil_suivant, e$
				]
            ]
        if outils_param = 1 & nom_outil = 0,  [ # avec les parametres
            outil_param = t$
            outil_suiv_param = next_tool$
            outil_param = outil_param + 500
            outil_suiv_param = outil_suiv_param +500
            num, "T", no_spc$, 35, *outil_param, "M6", e$
            if rpd_typ$ <> 7 & bldnxtool$ = 1, [
				#(ra_type$ = 0 & next_tool$ < 61 & next_tool$ > 63), n$, "T", no_spc$, 35, *outil_suiv_param, e$
				if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0,  n$, "T", no_spc$, 35, *outil_suiv_param, e$
				]
            ]
        ]
    if ra_tc_type$ = 2, [    #renvois d'angle à changement manuel
        n$, s_com_open, "OUTIL A RENVOI D ANGLE A CHARGER MANUELLEMENT", s_com_close, e$
        n$, "M0", e$
        n$, s_com_open, "OUTIL NUMERO : ", *t$, s_com_close, e$
        ]
    if program_stop = 11, pcan1, n$, sm00, e$
    if program_stop = 22, pcan1, n$, sm01, e$
	p_debut_renvoi_angle
    if Position_info_outil = 2, p_info_outils
    if deg_apres_outil > 0, [
        old_type_deg = deg_outil        # Memo Valeur
        deg_outil = deg_apres_outil     # Affectation pour Valeur deg. apres outil
        p_degage_ptlchg                 # Retour suivant Valeur deg. apres outil
        deg_apres_outil = old_type_deg  # Réaffectation de la valeur de base
        ]
    pfrvar
	if CN_textes <> 0, param_comp       # afficher le type de compensation
    if CN_textes <> 0, param_surep      # afficher les surepaisseurs
    pcan
    if nextdc$ >= 8 & nextdc$ < 18, [
        n$, "M5 M9", e$
        palpeur = 1
        palpage = 1
        ]
    if nextdc$ < 8 | nextdc$ > 18,     # ROT BROCHE SAUF BROSSE, PALPAGES & PERCAGE PROFOND
        n$, *ssa, pgamme, *spdlon, e$, n$, p_lubrif_ON, e$
    comment$
    gcode$ = 5
    !gcode$
    if nextdc$ < 9, perreur_vit_broche
	old_t = t$
#endregion

#region psof_debut
p_palette_debut
	if utilise_palette > 0, [   # PALETTES
         if useaxe = 1, [    	# VALEURS UNIQUEMENT SI ON UTILISE L AXE A
            if deg_palette_deb_fin > 0, [
                old_degageX     = degageX
                old_degageY     = degageY
                old_degageZ     = degageZ
                degageX        	= degageX_pal
                degageY        	= degageY_pal
                degageZ        	= degageZ_pal
                deg_debut 		= deg_palette_deb_fin
                p_degage_debut
                degageX        	= old_degageX
                degageY        	= old_degageY
                degageZ        	= old_degageZ
                ]
            n$, "T0 M6", s_com_open, "DECHARGE DE L'OUTIL EN BROCHE", s_com_close, e$
            n$, s_com_open, "POUR ROTATION PALETTE AVEC L AXE -A-B-", s_com_close, e$
            ]
        if Var_16_question > 0, n$, "M127", s_com_open, "ROTATION PALETTE A", s_com_close, e$
        if Var_17_question > 0, n$, "M128", s_com_open, "ROTATION PALETTE B", s_com_close, e$
        n$, "M44", s_com_open, "RIDEAUX EAU ON", s_com_close, e$
        n$, "G0 G17 G49 G80 G90", e$
        ]

psof0$       # DEBUT DE PROGRAMME pour T=0
    psof$

psof$        # DEBUT DE PROGRAMME T<>0
    p_restriction_PP  
    P_f_val_origine_depart_idem
    #p_lire_axes                                   # Lecture des parametres de la combinaison d'axes uniquement
    if renvoi_d_angle = 0 & rotation_axe = 2, result = mprint(serreur2)
    if renvoi_d_angle = 1 & rotation_axe = 2, result = mprint(serreur2_2)
    if Mode_reglage_PP = 0, [
         "************A:", *rotation_A, " B:", *rotation_B, " rotation gEnErale", *rotation_axe, " div:" *diviseur, e$
        " syncax", *syncaxis$, " old_sync", *old_syncaxis, " nbr_combi", *nbr_combi, " compt_axes_rot", *compt_axes_rot, e$
        " M1", *m1$, " M5", *m5$, " M7", *m7$, " M8", *m8$, " M9", *m9$, e$
        ]
    if lire_def_machine = 0, [                      # affecter les valeurs suivant inclinaisons du programme
        if rotation_A = 1, [
            if diviseur = 2, p_erreur_choix_axe
            diviseur = 1, useaxe = 1
            ]
        if rotation_B = 1, [
            if diviseur = 1, p_erreur_choix_axe
            diviseur = 2, useaxe = 1
            ]
        ]
    if rotation_A =1 | rotation_B =1 & rotation_axe = 1, useaxe = 1
        else, useaxe = 0
    if lire_def_machine = 1, [
        if diviseur = 1 & rotation_B = 1, result = mprint(serreur3) # erreur: rotation sur B avec du A
        if diviseur = 2 & rotation_A = 1, result = mprint(serreur4) # erreur: rotation sur A avec du B
        ]
    if rotation_A = 1, result = nwadrs(s_axe_rot_A, axe_AB)
    if rotation_B = 1, result = nwadrs(s_axe_rot_B, axe_AB)
    #
    if outils_param = 1,  [                      # avec les parametres
        n$, " ", e$
        n$,  s_com_open, 35, "549 =X - X= NUMERO DU CORRECTEUR EN PLUS)", e$
        n$,  "(--T -- NUM. OUTIL CONCERNE)", e$
        ]
    if tooltable$ <> 0 & CN_textes <> 0, [      # Si liste des outils et textes supportés
        if numcoment = 0, omitseq$ = 1          # Si pas de numero sur les commentaires
        #n$, " ", e$
        omitseq$ = old_omitseq
        ]
    entete_ = 0
	# TEMPS
	info_temps = 2, p_temps_affectation
	if Affiche_temps_dll = 1, [ 	# TEMPS DE L OUTIL			
		if Types_Temps_DLL = 2, [
			p_Convert_time_dll 
			n$, "  ", s_com_open, "TPS OUT. = ", *Heure, *min, *sec, s_com_close, e$
			]	
		]	
	info_temps = 3, p_temps_affectation
	if Affiche_temps_dll = 1 & Types_Temps_DLL = 3, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS BRUT TOTAL MC ", *Heure, *min, *sec, s_com_close, e$	
		]
	time_total = 0
	Tot_time_Out = 0
	#
	if affiche_ori_entete = 1, mergesub$, n$, " ", e$        				# ICI les origines utilisés par MC (depuis pwrtt$)
    if affiche_ori_entete = 11 & old_workofs <> 54, mergesub$, n$, " ", e$  # ICI les origines utilisés par MC (depuis pwrtt$)
	if affiche_ori_entete = 1 | affiche_ori_entete = 11, clearsub$			# Sup. des origines dans la mémoire
	if block_form, p_block_form, n$, " ", e$
	# ICI descripteur si actif dans la machine et config PP
	comment$ 
	debut = 0
	#
    ptravel
    pwritbuf5
    if output_z = 1, n$, s_com_open, "TRAVAIL MAX PIECE ", *z_tmax, s_com_close, e$
    if output_z = 1, n$, s_com_open, "TRAVAIL MIN PIECE ", *z_tmin, s_com_close, e$
    ## subout$ = 0
    gcode$ = 0
    plane$ = 3                                  # pour focer le rappel G17 G18 G19
    !plane$
    old_origine = -9999                         # pour forcer l'affichage du G54 au chg outil
    old_correcteur_H = -99999                   # pour forcer l'appel du G43
    n$, *sgcode, "G94 G90 G40 G80 G98 G17", e$  # Initialisation de la machine
	if convoyeur = 1, n$, s_convoyeur_ON, e$
    incremental = 0                             # pour re forcer l'affichage du mode Absolue
    p_palette_debut	# PALETTES
    p_degage_debut
	comment$ 
    p_affiche_outil
	#temps DLL
	Tot_time_op = 0	#remise à 0 entre l'entete et OPs
	info_temps = 4, p_temps_affectation
	p_temps_dll	# lecture du temps de l'OP dans la DLL
    #
	p_Z_mini_maxi_OP
    if tool_op$ = 114, cant_no$ = 0 #tool_op$ 114 = perCage AVANCE #pour ne pas afficher un arrosage erroné au debut
    p_placement_apres_chang_outil                       	# AFFICHAGE DES MOUVEMENTS MACHINE
    perreur_vit_broche
    p_ugv
    if opcode$ = 16, drill_4_axes = 1
	# Z de départ perçage 5 axes
	if opcode$ = 16 & diviseur = 1, old_z = ynci$  
	if opcode$ = 16 & diviseur = 2, old_z = xnci$ 
    p_test_arcs_tete_renvoi
#endregion

#region placement_apres_chang_outil
p_placement_apres_chang_outil           # AFFICHAGE DES MOUVEMENTS MACHINE
    if Mode_reglage_PP = 0, "--> p_placement_apres_chang_outil", e$
	@rotaxis$                           # mise a jour du type de substitution d'axe
    old_workofs = -999					# Force l'affichage du décallage après le changement d'outil
	if nextop$ = 11,    [               # si  4 axes avec fonction 5 axes
        gcode$ = 0                      # Force le gcode a 0 pour faire un G0 apres
        x$ = xr$
        y$ = yr$
        z$ = zr$
        axe_AB = 0
        axeA1_dep = 0
        old_axeA1 = 0
        debutpmx = 1                    # flag pour faire l'appel outil
        ]
    if nextop$ <> 11,   [               # utilisation en positionné ou substitution
        gcode$ = 0                      # Force le gcode a 0 pour faire un G0 apres
        x$ = xr$                        # prise en compte de XYZ
        y$ = yr$
        z$ = zr$
        xabs = x$
        yabs = y$
        zabs = z$
        if ra_block$ >0, p_calcul_xyz_tete_renvoie                      # RENVOIE D'ANGLE
        if rotaxis$ = 0,    [                                           # 3 axes + diviser en positionne
            p_calcul_rot_posit                                          # calcul rotation plateau
            if Systeme_rot_plans <> 5, old_axe_AB = -99999                # pour forcer l'affichage
            p_ori_usi
            n$, *sgcode, *sinc_abs, p_type_avance, "G17", *xabs, *yabs, e$
            p_rot_ptlchg                                                # affichage de l'angle au chg outil
            n$, pcorh, *zabs, e$
            ]
        if rotaxis$ <> 0,   [                                           # utilisation en substitution
            p_calcul_rot_posit
            p_calcul_AB_pos_Subs
            if mi7$ = 1, bloque = 2, n$, sbloque, e$        			# déblocage de l'axe A/B
            if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0                   # diviseur tourne autour de Y (X sbstitue)
            if rotaxis$ = -2 | rotaxis$ = 2,  yabs = 0                  # diviseur tourne autour de X (Y sbstitue)
            p_ori_usi
            n$, *sgcode, *sinc_abs, p_type_avance, "G17", *axeAB_subs, e$
            if mi7$ = 1, bloque = 1, n$, sbloque, e$					# si ROT - Bloque
			n$, *xabs, *yabs, e$
            n$, pcorh, *zabs, e$
            ]
        p_modal                                                                 	# affectation en format modal
        !x$, !y$, !z$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc, !axe_AB, !axe_ABi  	# mise à jour des positions affichées
        ]
    if tool_op$ = 100, n$, "(PAS DU FILETAGE = ", *pas_filetage, s_com_close, e$    # affichage de la valeur du vrai filetage
    perreur_vit_broche
    old_ssa = ss$               # memo de la vitesse de broche
    old_op_id = op_id$          # memo du numero d'operation
    old_rotaxis = rotaxis$      # memo du type de substitution
    old_x = xabs                # memo X Y Z
    old_y = yabs
    old_z = zabs
    c_mmlt$                     # Multiple tool subprogram call
    c_msng$						# Single tool subprogram call
#endregion

#region ptlchg0
ptlchg0$     # CHANGEMENT D'OUTIL NUL
    Perreur_nom_RUD
    perreur_pas_fil
    p_erreur_dif_T_H_D
    memo_incremental = incremental                  # memo du mode ABS INC actuel
    incremental = 0                                 # pour forcer le mode Absolue
    @rotaxis$, @old_rotaxis                         # mise a jour
    gcode$ = 0                                      # Force le gcode a 0 pour faire un G0 apres
    linarc$ = 0                                     # pour activer les G2 G3
    typcycle = 0                                    # variable mise a 1 lors des percages pour afficher l'intitulé du cycle
    if Test_bris_outils = 1, [
        pcool_off
        n$, "M5", e$
        p_test_bris_outil
        pcan1_cool
        n$, *spdlon, *ssa, e$
        ] 
	if op_id$ <> old_op_id, [	
		#temps DLL
		info_temps = 4, p_temps_affectation
	    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
			p_Convert_time_dll
			n$, s_com_open, "TEMPS DE L OPE. = ", *Heure, *min, *sec, s_com_close, e$
			]
		p_temps_dll
		#  
	    pnomgroupe                                  # Nom du groupe d'operation
	    p_num_op_MC
		p_affiche_type_op_MC
		]
	affiche_m0 = 1
	comment$                                        # commentaires d'operation
    if CN_textes <> 0, param_comp                   # afficher le type de compensation
    if CN_textes <> 0, param_surep                  # afficher les surepaisseurs
    if tool_typ$ = 5, ss$ = (abs(ss$))*-1           # si taraud à gauche inverser le sens de broche
    if ss$ <> old_ssa, ssa = ss$, n$, *ssa, pgamme, *spdlon, e$     # si changement de vitesse de broche l'afficher
    if ra_type$ = 1 & ra_block$ >0, [				# Renvoi d'ANGLE
		Angle_PLAN_MC_renvoie_angle = atan2(-m8$,-m7$)
		if Angle_PLAN_MC_renvoie_angle <> old_Angle_PLAN_MC_renvoie_angle, [
			if type_renvoie_angle = 9, result = mprint(s_erreur_angle_renvoi_fixe) 
			p_degage_4_axes
			n$, "G52 X0 Y0 Z0", e$
			p_dec_renvoi_angle     						# 1 =renvoie d'angle actif et NUM choix du multibroche
			]
		]
    if nextop$ <> 11, [                             # utilisation en positionné ou substitution
        gcode$ = 0                                  # Force le gcode a 0 pour faire un G0 apres
        xabs = x$                                   # prise en compte de XYZ
        yabs = y$
        zabs = z$
        if rotaxis$ = 0, [                          # 3 axes + diviseur en positionné
			p_calcul_rot_posit                      # calcul rotation plateau
            p_ori_usi                           	# affichage de l'origine d'usinage
            p_rot_tlchg0                            # affichage de l'angle
			]
        if rotaxis$ <> 0,  [                        # si on passe de positionné à SUBSTITUTION     & old_rotaxis = 0
            p_calcul_rot_posit                                              # Convertir les G2 G3 en G1
            p_calcul_AB_pos_Subs                                            # calcul de l'axe A en substitution
            if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0                       # diviseur tourne autour de Y (X sbstitue)
            if rotaxis$ = -2 | rotaxis$ = 2, yabs = 0                       # diviseur tourne autour de X (Y sbstitue)
            p_Apos_affiche_subs                                             # affichage de l'angle au chg outil nul pour continue/substitution
            p_ori_usi
            n$, zabs, e$
            n$, sgcode, sinc_abs, xabs, yabs, !xinc, !yinc, e$
            n$, sgcode, sinc_abs, zabs, !zinc, e$
            p_modal                                                         # affectation en format modal
            !x$, !y$, !z$, !xabs, !yabs, !zabs, !xinc, !yinc, !zinc, !axe_AB, !axe_ABi  # mise à jour des positions affichées
            ]
        ]
    if nextop$ = 11,   [                               # si 4 axes avec fonction 5 axes
        if op_id$ <> old_op_id,    [
            old_axeA1 = 0
            axeA1_dep = 0
            p_ori_usi                              # affichage de l'origine d'usinage
            ]
        ]
    
	if opcode$ = 16, drill_4_axes = 1
    p_ugv
    p_test_arcs_tete_renvoi
    incremental = memo_incremental      # rappel du mode incremental ou absolue précédent
    old_ssa = ss$                       # memo de la vitesse de broche
    old_op_id = op_id$                  # memo du numero d'operation
    old_rotaxis = rotaxis$              # memo du type de substitution
    old_x = xabs                        # memo X Y Z
    old_y = yabs
    old_z = zabs
    p_erreur_choix_axe_substitution
    c_mmlt$     # Multiple tool subprogram call
	c_msng$		# Single tool subprogram call
#endregion

#region ptlchg
pspindle        #Spindle speed calculations for RPM
    ssa = abs(ss$)
    @old_ssa
    if ssa, [
        if ssa > maxss$, ssa = maxss$
        if ssa < min_speed, ssa = min_speed
        ]
    spdlsel = fsg3(spdir$)

pspindchng      #Spindle speed change
    if prv_spdlsel <> spdlsel & old_ssa <> zero, p_bloc_O, n$, *sm_01, e$
    if old_ssa <> ssa | prv_spdlsel <> spdlsel, [
        if ssa <> 0, [
             n$, ssa, e$
            ]
        if spdlsel <> 1, n$, *spdlon, e$
        old_ssa = ssa
        ]
    if tool_op$ <> 114, perreur_vit_broche
    !ssa, !spdlsel

ptoolend$        #End of tool path, before reading new tool data
    !ssa, !spdlsel
    Test_bris_outils = mi6$

ptlchg$      # CHANGEMENT D'OUTIL
    increment_op_outil = 1
    p_lubrif_OFF
    pas = 0
	if s_reset_AB <> svide, n$, s_reset_AB, e$
    if Test_bris_outils = 1, p_test_bris_outil
    p_ugv_off
    if decalage = 1 | sauve_ra_block_ >0, [     # Annulation du décallage FIN du renvoie d'angle
        p_annule_decalage                       # annuler les decalages d'origine
		usecandrill$ = old_usecandrill
	    usecanpeck$  = old_usecanpeck
	    usecanchip$  = old_usecanchip
	    usecantap$   = old_usecantap
	    usecanbore1$ = old_usecanbore1
	    usecanbore2$ = old_usecanbore2
	    usecanmisc1$ = old_usecanmisc1
	    usecanmisc2$ = old_usecanmisc2				
        #p_cycles_valides                        # réactives les cycles utilisables après le Renvoie
        sauve_ra_block_ = 2
        ]
    n$, *sm_01, e$	#"M5"
    p_degage_ptlchg
	debut_out = 1
    gcode$ = 0
    if program_stop = 1, pcan1, n$, sm00, e$
    if program_stop = 2, pcan1, n$, sm01, e$
	#temps DLL
	info_temps = 4, p_temps_affectation	
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS DE L OPE. = ", *Heure, *min, *sec, s_com_close, e$
		]  
	info_temps = 5, p_temps_affectation
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 5, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS DE L OUTIL= ", *Heure, *min, *sec, s_com_close, e$
		Tot_time_op = 0
		Tot_time_Out = 0	
		]		
	#
	if nbrtour <> 0 ,   [                   # pour remise a zero du diviseur
        old_axe_AB = 0
        axe_AB = 0
        nbrtour = 0
        ]
    avance = -1                             # pour rappel de l'avance sur le premier G1
    !avance
    plane$ = 3                              # pour focer le rappel G17 G18 G19
    !plane$
    memo_incremental = incremental          # memo du mode incremental
    incremental = 2                         # pour re forcer l'affichage du mode Absolue
    !incremental
    incremental = 0                         # pour forcer le mode Absolue
    old_origine = -9999                     # pour forcer l'affichage du G54 au chg outil
    old_correcteur_H = -99999               # pour forcer l'appel du G43
    linarc$ = 0                             # pour activer les G2 G3
    typcycle = 0                            # variable mise a 1 lors des percage pour afficher l'intitulé du cycle
    p_affiche_outil                         # APPEL OUTIL
	#temps DLL
	info_temps = 4, p_temps_affectation
	p_temps_dll	# lecture du temps de l'OP dans la DLL		
   	#
    p_Z_mini_maxi_OP
    if ra_type$ = 1 & ra_block$ >0, p_dec_renvoi_angle    # 1 =renvoie d'angle actif et NUM choix du multibroche
    p_placement_apres_chang_outil           # AFFICHAGE DES MOUVEMENTS MACHINE
    incremental = memo_incremental          # pour revenir au mode precedent
    p_ugv
    if opcode$ = 16, drill_4_axes = 1
    p_test_arcs_tete_renvoi
    p_erreur_choix_axe_substitution
#endregion

#region peof_fin
p_palette_fin
	if utilise_palette > 0, [    # PALETTES
        if useaxe = 1, [
            n$, "T0 M6", s_com_open, "DECHARGE DE L'OUTIL EN BROCHE", s_com_close, e$
            n$, s_com_open, "POUR ROTATION PALETTE AVEC L AXE -A-", s_com_close, e$
            ]
        n$, "M45", s_com_open, "RIDEAUX EAU OFF", s_com_close, e$
        if useaxe = 1, [
            if deg_palette_deb_fin > 0, [
                old_degageX     = degageX
                old_degageY     = degageY
                old_degageZ     = degageZ
                degageX        	= degageX_pal
                degageY        	= degageY_pal
                degageZ        	= degageZ_pal
                deg_fin 		= deg_palette_deb_fin
                p_degage_fin
                degageX        	= old_degageX
                degageY        	= old_degageY
                degageZ        	= old_degageZ
                ]
            ]
        if Var_16_question > 0, n$, "M128", s_com_open, "RETOUR ROTATION PALETTE B", s_com_close, e$
        if Var_17_question > 0, n$, "M127", s_com_open, "RETOUR ROTATION PALETTE A", s_com_close, e$
        n$, "G0 G17 G49 G80 G90", e$
        # COMPTEURS FANUC PALETTES
        if Var_16_question > 0, n$, "#500=#500+", no_spc$, *Var_16_question, s_com_open, "COMPTEUR PALETTE A", s_com_close, e$
        if Var_17_question > 0, n$, "#500=#500+", no_spc$, *Var_17_question, s_com_open, "COMPTEUR PALETTE B", s_com_close, e$
        if Var_16_question > 0 & Var_17_question > 0, result = mprint(s_erreur_choix_palette)
        if Var_16_question < 1 & Var_17_question < 1, result = mprint(s_erreur_choix_palette)
        ]

peof0$
   peof$
	
peof$
    #n$, "G0", *zrp, e$
    p_lubrif_OFF                        	# Arret lubriff
    p_ugv_off
    n$, "M5", e$                            # Arret broche
    if decalage = 1 | sauve_ra_block_ >0, [     # Annulation du décallage FIN du renvoie d'angle
        p_annule_decalage                       # annuler les decalages d'origine
        sauve_ra_block_ = -1
        ]
    if Test_bris_outils = 1, p_test_bris_outil
    gcode$ = 0                              # Force le gcode a 0 pour faire un G0 apres
    incremental = 2                         # pour re forcer l'affichage du mode Absolue
    !incremental
    incremental = 0                         # pour forcer le mode Absolue
    if (old_tox4 <> 0 ) | (old_toy4 <> 0) | (old_toz4 <> 0), n$, "G52X0Y0Z0", e$
    p_degage_fin                            # Dégagement de la machine fin de prog
    if bldnxtool$ = 1 & type_prep_outil = 2,    [
        if nom_outil = 1, [                             	# Tool call uses tool name
            first_op_id = streaminfo(1, 1)              	# Get the operation ID for the first operation in the sequence
            stoolname = opinfo(20001, first_op_id, 1)      	# Get the tool name for the first operation
            if stoolname = sblank, stoolname = "ERREUR-OUTIL SANS NOM"
            n$, "T", no_spc$, stoolname, e$
            ]
        if outils_param = 0 & nom_outil = 0, n$, "T", next_tool$, "M6", e$              # sans les parametres
        if outils_param = 1 & nom_outil = 0, n$, "T", no_spc$, 35, *outil_suiv_param, "M6", e$   # AVEC les parametres
        ]
    # Déchargement de l'outil en broche
    if bldnxtool$ <> 1 & type_prep_outil < 1 & decharge_outil_fin = 1,    [
        if outils_param = 0 & nom_outil = 0, n$, "T0 M6", e$
        if outils_param = 1 & nom_outil = 0, outil_suiv_param = 0, n$, "T", no_spc$, 35, *outil_suiv_param, "M6", e$
        ]
		
    if useaxe <> 0 & old_axe_AB <> 0,  [      # Remise a 0 de l'axe A si pas a Zero
        axe_AB = 0
        p_rot_ptlchg                        # affichage de l'angle
        ]
    plane$ = 3                              # pour focer le rappel G17 G18 G19
    !plane$
    plane$ = 0
    n$, splcode, sinc_abs, e$               # Plan XY mode Absolue
    comment$                                # commentaires d'operation
    #if palette = 1, n$, "M98", "P9901", e$
    if palpage = 1,    [
        n$, "GOTO 9999", e$
        "N9998 ", 35, "3000=1 (MAUVAIS PALPAGE -PARCOUR SUP.)", e$
        "N9999", e$
        ]
    p_palette_fin	# PALETTES
	if convoyeur = 1, n$, s_convoyeur_OFF, e$
	if compteur_pieces	= 1, n$, s_compteur_piece, e$ 
    #
    #n$, "M0", e$
    #n$, "M99", e$                          # fin de prog et rembobine au debut
	#temps DLL
	info_temps = 4, p_temps_affectation
	p_temps_dll	
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS OPE. = ", *Heure, *min, *sec, s_com_close, e$
		]  
	info_temps = 5, p_temps_affectation
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 5, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS OUTIL = ", *Heure, *min, *sec, s_com_close, e$
		Tot_time_op = 0
		Tot_time_Out = 0	
		]	
	info_temps = 6, p_temps_affectation
	if Affiche_temps_dll = 1 & Types_Temps_DLL = 6, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS TOTAL CORRIGE ", *Heure, *min, *sec, s_com_close, e$
		]  
	#
    if fin_programme = 1, n$, "M30", e$     # Fin si l'outil à renvoie d'angle non défini en longueur
    if fin_programme = 2, n$, "M02", e$
	if fin_programme = 3, n$, "M99", e$
	
	# Ajout pour les sous-programmes
    *e$                             		# Sauter une ligne
    subout$ = 0                             # Ecriture dan le NC
	
    mergesub$								# Ecriture du sous-prog "transformation"
	clearsub$								# Effacer les fichiers ".sub"
	#mergeext$
	#clearext$
	
	mergeaux$								# Sous-programme interne /passes en Z ..
	clearaux$ 								# Effacer les fichiers ".AUX" /passes en Z ..
    #if affiche_ori_entete = 2, mergeext$   # dans un autre fichier ".AUX"
    #if affiche_ori_entete = 22 & workofs_pwrtt > 54, mergeext$    # dans un autre fichier ".AUX"
    #clearext$                              # Effacer les sous-prog
    if affiche_ori_entete = 1 | affiche_ori_entete = 11, clearsub$	# Effacer les fichiers "sub" ORIGINES
    "%", e$                                 # fin de fichier
#endregion
#endregion

#region tool_inspection
ptool_insp      # inspection des plaquettes/outil
    p_lubrif_OFF
    pdeg_inspection_plaquette
    if prmcode$ = 29999,  [  #seulement le commentaire dans le controle d'outil
        sparameter$ = ucase(sparameter$)
        n$, "M0 ;", sparameter$, e$
        ]
    else, n$, "M0", e$
    n$, "(CONTROLE DE L ETAT -PLAQUETTES-OUTIL-)", e$
    n$, *spdlon, e$
    old_lubrif = -1
    n$, p_lubrif_ON, e$
    !gcode$
#endregion

#region test_bris_outil
sbris_outil  : "CALL PGM TNC:\USINAGE\L_BREAK_TEST.H"   # macro appel de sous programme pour test bris_outil
sbris_outil1 : "CALL PGM TNC:\dmg\BRIS-FORET.H"            # macro appel de sous programme pour test bris_outil
sbris_outil2 : "CALL PGM TNC:\dmg\BRIS-FRAISE.H"        # macro appel de sous programme pour test bris_outil

p_test_bris_outil                    # controle bris outil
    type_test_bris_outils = mi5$
    Test_bris_outils = mi6$
    if type_test_bris_outils <> 0,     [
        p_erreur_test_bris_out_nom
        if type_test_bris_outils = 1,    [
            n$, "(CYCLE DE TEST BRIS OUTIL)", e$
            n$, "(2. Tool Breakage Length, Non-rotating)", e$
            #n$, "( TOOL No. =", *varOut, ")", e$
            n$, "( TOLERANCE = 0.3 )", e$
            n$, "( SI OUTIL CASSE = ALARME )", e$
            n$, "G53G00G90Z23.708", e$
            if outils_param = 0 & nom_outil = 0, n$, "#20=", *t$, e$
            if outils_param = 1 & nom_outil = 0, n$, "#20=", *outil_param, e$
            n$, "#13=200 (AVANCE F)", e$
            n$, "IF[#20EQ#13]#3000=1 (TOOL_NUMBER AND SET_A_FLAG CANNOT MATCH)", e$
            n$, "G49", e$
            if outils_param = 0 & nom_outil = 0, n$, "G65P9023A24.", *outil, "H0.3", e$
            if outils_param = 1 & nom_outil = 0, n$, "G65P9023A24.T", no_spc$, 35, *outil_param, "H0.3", e$
            ]
        if type_test_bris_outils = 2,    [
            "CYCLE NUM. 2 DE BRIS D OUTIL A DEFINIR",e$
            n$, ";TEST BRIS OUTIL FRAISE", e$
            #n$, sbris_outil2, e$
            ]
        if type_test_bris_outils = 3,    [
            "CYCLE NUM. 3 DE BRIS D OUTIL A DEFINIR",e$
            ]
        type_test_bris_outils = 0
        Test_bris_outils = 0
        ]
#endregion

#region deplacements
p_type_tempo
	if dwell_tempo = 1, s_tempo = s_tempo + s_tempo_X
	if dwell_tempo = 2, s_tempo = s_tempo + s_tempo_U
	if dwell_tempo = 3, s_tempo = s_tempo + s_tempo_P
	
pdwl_spd$        #Call from NCI gcode 4    *** ROTATION BROCHE / TEMPO / ARROSAGES
    #"ICI : pdwl_spd$", e$
    pspindle
    comment$
    pspindchng
    pcan
    if fmtrnd(dwell$), dwell_ = dwell$, pcan1, p_bloc_O, n$, *dwell_, e$
    else, pcan1, p_bloc_O, #n$, strcantext, e$
    pcan2

#----------------CORPS DU CODE ISO G1 G2 G3 G0 -------------------------
prapid$      # Ligne en rapide
    #"ICI : prapid$ --> G0 X Y", e$
    p_correc_time_G0	
    xabs = x$
    yabs = y$
    zabs = z$
	if ra_block$ > 0, [        #avec le renvoie d'angle
		pcan1, p_bloc_O, n$, sgcode, sinc_abs, pxyz, p_lubrif_ON, strcantext, e$
		]
    if ra_block$ =0, [        #pas avec le renvoie d'angle
        if rot_tlchg_zero = 1,  [
            x_ = x$
            y_ = y$
            zp = z$
            #pcan1, p_bloc_O, n$, sgcode, sinc_abs, x_, y_, p_lubrif_ON, strcantext, e$
            pcan1, p_bloc_O, n$, sgcode, sinc_abs, pxyz, p_lubrif_ON, strcantext, e$
            rot_tlchg_zero = 0
            ]
        else, pcan1, p_bloc_O, n$, sgcode, sinc_abs, pxyz, e$
        ]

pzrapid$     # Ligne Z en rapide
    #"ICI : pZrapid$ --> G0 Z", e$
	p_correc_time_G0
    xabs = x$
    yabs = y$
    zabs = z$
	gcode$ = 0 
	if ra_block$ = 0, [ # pas avec le RENVOIE D'ANGLE
	    if rot_tlchg_zero = 1 & zabs <> old_zabs, n$, sgcode, *zabs, e$
	    if rot_tlchg_zero = 0, [
			n$, sgcode, sinc_abs, pxyz, p_lubrif_ON, strcantext, e$
	        ]
		]

plin$        # Ligne travail
    #"ICI : plin$ ", e$
    xabs = x$
    yabs = y$
    zabs = z$
	p_percages_decomposes	
    if cc$ = 41 | cc$ = 42, n$, *sgcode, sinc_abs, pcorr, pxyz, pcorrecteur_D, pfr, p_lubrif_ON, strcantext, e$
    else, n$,  sgcode, sinc_abs, pcorr, pxyz, pfr, p_lubrif_ON, strcantext, e$
	if drillcyc$ >= 0 & dwell$ > 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1), n$, *dwell_, e$
    if rpd_typ$ = 7, ptool_insp     # inspection des plaquettes/outil

pz$      	# z en avance TRAVAIL
    #"ICI : pz$", e$
    xabs = x$
    yabs = y$
    zabs = z$
    n$, sgcode, sinc_abs, pxyz, pfr, p_lubrif_ON, strcantext, e$

pcir0$   # verif des arcs --> conversion en lignes si besoin
	@plane$
	#if sauve_ra_block_ <= 0, linarc$ = 0
	if rotaxis$ <> 0, linarc$ = 1	# Convertir les arcs en lignes si travail en substitution
	else, linarc$ = 0
	#if plane$ <> 0, linarc$ = 1	# pas d'arcs si G18 ou G19
	if ra_block$ >0, if m8$ <> 1 & m8$ <> -1 & m7$ <> 1 & m7$ <> -1, linarc$ = 1
	
pcir$        # Circulaire
    #"ICI : pcir$ ", e$
    p_modal     #affectation en format modal
    xabs = x$
    yabs = y$
    zabs = z$
    if arctype$ >= 5, pcir_r, p_lubrif_ON, strcantext, e$        # en R
    else, pcir_ij, p_lubrif_ON, strcantext, e$ # [if ra_block$ >0, rayon = arcrad$, s_com_open, no_spc$, *rayon, no_spc$, s_com_close ], e$    # en IJ

pcir_r      # Circulaire G2 G3 G17 G18 G19 en R
	if arctype$ = 5, rayon = arcrad$           # pour Rayon
    if arctype$ = 6 & abs(sweep$) <= 180, rayon = arcrad$  # pour Rayon signé
    if arctype$ = 6 & abs(sweep$) > 180, rayon = -arcrad$  # pour Rayon signé
    if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
    if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
    if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z
	if ra_block$ >0, [
		if (m8$ = 1 | m8$ = -1), plane$ = 2
		if (m7$ = 1 | m7$ = -1), plane$ = 1
		]
	n$, splcode, sinc_abs, *sgcode, pxyz, rayon, pfr

pcir_ij     # Circulaire G2 G3 G17 G18 G19 en IJ
    rayon = arcrad$	# pour l'info de la valeur du Rayon
	if plane$ = 0, p_casse_modalite_X, p_casse_modalite_Y
    if plane$ = 2, p_casse_modalite_X, p_casse_modalite_Z
    if plane$ = 1, p_casse_modalite_Y, p_casse_modalite_Z
	if ra_block$ >0, [
		if (m8$ = 1 | m8$ = -1), plane$ = 2
		if (m7$ = 1 | m7$ = -1), plane$ = 1
		]
	n$, splcode, sinc_abs, *sgcode, pxyz, pijk, pfr, [ if tool_op$ = 1, s_com_open, no_spc$, rayon, no_spc$, s_com_close ]

pijk        # ecriture des IJK pour G90 G91
    !i$, !j$, !k$
    if arctype$ = 1, [   # pour centre en absolue en G90
        iabs = i$
        jabs = j$
        kabs = k$
        iinc = i$ - prv_x$
        jinc = j$ - prv_y$
        kinc = k$ - prv_z$
        ]
    else,       [     # pour centre en relatif en G90
        iabs = i$
        jabs = j$
        kabs = k$
        iinc = i$
        jinc = j$
        kinc = k$
        ]
    if incremental = 0 & plane$ = 0 , *iabs, *jabs, !iinc, !jinc, !kinc
    if incremental = 0 & plane$ = 2 , *iabs, *kabs, !iinc, !jinc, !kinc
    if incremental = 0 & plane$ = 1 , *jabs, *kabs, !iinc, !jinc, !kinc
    if incremental = 1 & plane$ = 0 , !iabs, !jabs, *iinc, *jinc, !kinc
    if incremental = 1 & plane$ = 2 , !iabs, !kabs, *iinc, !jinc, *kinc
    if incremental = 1 & plane$ = 1 , !jabs, !kabs, !iinc, *jinc, *kinc

#   Gestion de la correction outil et du numéro de correcteur
pcorr
    if cc$ = 41 | cc$ = 42, cc$
    if cc$ = 140 | cc$ = 40, "G40"
    if cc$ = 140, cc$ = -1
    !cc$
    if cc$ = 140, !correcteur_D
    if nextop$ = 11, cc$ = 0

pcorrecteur_D
    correcteur_D = tloffno$     # + nbr_outil
	#if type_comp = 5 | type_comp = 6, correcteur_D = correcteur_D + 100 	# AJOUT DE 100 UNIQUEMENT POUR L'**USURE** (cohabitation du mode "armoire et usure")
    perreur_D
    if outils_param = 0,    [
        # UNIQUEMENT AU 1ER G41/G42
		#if correcteur_D <> old_correcteur_D, *correcteur_D
        #old_correcteur_D = correcteur_D
		#
		# A chaque G41/G42
		*correcteur_D
		#
        ]
    if outils_param = 1,    [
        correcteur_D_param = correcteur_D
        correcteur_D_param = correcteur_D_param +500
        p_erreur_dif_T_H_D
        #if correcteur_D_param <> old_correcteur_D_param, "D", no_spc$, 35, correcteur_D_param
        if correcteur_D_param <> old_correcteur_D_param, "D", no_spc$, 35, correcteur_D_param
        old_correcteur_D_param = correcteur_D_param
        ]

p_modal     # affectation en format modal X Y Z A garde profondeur ABS ET INC
    #"p_modal"
    result = newfs (2, xabs)
    result = newfs (11, xinc)
    result = newfs (2, yabs)
    result = newfs (11, yinc)
    result = newfs (2, zabs)
    result = newfs (11, zinc)
    result = newfs (2, axe_AB)
    result = newfs (11, axe_ABi)
    result = newfs (2, prof_abs)
    result = newfs (2, prof_inc)
    result = newfs (2, garde_abs)
    result = newfs (2, garde_inc)

p_casse_modalite_avance # casser la modalité de l'avance
    result = newfs (5, avance)

p_casse_modalite    # pour casser la modalité de Xabs et Xinc Yabs et Yinc Zabs et Zinc
    #"p_casse_modalite"
    p_casse_modalite_X
    p_casse_modalite_Y
    p_casse_modalite_Z
    p_casse_modalite_A

p_casse_modalite_X  # pour casser la modalité de Xabs et Xinc
    result = newfs (3, xabs)
    result = newfs (12, xinc)

p_casse_modalite_Y  # pour casser la modalité de Yabs et Yinc
    result = newfs (3, yabs)
    result = newfs (12, yinc)

p_casse_modalite_Z  # pour casser la modalité de Zabs et Zinc
    result = newfs (3, zabs)
    result = newfs (12, zinc)

p_casse_modalite_A  # pour casser la modalité de Zabs et Zinc
    result = newfs (3, axe_AB)
    result = newfs (12, axe_ABi)

p_casse_modalite_perce  # pour casser la modalité de prof_abs et prof_i garde_abs garde_i
    result = newfs (3, prof_abs)
    result = newfs (3, prof_inc)
    result = newfs (3, garde_abs)
    result = newfs (3, garde_inc)
#endregion

#region mouvements pxyz et 4 axes
pxyz        # ecriture des x, y, z en abs ou incremental pour corp ISO
    pxyz_new
    p_modal     # affectation en format modal
    !x$, !y$, !z$   # mise a jour xyz
    old_x = xabs    # memo des anciennes positions
    old_y = yabs
    old_z = zabs

#region calculs TETE DE RENVOIE
pcalcul_plan
    angle_autour_Y = asin (m3$)
    cos_angleY = cos (angle_autour_Y)
    angle_autour_Y = angle_autour_Y *-1
    if cos_angleY > 0.005,
    [
        #3 angle autour de X
        tr_x = m9$ / cos_angleY
        tr_y = -m6$ / cos_angleY
        angle_autour_X  = atan2 (tr_y,tr_x)
        if angle_autour_X > 180 , angle_autour_X = angle_autour_X - 360
        angle_autour_X = angle_autour_X * -1
        #4 angle autour de Z
        tr_x = m1$ / cos_angleY
        tr_y = -m2$ / cos_angleY
        angle_autour_Z  = atan2 (tr_y,tr_x)
        if angle_autour_Z > 180 , angle_autour_Z = angle_autour_Z - 360
        angle_autour_Z = angle_autour_Z * -1
    ]
    else,
    [
        # angle autour de X
        angle_autour_X  = 0
        # angle autour de Z
        angle_autour_Z  = atan2 (m4$,m5$)
        if angle_autour_Z > 180 , angle_autour_Z = angle_autour_Z - 360
        angle_autour_Z = angle_autour_Z * -1
    ]

pcalcul_xyz_absolu
    !angle_autour_X, !angle_autour_Y, !angle_autour_Z
    angle_autour_X_2 = angle_autour_X * -1
    angle_autour_Z_2 = angle_autour_Z * -1
    angle_autour_Y_2 = angle_autour_Y * -1
    #"voir les angles tournés ", *angle_autour_X_2, *angle_autour_Z_2 , *angle_autour_Y_2 , e$
    #   tourne le point autour X
    y1 = zdep * sin(angle_autour_X_2) + ydep * cos(angle_autour_X_2)
    z1 = zdep * cos(angle_autour_X_2) - ydep * sin(angle_autour_X_2)
    #   tourne le point autour Y
    zabs = xdep * sin(angle_autour_Y_2) + z1  * cos(angle_autour_Y_2)
    x1 = xdep * cos(angle_autour_Y_2) - z1  * sin(angle_autour_Y_2)
    # tourne le point autour de Z
    xabs = y1  * sin(angle_autour_Z_2) + x1  * cos(angle_autour_Z_2)
    yabs = y1  * cos(angle_autour_Z_2) - x1  * sin(angle_autour_Z_2)

angle_autour_X_2 : 0
angle_autour_Z_2 : 0
angle_autour_Y_2 : 0
angle_autour_Z : 0
angle_autour_Y : 0
angle_autour_X : 0
xplan_inter : 0
yplan_inter : 0
zplan_inter : 0
tr_y : 0
tr_x : 0
cos_angleY : 0
x1 : 0
y1 : 0
z1 : 0
xplan : 0
yplan : 0
zplan : 0
xdep : 0
ydep : 0
zdep : 0
sauvX : 0
sauvY : 0
sauvZ : 0

p_calcul_xyz_tete_renvoie
    pcalcul_plan
    sauvX = x$
    sauvY = y$
    sauvZ = z$
    xdep = x$
    ydep = y$
    zdep = z$
    pcalcul_xyz_absolu
    x$ = xabs
    y$ = yabs
    z$ = zabs
    #AUTRE CEDRIC
     #xabs = x$ * m1$ + y$ * m2$ + z$ * m3$
    #Yabs = x$ * m4$ + y$ * m5$ + z$ * m6$
    #Zabs = x$ * m7$ + y$ * m8$ + z$ * m9$

#endregion

pxyz_new    # ecriture des positions X Y Z et A pour XYZ CLASIQUE et substitution
    if ra_block$ >0, p_calcul_xyz_tete_renvoie #RENVOIE D'ANGLE

    if rotaxis$ = 0, [    # XYZ CLASIQUE
        if incremental = 0,    [
            if cc$ = 41 | cc$ = 42 | cc$ = 140, *xabs, *yabs, zabs, !xinc, !yinc, !zinc
            else, xabs, yabs, [if zabs <> old_zabs, zabs], !xinc, !yinc, !zinc 
            ]
        else, !xabs, !yabs, !zabs, xinc, yinc, zinc         #pour 1er déplacement
		old_zabs = zabs
        ]

    #POUR SUBSTITUTION "incrémental" ?
    #if incremental = 0, xabs, yabs, axe_AB, zabs, !xinc, !yinc, !axe_ABi, !zinc
    #else, !xabs, !yabs, !axe_AB, !zabs, xinc, yinc, axe_ABi, zinc

    if rotaxis$ = -2 | rotaxis$ = 2, [    # SUBSTITUTION Y par A (diviseur tourne autour de X)
        p_calcul_AB_pos_Subs
        yabs = 0
        xabs = x$
        xabs, [if yabs <> old_y, yabs], zdev, axeAB_subs, !yabs, !zabs     #, !xinc, !yinc, !zinc, !A_posi, !zdevi
        axe_AB = axeAB_subs
        old_y = 0
        nbrtour = int (axe_AB / 360)
        old_axe_AB  = axeAB_subs
        ]
    if rotaxis$ = -1 | rotaxis$ = 1, [   # SUBSTITUTION X par A (diviseur tourne autour de Y)
        p_calcul_AB_pos_Subs
        xabs = 0
        yabs = y$
        [if xabs <> old_x, xabs], yabs, zdev, axeAB_subs, !xabs, !zabs     #, !xinc, !yinc, !zinc, !A_posi, !zdevi
        axe_AB  = axeAB_subs
        old_x = 0
        old_axe_AB  = axeAB_subs
        nbrtour = int (axe_AB / 360)
        ]
#endregion

#region erreurs
#-------------------------------------------------------------------------
s_erreur_message_0          : ""
s_erreur_message            : ""
serreur2                    : "nbr_combi_axes > 1, qu'une combinaison d'axe par programme"
serreur2_2                  : "Utilisation d'un BLOCK de revoie d'angle ou nbr_combi_axes > 1, qu'une combinaison d'axe par programme"
serreur3                    : "combinaison d'axe impossible, rotation en X sur B MODIFIER LE PLAN DE ROTATION"
serreur4                    : "combinaison d'axe impossible, rotation en Y sur A MODIFIER LE PLAN DE ROTATION"
serreurTar                  : "Erreur - Taraud avec un autre cycle"
serreurPalp1                : "ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
serreurPalp2                : "ATTENTION SENS DE PALPAGE X ERRONE"
serreurPalp3                : "ATTENTION SENS DE PALPAGE Y ERRONE" # op_id$," AVEC OUTIL ",t$,e$
#serreurCC_Cor              : "ATTENTION PRISE DE CORRECTION SUR UN CERCLE"
serreur_Aff_ORI             : "ATTENTION INFORMER LES VALEURS D ORIGINE ET RELANCER LE PST"
s_avert_taraud_brise_c      : "ATTENTION AVERTISSEMENT : TARAUDAGE AVEC BRISE COPEAUX"
serreur_av_taraudage        : "ATTENTION LE PAS A UNE VALEUR DECIMAL"
serreur_H_et_D              : "ATTENTION RENUMEROTER TOUT -outil et H/D DIFFERENTS"
serreur_vit_broche          : "ATTENTION -BROCHE SANS VITESSE-"
serreurPalp4_1              : "ATTENTION IL MANQUE UNE LONGUEUR DE PALPAGE ORIGINE X/Y 2 FACES"
serreurPalp4_2              : "ATTENTION IL MANQUE LE TYPE DE PALPAGE ORIGINE X/Y 2 FACES"
s_erreur_origine_plan       : "ATTENTION coordonnée de l'origine du plan incliné ne correspond à l'origine de base"
s_erreur_Nom_RUD            : "ATTENTION *** RUDs DIFFERENTS dans un meme programme ****"
s_erreur_pas_fil            : "ATTENTION RENSEIGNER LE PAS DU FILETAGE à la fraise"
#s_mess_per_prof            : "ATTENTION METTRE S/10 SUR LE FORET TRES LONG. LE PP *10"
#s_mess_per_prof2           : "ATTENTION METTRE -F- A LA BONNE VALEUR SUR LE FORET TRES LONG."
#s_mess_per_prof3           : "ATTENTION -S- DE DEPART > 500 Tr/mn A MODIFIER DANS L'ISO !"
s_erreur_pas_fil2           : "ATTENTION l'outil et l'opération non pas le meme PAS !"
s_erreur_transf_plan         : "ATTENTION transformation PLAN à plat ! Rotation sur Z !"
s_erreur_origine_plan2      : "- POUR INFO - il peut Etre utilisE avec plusieurs piEces"
s_erreur_dif_T_H_D          : "ATTENTION num. d'outil est different du num -H- ou -D- !"
s_erreur_avance_fil         : "ATTENTION l'avance de filetage à la fraise est TROP importante !"
s_erreur_avanceS            : "ATTENTION **INFORMER LA VALEUR DE --F-- DANS L OUTIL***"
s_erreur_choix_axe          : "ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
s_erreur_nbr_axes_rot           	: "le pst ne supporte q'un axe rotatif"
s_erreur_choix_cycle_palpage    	: "CYCLES DE PALPAGES NON AUTORISE, VEUILLEZ CONTACTER FICAM POUR LES UTILISER"
s_erreur_stock_shape            	: "ERREUR - CONFIG. DU BRUT - Seulement rectangulaire ou Cylindrique supportEs CN." + no2asc(13) + no2asc(13) + "Info dans l'ISO, Solide-Maillage, Stl"
s_erreur_inclinaison_OP_5axes     	: "ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"
s_erreur_test_bris_out_nom        	: "IMPOSSIBLE DE FAIRE UN TEST BRIS OUTIL AVEC LE NOM D'OUTIL !!"
s_erreur_num_block_renvoie_angle    : "ATTENTION ! Le numéro d'outil doit etre identique au numéro du BLOCK ORIENTABLE !"
s_erreur_angles_renvoie_angle       : "ATTENTION ! L'ANGLE du PLAN n'est pas identique à l'angle du BLOCK ORIENTABLE !"
s_erreur_lub_perc_prof             	: "ATTENTION ! Opération de perçage très profond : l'arrosage sélectionné n'est pas au CENTRE OUTIL"
s_erreur_choix_palette             	: "erreur de choix de palette 1(A) ou 2(B) indiquez le nbr de pièces sur une des 2 palettes"
s_erreur_choix_axe_substitution 	: "ATTENTION ! erreur sur le choix de l'axe de substitution ! A CHANGER"
s_erreur_config_type_arc			: "ATTENTION ! erreur de config d'arcs au niveau armoire UNIQUEMENT -R- ou -IJK- en FANUC"
s_erreur_config_type_arc2			: "Veuillez le modifier dans la config. armoire"
s_erreur_config_type_arc3			: "Pour utiliser ce mode mettre la variable-erreur_type_arcs- liqne 145 du post-pro à -0-"
s_erreur_angles_renvoie_angle_2     : "ATTENTION ! L'ANGLE du PLAN n'est pas pris en charge par l'angle du BLOCK ORIENTABLE !"
s_erreur_S_maxi_renvoi_angle		: "ATTENTION ! S de rotation > S autorisé avec le renvoi d'angle --> la vitesse de broche passe au MAXIMUM AUTORISE!" 
s_erreur_angle_renvoi_fixe			: "ATTENTION ! Ce renvoi d'angle n'autorise pas de rotations !" 
s_erreur_val_C_MM_perc				: "ATTENTION ! la valeur du choix du type % mm ne peut Etre à 0"  
s_erreur_val_inf_perc				: "ATTENTION ! la valeur Z de l'ammorce de perçage doit Etre inf."

p_erreur_messages
	if affiche_num_op_MC = 1, s_erreur_message_0 = "ATTENTION ERREUR A L'OP: " + s_old_spost_arg_2 + " AVEC L'OUTIL N° " + no2str(t$)
	if affiche_num_op_MC = 2, s_erreur_message_0 = "ATTENTION ERREUR A L'OP: " + no2str(op_number) + " AVEC L'OUTIL N° " + no2str(t$)
    result = mprint(s_erreur_message_0)

perreurTaraud   #"Erreur - Taraud avec un autre cycle"
    if paramT2 = 4 | paramT2 = 5,
        [
        p_erreur_messages
        "ERREUR NUM: 1", s_erreur_message_0, e$
        result = mprint(serreurTar)
        exitpost$
        ]

perreurPalp1    #"ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
    if drl_prm1$ <> 1 & drl_prm2$ <> 1, [
        p_erreur_messages
        "ERREUR NUM: 3", s_erreur_message_0, e$
        result = mprint(serreurPalp1)
        exitpost$
        ]

perreurPalp2    #"ATTENTION SENS DE PALPAGE X ERRONE"
    if peck1$ =0,
        [
        p_erreur_messages
        "ERREUR NUM: 4", s_erreur_message_0, e$
        result = mprint(serreurPalp2)
        exitpost$
        ]

perreurPalp3    #"ATTENTION SENS DE PALPAGE Y ERRONE"
    if peck1$ < 0 | peck1$ > 1,
        [
        p_erreur_messages
        "ERREUR NUM: 5", s_erreur_message_0, e$
        result = mprint(serreurPalp3)
        exitpost$
        ]

perreurPalp4    #"ATTENTION IL MANQUE UNE VALEUR DE PALPAGE ORIGINE X/Y 2 FACES"
    if (drillcyc$ = 15 & peck1$ = 0) | (drillcyc$ = 16 & peck2$ = 0), erreur = 41
    if ((drl_prm1$ + drl_prm2$) <> 1), erreur = 42
    if erreur = 41, result = mprint(serreurPalp4_1)
    if erreur = 42, result = mprint(serreurPalp4_2)
    if erreur = 41 | erreur = 42,
        [
        p_erreur_messages
        "ERREUR NUM: 6", s_erreur_message_0, e$
        exitpost$
        ]

perreur_Aff_Ori #"ATTENTION INFORMER LES VALEURS D ORIGINE ET RELANCER LE PST"
    if axe_AB <> 0 & (workofs_ < 1),
        [
        p_erreur_messages
        "ERREUR NUM: 7", s_erreur_message_0, e$
        result = mprint(serreur_Aff_ORI)
        exitpost$
        ]

perreur_transf_plan # "ATTENTION transformation PLAN à plat !  Rotation sur Z !"
    if (diviseur = 1 & m1$ <> 1) | (diviseur = 2 & m5$ <> 1),
        [
        p_erreur_messages
        "ERREUR NUM: 8", s_erreur_message_0, e$
        "ATTENTION VERIFIER SI LE NOUVEAU PLAN EST BIEN D EQUERRE PAR RAPPORT AU RUD", e$
        result = mprint(s_erreur_transf_plan)
        n$, *m1$, *m2$, *m3$, *m4$, *m5$, *m5$, *m7$, *m8$, *m9$, e$
        ]
    if diviseur = 1 & m1$ <> 1, [
        p_erreur_messages
        "ERREUR NUM: 9", s_erreur_message_0, e$
        "ROTATION AXE MACHINE = ", s_axe_rot_A, e$
        "SOLUTION CREER LE NOUVEAU PLAN PAR RAPPORT AU RUD AVEC -PLAN ROTATION- DE X DEG. EN X,Y OU Z", e$
        ]
    if diviseur = 2 & m5$ <> 1, [
        p_erreur_messages
        "ERREUR NUM: 10", s_erreur_message_0, e$
        "ROTATION AXE MACHINE = ", s_axe_rot_B, e$
        "SOLUTION CREER LE NOUVEAU PLAN PAR RAPPORT AU RUD AVEC -PLAN ROTATION- DE X DEG. EN X,Y OU Z", e$
        ]

perreur_PAS_Taraud  #"Erreur - ATTENTION LE PAS A UNE VALEUR DECIMAL"
    if erreur_pas <> pas, [
        p_erreur_messages
        "ERREUR NUM: 11", s_erreur_message_0, e$
        result = mprint(serreur_av_taraudage)
        exitpost$
        ]

perreur_H   #"ATTENTION RENUMEROTER TOUT -outil et H/D DIFFERENTS"
    if paramT1 <> tlngno$, [
        p_erreur_messages
       "ERREUR NUM: 12", s_erreur_message_0, e$
       "T", paramT1, "H", *correcteur_H, e$
        result = mprint(serreur_H_et_D)
        exitpost$
        ]

perreur_D   #"ATTENTION RENUMEROTER TOUT -outil et H/D DIFFERENTS"
    if paramT1 <> tloffno$, [
        p_erreur_messages
        "ERREUR NUM: 13", s_erreur_message_0, e$
        "T", paramT1, "D", *correcteur_D, e$
        "ATTENTION ERREUR 13 OP: ", op_id$, " AVEC OUTIL ", *t$, e$
        result = mprint(serreur_H_et_D)
        exitpost$
        ]

perreur_vit_broche #"ATTENTION -BROCHE SANS VITESSE-"
    if ssa = 0, [
        #p_erreur_messages
        #"ERREUR NUM: 14", s_erreur_message_0, e$
        result = mprint(serreur_vit_broche)
        ]

Perreur_origine_plan    #    OBSOLETE --> GENERE UN DECALLAGE DE COORDONNEES G52/TRANS/DEF 7 ...
    if Val_origine_Z <> Old_Val_origine_Z | Val_origine_Y <> Old_Val_origine_Y | Val_origine_X <> Old_Val_origine_X,
        [
        p_erreur_messages
        "ERREUR NUM: 15", s_erreur_message_0, e$
        result = mprint(s_erreur_origine_plan)
        result = mprint(s_erreur_origine_plan2)
        #exitpost$
        ]

Perreur_nom_RUD         # 2 ruds differents utilises dans un mEme programme
    if snom_RUD <> Sold_snom_RUD,
        [
        p_erreur_messages
        #"ERREUR NUM: 16", s_erreur_message_0, "REGENERER OPs SI BESOIN", e$
        #s_erreur_Nom_RUD, e$
        result = mprint(s_erreur_Nom_RUD)
        ]
    Sold_snom_RUD = snom_RUD

perreur_pas_fil  # "ATTENTION RENSEIGNER LE PAS DU FILETAGE à la fraise"
    if tool_op$ = 100,
        [
        if pas_filetage = 9.999, [  # "ATTENTION RENSEIGNER LE PAS DU FILETAGE à la fraise"
            p_erreur_messages
            "ERREUR NUM: 17", s_erreur_message_0, e$
            result = mprint(s_erreur_pas_fil)
            exitpost$
            ]
        if pas_filetage <> paramT7, [   # ""ATTENTION l'outil et l'opération non pas le meme PAS !""
            p_erreur_messages
            "ERREUR NUM: 18", s_erreur_message_0, e$
            result = mprint(s_erreur_pas_fil2)
            exitpost$
            ]
        p_erreur_avance_fil
        ]

p_erreur_dif_T_H_D # "ATTENTION num. d'outil est different du num -H- ou -D- !"
    if t$ <> tloffno$ | t$ <> tlngno$ & opcode$ <> 3,
        [
        p_erreur_messages
        "ERREUR NUM: 19", s_erreur_message_0, e$
        s_erreur_dif_T_H_D, e$
        result = mprint(s_erreur_dif_T_H_D)
        ]

p_erreur_avance_fil # "ATTENTION l'avance de filetage à la fraise est TROP importante !"
    if fr$ > 500,
        [
        p_erreur_messages
        "ERREUR NUM: 20", s_erreur_message_0, e$
        result = mprint(s_erreur_avance_fil)
        ]

p_erreur_avanceS    #: "ATTENTION **INFORMER LA VALEUR DE --F-- DANS L OUTIL***"
    if drillcyc$ > 0 & frplunge$ = 0,
        [
        p_erreur_messages
        "ERREUR NUM: 21", s_erreur_message_0, e$
        "ATTENTION l'avance -F- EST A --0-- !", e$
        #*drillcyc$, *frplunge$, *drillcyc$, *fr_pos$, e$
        result = mprint(s_erreur_avanceS)
        ]

p_erreur_choix_axe    #: "ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
    p_erreur_messages
    "ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
    result = mprint(s_erreur_choix_axe)
    if diviseur = 1, "ROTATION AXE :", s_axe_rot_B, e$
    if diviseur = 2, "ROTATION AXE :", s_axe_rot_A, e$
    "ERREUR NUM: 22", s_erreur_message_0, e$

p_erreur_cycle_palpage
    p_erreur_messages
    n$, "CYCLES DE PALPAGES NON AUTORISE, VEUILLEZ CONTACTER FICAM POUR LES UTILISER", e$
    result = mprint(s_erreur_choix_cycle_palpage)

p_erreur_inclinaison_OP_5axes    #: "ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"
    p_erreur_messages
    "ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"
    "VEUILLEZ BLOQUER UN AXE SI POSSIBLE DANS L'OPERATION OU CHANGER D'OPERATION"
    result = mprint(s_erreur_inclinaison_OP_5axes)
    "ERREUR NUM: 23", s_erreur_message_0, e$
    exitpost$

p_erreur_test_bris_out_nom
    if nom_outil = 1, [
        p_erreur_messages
        "ERREUR NUM: 24", s_erreur_message_0, e$
        result = mprint(s_erreur_test_bris_out_nom)
        exitpost$
        ]

p_erreur_num_block_renvoie_angle
    if t$ <> ra_block$, [
        p_erreur_messages
        "ERREUR NUM: 25", s_erreur_message_0, e$
        result = mprint(s_erreur_num_block_renvoie_angle)
        #exitpost$
        ]

p_erreur_angles_renvoie_angle
    if ANGLE_XY_renvoie_angle <> Angle_PLAN_MC_renvoie_angle, [
        p_erreur_messages
        "ERREUR NUM: 26", s_erreur_message_0, e$
        result = mprint(s_erreur_angles_renvoie_angle)
        exitpost$
        ]

p_erreur_lub_perc_prof
    if coolantx <> 4, [
        result = mprint(s_erreur_lub_perc_prof)
        ]

p_erreur_choix_axe_substitution
    if diviseur = 1 & (rotaxis$ = -1 | rotaxis$ = 1), [
        p_erreur_messages
        "ERREUR NUM: 27", s_erreur_message_0, e$
        result = mprint(s_erreur_choix_axe_substitution)
        exitpost$
        ]
    if diviseur = 2 & (rotaxis$ = -2 | rotaxis$ = 2), [
        p_erreur_messages
        "ERREUR NUM: 28", s_erreur_message_0, e$
        result = mprint(s_erreur_choix_axe_substitution)
        exitpost$
        ]

p_erreur_config_type_arc
	s_com_open, "ERREUR NUM: 29", s_com_close, e$
	result = mprint(s_erreur_config_type_arc)
	result = mprint(s_erreur_config_type_arc2)
	result = mprint(s_erreur_config_type_arc3)
	
p_erreur_angles_renvoie_angle_2		# ICI ANGLES FIXES A INDIQUER --> ICI TETE A 4 fois 90DEG
	if Angle_PLAN_MC_renvoie_angle <> 0 | Angle_PLAN_MC_renvoie_angle <> 90 | 
			Angle_PLAN_MC_renvoie_angle <> 180 | Angle_PLAN_MC_renvoie_angle <> 270, [
        p_erreur_messages
        "ERREUR NUM: 30", s_erreur_message_0, e$
        result = mprint(s_erreur_angles_renvoie_angle_2)
        exitpost$
        ]

p_erreur_perc_decomposes
	if perc_1er_perc_pour_C_ou_mm = 0, [
		p_erreur_messages
		"ERREUR NUM: 31", s_erreur_message_0, e$
		result = mprint(s_erreur_val_C_MM_perc)
		]
	if P_er_perc_0 < P_er_perc_1 | peck1$ < P_er_perc_1, [
		p_erreur_messages
		"ERREUR NUM: 32", s_erreur_message_0, e$
		result = mprint(s_erreur_val_inf_perc)
		]	
#endregion

#region percages_simples_et_continus

#region percages_simples
#--------------- PERCAGES
passage_drillcyc : 0
p_percages_decomposes
	#"p_percages_decomposes : ", *drillcyc$, *usecanDRILL, *usecanPECK, " ", *usecanCHIP, " ", *perc_1er_perc_pour_C_ou_mm, e$
	if drillcyc$ >= 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1) & passage_drillcyc = 0, 
		[
		if drillcyc$ = 0, n$, s_com_open, "PERCAGE LAMAGE TEMPO -G82-", s_com_close, e$ 
		if drillcyc$ = 1, n$, s_com_open, "PERCAGE DEBOURRAGE -G83-", s_com_close, e$
		if drillcyc$ = 2, n$, s_com_open, "PERCAGE DEBOURRAGE BRISE COPEAUX -G83-", s_com_close, e$ 
		#if drillcyc$ = 3, n$, s_com_open, "TARAUDAGE G84", s_com_close, e$ 
		dwell_ = dwell$ 
		passage_drillcyc = 1
		]	
	if drillcyc$ >= 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1) & perc_1er_perc_pour_C_ou_mm >= 0 & perc_Val_pour_Cent_mm <> 0,  
		[
		n$, s_com_open, "AVEC AMORCE DE PERCAGE", s_com_close, e$ 
		# Avances
		if perc_AVANCE_pour_Cent_mm > 0, [			# %		
			avance = (frplunge$ * perc_AVANCE_pour_Cent_mm) / 100
			]
		if perc_AVANCE_pour_Cent_mm < 0, [			# mm
			avance = perc_AVANCE_pour_Cent_mm * -1
			]
		# Profondeurs
		if perc_1er_perc_pour_C_ou_mm = 0, [		# VALEUR EN mm	
			P_er_perc_0 = perc_Val_pour_Cent_mm 
			P_er_perc_2 = refht$ - P_er_perc_0	
			]	
		if perc_1er_perc_pour_C_ou_mm = 1, [		# Valeur en %
			angle_foret = 90 - (paramT8 / 2)
			P_er_perc_0 = refht$ - z$
			P_er_perc_1 = (P_er_perc_0 * perc_Val_pour_Cent_mm) / 100 
			P_er_perc_2 = refht$ - P_er_perc_1					
			]
		n$, "G1", *P_er_perc_2, *avance, e$
		if dwell$ > 0, *dwell_, e$ 
		p_erreur_perc_decomposes
		perc_1er_perc_pour_C_ou_mm = -1	# pour ne pas l'afficher sur les autres profondeurs
		]

pdrill0$
    p_correc_time_G0
	sav_dgcode = gcode$ #Capture gcode for 5 axis drill
	if usecanDRILL = 1, usecandrill$ = no$
	if usecanPECK = 1, usecanpeck$ = no$
	if usecanCHIP = 1, usecanchip$ = no$
	if percages_formats_Q = 2, result = newfs (7, peck1$)
	if percages_formats_Q = 3, result = newfs (28, peck1$)
	if percages_formats_Q = 4, result = newfs (29, peck1$)
	passage_drillcyc = 0
	
pdrill_param
    if sav_dgcode = 81,	[
        result = newfs (2, zinc)
        if drillcyc$ = three, drlgsel = fsg1(-ss$) + drillcyc$ * two
        else, drlgsel = fsg2(dwell$) + drillcyc$ * two
        if initht$ <> refht$, drillref = 0
        else, drillref = 1
        #prv_refht_a = -9999
        #prv_refht_i = -9999
        #prv_dwell$ = 0
        ]

pdrill$      # Cycle de percage G81 G82 
	if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0 & dwell$ = 0,  n$, s_com_open, "POINTAGE-PERCAGE", s_com_close, e$
        if typcycle = 0 & dwell$ <> 0, n$, s_com_open, "POINTAGE-PERCAGE-TEMPO", s_com_close, e$
		if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
        omitseq$ = old_omitseq
        ]
    if drill_4_axes = 1, p_drill_5axes
    pdrill_param
    typcycle = 1
    p_casse_modalite            # casser la modalité de xy
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    if dwell$ <1, [
        tempo = dwell$
        tempo = tempo*100
        ]
	if dwell$ = 0, n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, pavanceperce, e$
    else, n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, *tempo, pavanceperce, e$
    perreurTaraud

ppeck$      # Cycle de débourrage G83
	if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0, n$, s_com_open, "DEBOURRAGE", s_com_close, e$
		if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
        omitseq$ = old_omitseq
        ]
    if drill_4_axes = 1, p_drill_5axes
    pdrill_param
    typcycle = 1
    p_casse_modalite            # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, *peck1$, pavanceperce, e$
    perreurTaraud

pchpbrk$    # Cycle de brise copeaux G73
    if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0, n$, s_com_open, "BRISE COPEAUX", s_com_close, e$
		if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
        omitseq$ = old_omitseq
        ]
    if drill_4_axes = 1, p_drill_5axes
    pdrill_param
    typcycle = 1
    p_casse_modalite            # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    #if dwell$ <1, [
        #tempo = dwell$
        #tempo = tempo*100
        #]
    n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, *peck1$, pavanceperce, tempo, e$	#retr$, peckclr$, 
    perreurTaraud

ptap$       # Cycle de taraudage G84
    if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0 & peck1$ = 0, n$, s_com_open, "TARAUDAGE", s_com_close, e$
		if typcycle = 0 & peck1$ > 0, n$, s_com_open, "TARAUDAGE AVEC DEBOURRAGE", s_com_close, e$
		if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
        omitseq$ = old_omitseq
        ]
    if drill_4_axes = 1, p_drill_5axes
    pdrill_param
    if dwell$ <1, [
        tempo = dwell$
        tempo = tempo*100
        ]
    typcycle = 1
    p_casse_modalite            # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    if n_tap_thds$ <> 0, pas = n_tap_thds$	# F en valeur du PAS
    if tool_typ$ = 5, ss$ = (abs(ss$))*-1
    if fmt_pas_tap = 1, pas = pas * abs(ss$)	# F en mm/mn	0=pas du filetage
    erreur_pas = pas
    erreur_pas = abs(erreur_pas)
    perreur_PAS_Taraud
    if s_taraudage_rigide <> svide, n$, s_taraudage_rigide, *ssa,  s_com_open, "TARAUDAGE RIGIDE", s_com_close, e$
    n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, [if peck1$ > 0, *peck1$], *pas, tempo, e$
	if peck1$ > 0, result = mprint(s_avert_taraud_brise_c)  #AFFICHAGE D UN MESSAGE POUR TARAUDAGE AVEC BRISE COPEAUX

pbore1$     # Cycle d'alésage G85
    if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0, n$, s_com_open, "ALESAGE ALESOIR", s_com_close, e$
		if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
        omitseq$ = old_omitseq
        ]
    if drill_4_axes = 1, p_drill_5axes
    pdrill_param
    typcycle = 1
    p_casse_modalite            # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    if dwell$ <1,    [
        tempo = dwell$
        tempo = tempo*100
        ]
    n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, pavanceperce, !tempo, e$
    perreurTaraud

p_bore2     # Cycle d'alésage G86
    if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0, n$, s_com_open, "ALESAGE BARE", s_com_close, e$
		if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
        omitseq$ = old_omitseq
        ]
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param
    typcycle = 1
    p_casse_modalite            # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    if dwell$ <1,    [
        tempo = dwell$
        tempo = tempo*100
        ]
    n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, pavanceperce, !tempo, e$

pbore2$     # Cycle d'alésage indexé G75
    pbore1$ #pas d'alésage indexé
    #if CN_textes <> 0, [
        #if numcoment = 0, omitseq$ = 1
        #if typcycle = 0, n$, s_com_open, "ALESAGE INDEXE", s_com_close, e$
        #omitseq$ = old_omitseq
        #]
    #typcycle = 1
    #p_casse_modalite       # casser la modalité de xyzra
    #p_casse_modalite_perce     # casser la modalité de la garde et la prof
    #if shftdrl$ = 0, shftdrl$ = 0.1
    #if shftdrl$ < 0, shftdrl$ = shftdrl$ * -1
    #if dwell$ <1, [
    #   tempo = dwell$
    #   tempo = tempo*100
    #   ]
    #n$, sinc_abs, "G86", *sgdrlref, p_XY_perc, *shftdrl$, "P0.", pavanceperce, !tempo, e$

pmisc1$     # Cycle 

pmisc2$     # Cycle

p_transit_perc_subst	# SUBSTITUTION 	# TROUS SUIVANTS
	pcanceldc$
	p_calcul_AB_pos_Subs
	if axeAB_subs <> old_axe_AB, 
		[
		gcode$ = 0
		if mi7$ = 1, bloque = 2, n$, sbloque, e$	# si ROT - Débloque			
		n$, *sgcode, *axeAB_subs, e$
		if mi7$ = 1, bloque = 1, n$, sbloque, e$	# si ROT - Bloque
		]
    @depth$
    @refht$
	prof_abs = (rotdia$/2) - abs(depth$)
    prof_inc = depth$ - ((rotdia$/2) - refht$) 
    garde_abs = refht$ + (rotdia$/2)
    garde_inc = refht$
    !depth$
    !refht$
	if rotaxis$ = -1 | rotaxis$ = 1, yabs = y$ 
	if rotaxis$ = -2 | rotaxis$ = 2, xabs = x$ 
	#if incremental = 0, *xabs, *yabs, axeAB_subs, e$, !xinc, !yinc, !axe_ABi
    #else, !xabs, !yabs, !axeAB_subs, *xinc, *yinc, *axe_ABi, e$ 	
	old_axe_AB = axeAB_subs
    nbrtour = int (axe_AB / 360)
		
pdrill_2$   # Percage suivant
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param	
    if drill_4_axes = 0 & rotaxis$ = 0, p_position_trou, e$
	if rotaxis$ <> 0, p_transit_perc_subst
    if drill_4_axes = 1 | rotaxis$ <> 0, [
        p_casse_modalite            # casser la modalité de xyzra
        p_casse_modalite_perce      # casser la modalité de la garde et la prof
        p_calcul_XYZ_percage_5x
        #n$, [ if epsi <> 0, *sgdrill, *sgdrlref, ], sinc_abs, sgdrill, sgdrlref, p_XY_perc, pavanceperce, [ if dwell$ = 0, tempo, ], e$
        n$, *sgdrill, *sgdrlref, sinc_abs, p_XY_perc, pavanceperce, [ if dwell$ > 0, tempo, ], e$
        ]

ppeck_2$    # Canned Peck Drill Cycle
    if drill_4_axes = 1, p_drill_5axes_2
	pdrill_param
	if drill_4_axes = 0 & rotaxis$ = 0, p_position_trou, e$
	if rotaxis$ <> 0, p_transit_perc_subst
    if drill_4_axes = 1 | rotaxis$ <> 0, [
        p_casse_modalite            # casser la modalité de xyzra
        p_casse_modalite_perce      # casser la modalité de la garde et la prof
        p_calcul_XYZ_percage_5x
		n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, *peck1$, pavanceperce, e$
        ]

pchpbrk_2$  # Canned Chip Break Cycle
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param
    if drill_4_axes = 0 & rotaxis$ = 0, p_position_trou, e$
	if rotaxis$ <> 0, p_transit_perc_subst
    if drill_4_axes = 1 | rotaxis$ <> 0, [
        p_casse_modalite            # casser la modalité de xyzra
        p_casse_modalite_perce      # casser la modalité de la garde et la prof
        p_calcul_XYZ_percage_5x
        if dwell$ <1,    [
            tempo = dwell$
            tempo = tempo*100
            ]
        n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, retr$, peckclr$, pavanceperce, tempo, e$
        ]

ptap_2$     # Canned Tap Cycle
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param
    if drill_4_axes = 0 & rotaxis$ = 0, p_position_trou, e$
	if rotaxis$ <> 0, p_transit_perc_subst
    if drill_4_axes = 1 | rotaxis$ <> 0, 
        [
        p_casse_modalite            # casser la modalité de xyzra
        p_casse_modalite_perce      # casser la modalité de la garde et la prof
        p_calcul_XYZ_percage_5x
        if ss$ >= 0, [          
            n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, [if peck1$ > 0, *peck1$], *pas, tempo, e$
            ]
        else,   [      
            n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, [if peck1$ > 0, *peck1$], *pas, tempo, e$           
            ]
        ]

pbore1_2$   # Canned Bore #1 Cycle   
    if drill_4_axes = 1, p_drill_5axes_2
	pdrill_param
    if drill_4_axes = 0 & rotaxis$ = 0, p_position_trou, e$
	if rotaxis$ <> 0, p_transit_perc_subst
    if drill_4_axes = 1 | rotaxis$ <> 0, [
        p_casse_modalite            # casser la modalité de xyzra
        p_casse_modalite_perce      # casser la modalité de la garde et la prof
        p_calcul_XYZ_percage_5x
        if dwell$ <1, [
            tempo = dwell$
            tempo = tempo*100
            ]
        n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, pavanceperce, !tempo, e$
        ]

pbore2_2$   # Canned Bore #2 Cycle
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param
    if drill_4_axes = 0 & rotaxis$ = 0, p_position_trou, e$
	if rotaxis$ <> 0, p_transit_perc_subst
    if drill_4_axes = 1 | rotaxis$ <> 0, [
        p_casse_modalite            # casser la modalité de xyzra
        p_casse_modalite_perce      # casser la modalité de la garde et la prof
        p_calcul_XYZ_percage_5x
        if dwell$ <1,  [
            tempo = dwell$
            tempo = tempo*100
            ]
        n$, sinc_abs, *sgdrill, *sgdrlref, p_XY_perc, pavanceperce, !tempo, e$
        ]

pmisc1_2$   # Canned Misc #1 Cycle
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param
    if rotaxis$ <> 0, n$, p_XY_perc, e$
    if drill_4_axes = 0, p_position_trou, e$

pmisc2_2$   # Canned Misc #2 Cycle
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param
    if rotaxis$ <> 0, n$, p_XY_perc, e$
    if drill_4_axes = 0, p_position_trou, e$
	
#region percages_5axes

#region si_dev_avec_decallage_G52
p_drill_5axes_commun_debut
    if Mode_reglage_PP = 0, n$, "--> pdrill_5_commun VOIR: ", e$
    gcode$ = 0
    vx = u$ - x$
    vy = v$ - y$
    vz = w$ - z$
    longvec=sqrt(vx * vx + vy * vy + vz * vz)
    vx2 = (vx/longvec)
    vy2 = (vy/longvec)
    vz2 = (vz/longvec)
    if Mode_reglage_PP = 0, n$, "--> pdrill_5_commun VOIR: ", *vx, *vy, *vz, *longvec, *vx2, *vy2, *vz2, *m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
    if diviseur = 1, [
        #m7$ = vx2
        m8$ = vy2
        m9$ = vz2
        ]
    if diviseur = 2, [
        m7$ = vx2
        #m8$ = vy2
        m9$ = vz2
        ]
    if type_dec_4x_percage = 1, [    #PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0
        tox4_ = 0    #((vx2 * abs(depth$)) + x$)
        toy4_ = 0     #((vy2 * abs(depth$)) + y$)
        toz4_ = w$     #((vz2 * abs(depth$)) + z$)
        ]
    if type_dec_4x_percage = 0, [    #PERCAGE EN ABSOLU PTs MC CLASSIQUE
        #n$, s_com_open, "PERCAGE EN ABSOLU PTs MC CLASSIQUE", s_com_close, e$
        ]

p_drill_5axes_commun_fin
    if Mode_reglage_PP = 0, n$, "--> p_drill_5axes_commun_fin", e$
    old_tox4 = tox4$    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
    old_toy4 = toy4$
    old_toz4 = toz4$
    old_w_= w$
    old_x= xr$
    old_y= yr$
    old_z= zr$
    #if type_dec_4x_percage = 1, x$=0, y$=0    #PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0
    !x$,!y$,!z$,!xr$,!yr$,!zr$
#endregion

p_drill_5axes   # ecriture pour TOUS LES percageS en 4 axes continus **AVEC** ZONE DE SECU G1 OU G0
    if Mode_reglage_PP = 0, n$, "--> pdrill_5_1 VOIR", *x$, *y$, *z$, *zr$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$,
        *m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
    #p_Z_mini_maxi_OP
    gcode$ = 0
    #xabs = xnci$
    #yabs = ynci$
    #p_drill_5axes_commun_debut
	p_calcul_rot_pmx
	n$, `sgcode, p_axeAB_pmx, e$ 	
    if t$ <> old_t, [
        #n$, "G52 X0. Y0. Z0.", e$
        #p_degage_4_axes
        old_t = t$
        ]
    comment$
    if type_dec_4x_percage = 1, [    #PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0
        n$, "G52", *tox4_, *toy4_, *toz4_, e$
        xnci$ = 0
        ynci$ = 0
        ]
    if type_dec_4x_percage = 0, [    #PERCAGE EN ABSOLU PTs MC CLASSIQUE
        #"ICI 4 AXES -------------------------", e$
        ]
	debutpmx = 11
	old_garde_abs = garde_abs
	
p_drill_5axes_2   # ecriture DE TOUS LES percageS SUIVANTS en 4 axes continus **SANS** la ZONE DE SECU
    if Mode_reglage_PP = 0, n$, "--> pdrill_5_2 VOIR", *x$, *y$, *z$, *zr$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$,
        *m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
    #p_drill_5axes_commun_debut
	p_correc_time_G0
    if type_dec_4x_percage = 1, [
        if tox4$ <> old_tox4 | toy4$ <> old_toy4 | toz4$ <> old_toz4 | w$ <> old_w_, [
            n$, "G52", *tox4_, *toy4_, *toz4_, e$
            ]
        xnci$ = 0
        ynci$ = 0
        z$ = refht$
        zp = z$
        ]
    p_calcul_rot_pmx
    pdril5x_annul
    # *old_axe_AB, *epsi, e$
    if epsi <> 0, [
        p_Z_SECU_ret_5x
		if mi7$ = 1, bloque = 2, n$, sbloque, e$    # si ROT - Débloque
        gcode$ = 0
        n$, sgcode, p_axeAB_pmx, e$
        if mi7$ = 1, bloque = 1, n$, sbloque, e$	# si ROT - Bloque
		epsi = 0
        ]
	old_garde_abs = garde_abs

p_Z_SECU_ret_5x	# si après rotation le Z est > alors remonter au Z suivant avant
	if opcode$ = 16 & garde_abs > old_garde_abs, [
			zabs = garde_abs
			gcode$ = 0
			n$, *sgcode, *zabs, e$
			]	
	
pdril5x_annul   # annulation percage 5 axes
    if Mode_reglage_PP = 0, n$, "--> pdril5x_annul", e$
    if epsi <> 0 | nextop$ = 80 | gcode$ = 80 | nextop$ = 1003, [
        gcode$ = 5, n$, *sgcode, e$
        if drillref = 0, zabs = prof_abs + drl_sel_ini$, n$, *zabs, e$
        ]
    if type_dec_4x_percage = 1, p_annule_decalage

#endregion

#region perCage_tres_profond_et_palpages
pdrlcst$     # Test de l'appel des cycles  et embranchements
    if Cycles_palpage_YN = 1 & drillcyc$ >7 & drillcyc$ <17, [
        #if dwell$ < 1, "----",e$,        "ATTENTION PAS DE DECALAGE D ACTIVE _KNUM", op_id$," AVEC LE PALPEUR", e$, "---",e$ ,exitpost$
        if drillcyc$ = 8, pdrlcst_8           #Cycle de palpage Pt de réf. int. (exter) rectangulaire"
        if drillcyc$ = 9, pdrlcst_9           #Cycle de palpage Pt de réf. int. (exter) Diamètre"
        #if drillcyc$ = 10, pdrlcst_10        #Cycle de palpage Pt de réf. exter Coin"
        #if drillcyc$ = 11, pdrlcst_11        #Cycle de palpage Pt de réf. inter Coin"
        if drillcyc$ = 12, pdrlcst_12         #Cycle de palpage Pt de réf. EN Z"
        if drillcyc$ = 13, pdrlcst_13         #Cycle de palpage Pt de réf. FACE EN X"
        if drillcyc$ = 14, pdrlcst_14         #Cycle de palpage Pt de réf. FACE EN Y"
        if drillcyc$ = 15, pdrlcst_15         #Cycle de palpage Pt de réf. EN X IN-OUT"
        if drillcyc$ = 16, pdrlcst_16         #Cycle de palpage Pt de réf. EN Y IN-OUT"
        ]
    if Cycles_palpage_YN = 0 & drillcyc$ >7 & drillcyc$ <18, p_erreur_cycle_palpage
    if drillcyc$ = 18, pdrlcst_18         	 # Cycle Brossage EBAVURAGE
    if drillcyc$ = 19, pdrlcst_19         	 # perçage très profond avec trous d'huile
    #n$, "M71 ;Desactivation du palpeur", e$
    gcode$ = 0

pdrlcst_2$   # Test de l'appel des cycles  et embranchements pour X palpages
    #if dwell$ < 1, "----",e$,"ATTENTION PAS DE DECALAGE D ACTIVE _KNUM", op_id$," AVEC LE PALPEUR", e$, "---",e$ ,exitpost$
    #n$, ";*************", e$
    #if drillcyc$ = 8, pdrlcst_8_2           #Cycle de palpage Pt de réf. int. (exter) rectangulaire"
    #if drillcyc$ = 9, pdrlcst_9_2           #Cycle de palpage Pt de réf. int. (exter) Diamètre"
    #if drillcyc$ = 10, pdrlcst_10_2         #Cycle de palpage Pt de réf. exter Coin"
    #if drillcyc$ = 11, pdrlcst_11_2         #Cycle de palpage Pt de réf. inter Coin"
    #if drillcyc$ = 12, pdrlcst_12_2         #Cycle de palpage Pt de réf. EN Z"
    #if drillcyc$ = 13, pdrlcst_13_2         #Cycle de palpage Pt de réf. FACE EN X"
    #if drillcyc$ = 14, pdrlcst_14_2         #Cycle de palpage Pt de réf. FACE EN Y"
    #if drillcyc$ = 15, pdrlcst_15_2         #Cycle de palpage Pt de réf. EN X IN-OUT"
    #if drillcyc$ = 16, pdrlcst_16_2         #Cycle de palpage Pt de réf. EN Y IN-OUT"
    #if drillcyc$ >7 & drillcyc$ <17, palpeur = 0          #Pour désactiver le palpeur
    #n$, "M71 ;Desactivation du palpeur", e$
    if drillcyc$ = 18, pdrlcst_18_2     	# Cycle Brossage EBAVURAGE
    if drillcyc$ = 19, pdrlcst_19_2       	# perçage très profond avec trous d'huile
    gcode$ = 0

pdrlcst_8    #Cycle de palpage Pt de réf. int. (exter) rectangulaire"
    gcode$ = 0
    #profrelatif = (initht$-depth$) * ( -1)
    if drl_prm1$ = 1 | drl_prm2$ = 1, [
        u_palpage = peck1$
        v_palpage = peck2$
        z_palpage = z$
        w_palpage = dwell$
        a_palpage = x$
        b_palpage = y$
        a_palpage = a_palpage * -1
        b_palpage = b_palpage * -1
        w_palpage = w_palpage + 53
        if w_palpage > 69, w_palpage = w_palpage - 59
        ]
    if drl_prm1$ = 1, n$, "(REF. INTER RECTANGLE)", e$
    if drl_prm2$ = 1, [
        u_palpage = u_palpage * -1
        v_palpage = v_palpage * -1
        n$, "(REF. EXTER RECTANGLE)", e$
        ]
    perreurPalp1
    if drl_prm1$ = 1 | drl_prm2$ = 1, [
        n$, "G320 ", u_palpage, v_palpage, z_palpage, "E5. ", w_palpage, a_palpage, b_palpage, "Q2. R2 T9998", e$
        n$, s_com_open, *u_palpage, " - LONGUEUR EN X )", e$
        n$, s_com_open, *v_palpage, " - LARGEUR EN Y )", e$
        n$, s_com_open, *z_palpage, " - PROFONDEUR EN Z )", e$
        n$, "( E5 - VALEUR D APPROCHE )", e$
        n$, s_com_open, *w_palpage, " - ORIGINE DO )", e$
        n$, s_com_open, *a_palpage, " - DISTANCE A L ORIGINE EN X )", e$
        n$, s_com_open, *b_palpage, " - DISTANCE A L ORIGINE EN Y )", e$
        n$, "( Q2 - LIMITE DE PALPAGE )", e$
        n$, "( R2 - NOMBRE DE MESURES )", e$
        n$, "( T9998 - NUM. BLOC DE RETOUR SI PARCOUR SUP. A Q )", e$
        ]
    #n$, "M82 ; soufflage OFF", e$
    #p_ori_usi

pdrlcst_9    #Cycle de palpage Pt de réf. int. (exter) Diamètre"
    gcode$ = 0
    #profrelatif = (initht$-depth$) * ( -1)
    if drl_prm1$ = 1 | drl_prm2$ = 1, [
        d_palpage = peck1$
        z_palpage = z$
        w_palpage = dwell$
        a_palpage = x$
        b_palpage = y$
        a_palpage = a_palpage * -1
        b_palpage = b_palpage * -1
        w_palpage = w_palpage + 53
        if w_palpage > 69, w_palpage = w_palpage - 59
        ]
    if drl_prm1$ = 1, n$, "(REF. INT. DIAMETRE)", e$
    if drl_prm2$ = 1,    [
        d_palpage = d_palpage * -1
        n$, "(REF. EXT. DIAMETRE)", e$
        ]
    perreurPalp1
    if drl_prm1$ = 1 | drl_prm2$ = 1,    [
        n$, "G320 ", d_palpage, z_palpage, "E3. ", w_palpage, a_palpage, b_palpage, "Q2. R2 T9998", e$
        n$, s_com_open, *d_palpage, " - DIAMETRE DE PALPAGE )", e$
        n$, s_com_open, *z_palpage, " - PROFONDEUR EN Z )", e$
        n$, "( E3 - VALEUR D APPROCHE )", e$
        n$, s_com_open, *w_palpage, " - ORIGINE DO )", e$
        n$, s_com_open, *a_palpage, " - DISTANCE A L ORIGINE EN X )", e$
        n$, s_com_open, *b_palpage, " - DISTANCE A L ORIGINE EN Y )", e$
        n$, "( Q2 - LIMITE DE PALPAGE )", e$
        n$, "( R2 - NOMBRE DE MESURES )", e$
        n$, "( T9998 - NUM. BLOC DE RETOUR SI PARCOUR SUP. A Q )", e$
        ]
    #n$, "M82 ; soufflage OFF", e$
    #p_ori_usi

pdrlcst_12    #Cycle de palpage Pt de réf. EN Z"
    gcode$ = 0
    #profrelatif = (initht$-depth$) * ( -1)
    a_palpage = x$
    b_palpage = y$
    z_palpage = z$
    w_palpage = dwell$
    w_palpage = w_palpage + 53
    if w_palpage > 69, w_palpage = w_palpage - 59
    #perreurPalp1
    n$, "(REF. EN Z)", e$
    n$, "( G100=APPEL DU SOUS-PROG. 9010 )", e$
    n$, "( H=DISTANCE A PALPER JUSQU AU CENTRE PALETTE )", e$
    n$, "( W=ORIGINE CONCERNE )", e$
    n$, "( S=SUREPAISSEUR )", e$
    n$, "(INFORMER LA VALEUR DU --H-- )", e$
    n$, "(POUR INFO PALPAGE A : ", *z_palpage, s_com_close, e$
    n$, " ", e$
    n$, *xabs, *yabs, e$
    n$, "G100 H00", w_palpage, "S0. T9998", e$
    #n$, "M82 ; soufflage OFF", e$

pdrlcst_13   #Cycle de palpage Pt de réf. FACE EN X"
    gcode$ = 0
    z_palpage = z$
    w_palpage = dwell$
    a_palpage = x$
    a_palpage = a_palpage * -1
    w_palpage = w_palpage + 53
    if w_palpage > 69, w_palpage = w_palpage - 59
    #perreurPalp1
    if peck1$ = 1, [
        if x$ < 0, x_palpage = x$ -3
        if x$ > 0, x_palpage = x$ +3
        ]
    if peck1$ = -1,[
        if x$ < 0, x_palpage = x$ +3
        if x$ > 0, x_palpage = x$ -3
        ]
    n$, "(REF. EN X)", e$
    n$, "( G320 APPEL DU CYCLE )", e$
    n$, "( X EN + = APPROCHE VERS LE X+ )", e$
    n$, "( X EN - = APPROCHE VERS LE X- )", e$
    n$, "( Z - HAUTEUR DE PALPAGE )", e$
    n$, "( W = ORIGINE CONCERNE )", e$
    n$, s_com_open, *a_palpage, " - DISTANCE A L ORIGINE EN X )", e$
    n$, "( Q2 - LIMITE DE PALPAGE )", e$
    n$, "( R2 - NOMBRE DE MESURES )", e$
    n$, "( T9998 - NUM. BLOC DE RETOUR SI PARCOUR SUP. A Q )", e$
    n$, " ", e$
    n$, *x_palpage, e$
    n$, "G320 ", *z_palpage, *w_palpage, *a_palpage, "Q2. R2 T9998", e$
    perreurPalp2

pdrlcst_14   #Cycle de palpage Pt de réf. FACE EN Y"
    gcode$ = 0
    z_palpage = z$
    w_palpage = dwell$
    b_palpage = y$
    b_palpage = b_palpage * -1
    w_palpage = w_palpage + 53
    if w_palpage > 69, w_palpage = w_palpage - 59
    #perreurPalp1
    if peck1$ = 1, [
        if y$ < 0, y_palpage = y$ -3
        if y$ > 0, y_palpage = y$ +3
        ]
    if peck1$ = -1, [
        if y$ < 0, y_palpage = y$ +3
        if y$ > 0, y_palpage = y$ -3
        ]
    n$, "(REF. EN Y)", e$
    n$, "( G320 APPEL DU CYCLE )", e$
    n$, "( Y EN + = APPROCHE VERS LE Y+ )", e$
    n$, "( Y EN - = APPROCHE VERS LE Y- )", e$
    n$, "( Z - HAUTEUR DE PALPAGE )", e$
    n$, "( W = ORIGINE CONCERNE )", e$
    n$, s_com_open, *b_palpage, " - DISTANCE A L ORIGINE EN Y )", e$
    n$, "( Q2 - LIMITE DE PALPAGE )", e$
    n$, "( R2 - NOMBRE DE MESURES )", e$
    n$, "( T9998 - NUM. BLOC DE RETOUR SI PARCOUR SUP. A Q )", e$
    n$, " ", e$
    n$, *y_palpage, e$
    n$, "G320 ", *z_palpage, *w_palpage, *b_palpage, "Q2. R2 T9998", e$
    perreurPalp2

pdrlcst_15   #Cycle de palpage Pt de réf. EN X IN-OUT"
    gcode$ = 0
    z_palpage = z$
    k_palpage = depth$ - tosz$
    u_palpage = peck1$
    w_palpage = dwell$
    w_palpage = w_palpage + 53
    if w_palpage > 69, w_palpage = w_palpage - 59
    #perreurPalp1
    if drl_prm1$ = 1,n$, "( REF. INTER X )", e$
    if drl_prm2$ = 1, [
        u_palpage = u_palpage * -1
        #v_palpage = v_palpage * -1
        n$, "( REF. EXTER X )", e$
        ]
    n$, "(REF. EN X ENTRE 2 FACES)", e$
    n$, "( G320 APPEL DU CYCLE )", e$
    n$, "( U = COTE A MESURER EN X )", e$
    n$, "( U EN - = MESURE EXTER )", e$
    n$, "( U EN + = MESURE INTER )", e$
    n$, "( K - HAUTEUR DE PALPAGE )", e$
    n$, "( EN RELATIF -Z- DEPART )", e$
    n$, "( W = ORIGINE CONCERNE )", e$
    n$, "( Q2 - LIMITE DE PALPAGE )", e$
    n$, "( R2 - NOMBRE DE MESURES )", e$
    n$, "( T9998 - NUM. BLOC DE RETOUR SI PARCOUR SUP. A Q )", e$
    n$, " ", e$
    n$, "G320", *u_palpage, *k_palpage, *w_palpage, "Q2. R2 T9998", e$
    perreurPalp4

pdrlcst_16   #Cycle de palpage Pt de réf. EN Y IN-OUT"
    gcode$ = 0
    z_palpage = z$
    k_palpage = depth$ - tosz$
    v_palpage = peck2$
    #b_palpage = y$
    #b_palpage = b_palpage * -1
    w_palpage = dwell$
    w_palpage = w_palpage + 53
    if w_palpage > 69, w_palpage = w_palpage - 59
    #perreurPalp1
    if drl_prm1$ = 1, n$, "( REF. INTER Y )", e$
    if drl_prm2$ = 1, [
        v_palpage = v_palpage * -1
        #v_palpage = v_palpage * -1
        n$, "( REF. EXTER Y )", e$
        ]
    n$, "(REF. EN Y ENTRE 2 FACES)", e$
    n$, "( G320 APPEL DU CYCLE )", e$
    n$, "( V = COTE A MESURER EN Y )", e$
    n$, "( V EN - = MESURE EXTER )", e$
    n$, "( V EN + = MESURE INTER )", e$
    n$, "( K - HAUTEUR DE PALPAGE )", e$
    n$, "( EN RELATIF -Z- DEPART )", e$
    n$, "( W = ORIGINE CONCERNE )", e$
    n$, "( Q2 - LIMITE DE PALPAGE )", e$
    n$, "( R2 - NOMBRE DE MESURES )", e$
    n$, "( T9998 - NUM. BLOC DE RETOUR SI PARCOUR SUP. A Q )", e$
    n$, " ", e$
    n$, "G320", *v_palpage, *k_palpage, *w_palpage, "Q2. R2 T9998", e$
    perreurPalp4

fmt "Z" 4 nombre_Va_et_Vient
fmt "Z" 2 Z_dep_brosse
fmt "Z" 2 Z_fin_brosse
pdrlcst_18     # Cycle Brossage EBAVURAGE
    if CN_textes <> 0, [
        if numcoment = 0, omitseq$ = 1
        if typcycle = 0, n$, s_com_open, "CYCLE DECOMPOSE D EBAVURAGE A LA BROSSE", s_com_close, e$
        omitseq$ = old_omitseq
        ]
    if drill_4_axes = 1, p_drill_5axes
    pdrill_param
    typcycle = 1
    p_casse_modalite            # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    Z_dep_brosse = drl_sel_tos$
    Z_fin_brosse = z$
    initht_ = initht$
    n$, "M3 S20", e$
    n$, "G01", *Z_fin_brosse, "F300", e$
    n$, *ssa, pgamme, *spdlon, e$
    while nombre_Va_et_Vient < peck2$, [
        nombre_Va_et_Vient = nombre_Va_et_Vient +1
        n$, *Z_dep_brosse, e$
        n$, *Z_fin_brosse, e$
        ]
    nombre_Va_et_Vient = 0
    n$, *Z_dep_brosse, e$
    n$, "M5", e$
    gcode$ = 0
    n$, *sgcode, *initht_, e$
    perreurTaraud

pdrlcst_18_2     # Cycle Brossage EBAVURAGE
    if drill_4_axes = 1, p_drill_5axes_2
    pdrill_param
    xabs = x$
    yabs = y$
    gcode$ = 0
    n$, *sgcode, xabs, yabs, e$
    p_casse_modalite            # casser la modalité de xyzra
    p_casse_modalite_perce      # casser la modalité de la garde et la prof
    Z_dep_brosse = drl_sel_tos$
    Z_fin_brosse = z$
    initht_ = initht$
    n$, "M3 S20", e$
    n$, "G01", *Z_fin_brosse, "F300", e$
    n$, *ssa, pgamme, *spdlon, e$
    while nombre_Va_et_Vient < peck2$, [
        nombre_Va_et_Vient = nombre_Va_et_Vient +1
        n$, *Z_dep_brosse, e$
        n$, *Z_fin_brosse, e$
        ]
    nombre_Va_et_Vient = 0
    n$, *Z_dep_brosse, e$
    n$, "M5", e$
    gcode$ = 0
    n$, *sgcode, *initht_, e$

pdrlcst_19    # perçage très profond avec trous d'huile
    gcode$ = 0
    p_erreur_lub_perc_prof
    f_p_profond = abs(frplunge$ *2)
    depth_ = depth$
    tosz_ = tosz$
    initht_ = initht$
    refht_ = refht$
    z_dep_p_prof = tosz$ +2
    if dwell$ <1,    [
        tempo = dwell$
        tempo = tempo*1000
        ]
    dwell = 1
	n$, "( PERCAGE TRES PROFOND )", e$
    posi_p_prof = 1
    p_rot_perc_profond
    n$, "M4", *ssa, e$
    n$, s_tempo, *dwell, e$
    n$, "G1", *refht_, f_p_profond, e$   # Z secu dehors
    n$, *z_dep_p_prof, "(Z DEPART PLUS 2MM)", e$    # Z départ
    posi_p_prof = 2
    p_rot_perc_profond
    n$, "M3", *ssa, e$
    n$, s_tempo, *dwell, e$
    n$, *scoolantx, e$
    n$, s_tempo, *dwell, e$
    n$, *depth_, pavanceperce, e$
    #n$, *tempo, e$
    n$, "M9", e$
    n$, *tosz_, "F1000", e$
    posi_p_prof = 1
    p_rot_perc_profond
    n$, "M3", *ssa, e$
    n$, initht_, e$
    drillcyc$ = -1
    drlcst7 = 1
    perreurTaraud

pdrlcst_19_2    # perçage très profond avec trous d'huile
    gcode$ = 0
    p_position_trou
    #result = mprint(s_mess_per_prof)
    #result = mprint(s_mess_per_prof2)
    f_p_profond = abs(frplunge$ *2)
    z_dep_p_prof = tosz$ +2
    depth_ = depth$
    tosz_ = tosz$
    initht_ = initht$
    refht_ = refht$
    if dwell$ <1, [
        tempo = dwell$
        tempo = tempo*1000
        ]
    dwell = 1
	n$, "( PERCAGE TRES PROFOND )", e$
    n$, "M4",  e$
    n$, "G1", *refht_, f_p_profond, e$   # Z secu dehors
    n$, *z_dep_p_prof, "(Z DEPART PLUS 2MM)", e$    # Z départ
    posi_p_prof = 2
    p_rot_perc_profond
    n$, "M3", *ssa, e$
    n$, s_tempo, *dwell, e$
    n$, *scoolantx, e$
    n$, s_tempo, *dwell, e$
    n$, *depth_, pavanceperce, e$
    #n$, *tempo, e$
    n$, "M9", e$
    n$, *tosz_, "F1000", e$
    posi_p_prof = 1
    p_rot_perc_profond
    n$, "M3", *ssa, e$
    n$, initht_, e$
    drillcyc$ = -1
    drlcst7 = 1

pdrlcst_8_2
    n$, ";CYCLE DE PALPAGE N 1 ***", e$
    n$, ";A completer", e$

pdrlcst_9_2
    n$, ";CYCLE DE PALPAGE N 2 ***", e$
    n$, ";A completer", e$

pdrlcst_13_2
    n$, ";CYCLE DE PALPAGE N 6 ***", e$
    n$, ";A completer", e$

pdrlcst_14_2
    n$, ";CYCLE DE PALPAGE N 7 ***", e$
    n$, ";A completer", e$

pdrlcst_15_2
    n$, ";CYCLE DE PALPAGE N 8 ***", e$
    n$, ";A completer", e$

pdrlcst_16_2
    n$, ";CYCLE DE PALPAGE N 9 ***", e$
    n$, ";A completer", e$

#endregion

#region positions_percages_et_annulation
p_calcul_XYZ_percage_5x
    if axe_AB = 0, [
        prof_abs = z$
        garde_abs = w$ #refht$
        prof_inc = depth$ - refht$
        garde_inc = refht$ - initht$
        ]
    if axe_AB <>0, [
        if diviseur = 1, prof_abs = z$*cos(axe_AB) - y$*sin(axe_AB) * -1
        if diviseur = 2, prof_abs = z$*cos(axe_AB) - x$*sin(axe_AB)
        garde_abs = prof_abs + drl_sel_ref$        # plan Z de GARDE
        p_calcul_rot_pmx    #Pts X & Y
        ]
    if Mode_reglage_PP = 0, [
		#"zabs = fond du trou en ABSOLU VAL MC", e$	
		#"zabs = VALEUR DE REFERENCE POUR TOUS LES CALCULS DE ****Zs****", e$
		spaces$ = 1
		*z$, " ", *y$, " ", *znci$, *ynci$,  e$ 
		*drl_ref_z$, *drl_sel_ini$, *drl_sel_ref$, *drl_sel_tos$, e$
		*drl_init_z$, *drl_tos_z$, *drl_zdrl_z$, " ",  *w$, " ", *z$, *znci$, e$
		*depth$, " ", *refht$, *zabs, e$	#*prof_perc_abs_5x, 
		*drl_depth_z$, *zr$, e$
		spaces$ = 0
		]
	#if type_dec_4x_percage = 1, garde_abs = 0
    prof_inc = depth$ - refht$
    garde_inc = refht$ - initht$

p_XY_perc     # ecriture des x, y en abs ou incremental pour percage
	xabs = x$
    yabs = y$
    if rotaxis$ = 0, [           # XY CLASIQUE    et perçage 5 axes
        @depth$
        @refht$
        if opcode$ <> 16, [        # NON PERCAGE 5 axes
            prof_abs = depth$
            prof_inc = depth$ - refht$
            garde_abs = refht$
            garde_inc = refht$ - initht$
            ]
		if opcode$ = 16, p_calcul_XYZ_percage_5x
        !depth$
        !refht$
        if incremental = 0, xabs, yabs, prof_abs, garde_abs, !xinc, !yinc, !prof_inc, !garde_inc
        else, !xabs, !yabs, !prof_abs, !garde_abs, xinc, yinc, prof_inc, garde_inc
        ]
    if rotaxis$ <> 0, [    # SUBSTITUTION 	# 1er TROU UNIQUEMENT
		p_calcul_AB_pos_Subs
        @depth$
        @refht$
		prof_abs = (rotdia$/2) - abs(depth$)
        prof_inc = depth$ - ((rotdia$/2) - refht$) 
        garde_abs = refht$ + (rotdia$/2)
        garde_inc = refht$
        !depth$
        !refht$
        if incremental = 0, xabs, yabs, axeAB_subs, prof_abs, garde_abs, !xinc, !yinc, !axe_ABi, !prof_inc, !garde_inc
        else, !xabs, !yabs, !axeAB_subs, !prof_abs, !garde_abs, xinc, yinc, axe_ABi, prof_inc, garde_inc
        old_axe_AB = axeAB_subs
        nbrtour = int (axe_AB / 360)
        ]
    p_modal     # afficher en format modal
    !x$, !y$    # mise a jour XY
    old_x = xabs
    old_y = yabs

p_position_trou       # trous suivants
	n$, sinc_abs, p_XY_perc, e$

pcanceldc$  # Annulation de cyle fixe
    if opcode$ = 16, pdril5x_annul, ex$
    z$ = initht$              # z au plan de secu
    prof_abs = -99999        # raz des prof garde tempo
    garde_abs = -99999
    tempo = 0
    !prof_abs
    !garde_abs
    !tempo
    if rotaxis$ = 0, zabs = z$   # XYZ CLASIQUE
    else, zabs = z$ + (rotdia$/2)
    gcode$ = 5    # choix du gcode pour ecrire G80
    if palpeur = 0, [
        if incremental = 0, n$, sinc_abs, *sgcode, *zabs, !zinc, e$
        if incremental = 1, n$, sinc_abs, *sgcode, !zabs, zinc, e$
        ]
    palpeur = 0
    !z$
    old_z = zabs
#endregion
#endregion

#endregion

#region Type_d_opErations
# Type d'operation
s_too_lop_0    : "NON DEFINIT"
s_too_lop_1    : "CONTOUR"
s_too_lop_2    : "PERCAGE"
s_too_lop_3    : "POCHE"
s_too_lop_4    : "TRANSFORMATION-MIRROR ROTATE TRANSLATE"
s_too_lop_5    : "MULTI-SURF. EBAUCHE PARALLELLE"
s_too_lop_6    : "MULTI-SURF. EBAUCHE RADIALE"
s_too_lop_7    : "MULTI-SURF. EBAUCHE PROJECTION"
s_too_lop_8    : "MULTI-SURF. EBAUCHE ISOPARAM"
s_too_lop_9    : "MULTI-SURF. EBAUCHE CONTOUR"
s_too_lop_10   : "MULTI-SURF. EBAUCHE POCHE"
s_too_lop_11   : "MULTI-SURF. FINIT. PARALLELLE"
s_too_lop_12   : "MULTI-SURF. FINIT. RADIALE"
s_too_lop_13   : "MULTI-SURF. FINIT. PROJECTION"
s_too_lop_14   : "MULTI-SURF. FINIT. ISOPARAM"
s_too_lop_15   : "MULTI-SURF. FINIT. CONTOUR"
s_too_lop_16   : "OPERATION PAR C-HOOK"
s_too_lop_17   : "ENTREE MANUELLE"
s_too_lop_18   : "CERCLE"
s_too_lop_19   : "POINT"
s_too_lop_20   : "LIMITATION"
s_too_lop_21   : "REGLE"
s_too_lop_22   : "REVOLUTION"
s_too_lop_23   : "LETTRE"
s_too_lop_24   : "BALAYEE 2D"
s_too_lop_25   : "BALAYEE 3D"
s_too_lop_26   : "CARREAU"
s_too_lop_27   : "SECTION"
s_too_lop_28   : "PERCAGE 5-AXES"
s_too_lop_29   : "COURBE 5-AXES"
s_too_lop_30   : "PROJECT. SUR UN PLAN"
s_too_lop_31   : "PROJECT. SUR UN CYLINDRE"
s_too_lop_32   : "PROJECT. SUR UNE SPHERE"
s_too_lop_33   : "PROJECT. SUR UN CONE"
s_too_lop_34   : "PROJECT. SUR UNE SECTION"
s_too_lop_35   : "PROJECT. SUR UNE SURFACE"
s_too_lop_36   : "NON-ASSOCIATIF CONTOUR"
s_too_lop_37   : "NON-ASSOCIATIF PERCAGE"
s_too_lop_38   : "NON-ASSOCIATIF POCHE"
s_too_lop_39   : "MULTI-SURF. FINIT. PENCIL TRACE"
s_too_lop_40   : "MULTI-SURF. FINIT. LEFTOVER STOCK"
s_too_lop_41   : "MULTI-SURF. FINIT. STEEP"
s_too_lop_42   : "MULTI-SURF. FINIT. SHALLOW"
s_too_lop_43   : "MULTI-SURF. FINIT. CONSTANT SCALLOP"
s_too_lop_44   : "MULTI-SURF. EBAUCHE PLUNGE"
s_too_lop_45   : "MULTI-SURF. FINIT. 5-AXE ISOPARAM"
s_too_lop_46   : "MULTI-SURF. FINIT. 4-AXE"
s_too_lop_47   : "MERGED IN ASCII NCI"
s_too_lop_48   : "5-AXE SWARF"
s_too_lop_49   : "5-AXE ROLL DIE"
s_too_lop_50   : "NON DEFINIT"
s_too_lop_51   : "CONTOURNAGE AXIAL"
s_too_lop_52   : "CONTOURNAGE RADIAL"
s_too_lop_53   : "CONTOURNAGE AXE C"
s_too_lop_54   : "VE PERCAGE, NOT USED NON-ASSOCIATI"
s_too_lop_55   : "PERCAGE AXIAL"
s_too_lop_56   : "PERCAGE RADIAL"
s_too_lop_57   : "PERCAGE AXE C"
s_too_lop_58   : "NON DEFINIT"
s_too_lop_59   : "NON DEFINIT"
s_too_lop_60   : "EBAUCHE"
s_too_lop_61   : "FINITION"
s_too_lop_62   : "GORGE"
s_too_lop_63   : "FILETAGE"
s_too_lop_64   : "PERCAGE"
s_too_lop_65   : "POINT"
s_too_lop_66   : "DRESSAGE"
s_too_lop_67   : "TRONCONNAGE"
s_too_lop_68   : "GORGE"
s_too_lop_69   : "ENTREE MANUELLE"
s_too_lop_70   : "MERGED ASCII"
s_too_lop_71   : "NON DEFINIT"
s_too_lop_72   : "NON DEFINIT"
s_too_lop_73   : "NON DEFINIT"
s_too_lop_74   : "CONTOUR FIL"
s_too_lop_75   : "CYCLE FIL"
s_too_lop_76   : "POCHE FIL"
s_too_lop_77   : "ENTREE MANUELLE FIL"
s_too_lop_78   : "POINT FIL"
s_too_lop_79   : "4-AXES FIL"
s_too_lop_80   : "TRANSFORMATION FIL"
s_too_lop_81   : "ASSOCIATIVE TRIMMED FIL"
s_too_lop_82   : "MERGED IN ASCII NCI FIL"
 
s_too_lop_100  : "FILETAGE A LA FRAISE"				# +18
s_too_lop_101  : "EDIT COMMON OPERATION PARAMETERS"
s_too_lop_102  : "SURFACAGE"
s_too_lop_103  : "ASSOCIATIF LIMITATION"
s_too_lop_104  : "CONTROL OPERATION SOLID PERCAGE"
s_too_lop_105  : "SLOT MILL"
s_too_lop_106  : "HELIX BORE"
s_too_lop_107  : "MULTI-SURF. EBAUCHE REPRISE"
s_too_lop_108  : "ASSOCIATIF NESTING CONTAINER OPERATION"

s_too_lop_201  : "CYCLE FINITION"					# +83
s_too_lop_202  : "CYCLE EBAUCHE"
s_too_lop_203  : "CYCLE EBAUCHE ET FINITION"
s_too_lop_204  : "CYCLE EBAUCHE DRESSAGE"
s_too_lop_205  : "CYCLE EBAUCHE ET FINITION DRESSAGE"
s_too_lop_206  : "CYCLE MODEL REPETITION EBAUCHE"
s_too_lop_207  : "CYCLE MODEL REPETITION EBAUCHE ET FINITION"
s_too_lop_208  : "CYCLE GORGE EBAUCHE"
s_too_lop_209  : "CYCLE GORGE FINITION"
s_too_lop_210  : "RAPIDE EBAUCHE"
s_too_lop_211  : "RAPIDE FINITION"
s_too_lop_212  : "RAPIDE GORGE"
s_too_lop_213  : "OPERATION GENEREE PAR C-HOOK"
s_too_lop_214  : "TRANSFER BRUT"
s_too_lop_215  : "RETOURNE BRUT"
s_too_lop_216  : "AVANCE BARRE"
s_too_lop_217  : "SERRAGE - DESSERAGE MORS"
s_too_lop_218 : "Tailstock operation"
s_too_lop_219 : "Steadyrest operation"
s_too_lop_220 : "Pinch-turn operation"
s_too_lop_221 : "Custom operation with tool" 
s_too_lop_222 : "Custom operation without tool" 
s_too_lop_223 : "Custom operation reference"
s_too_lop_224 : "Plunge turn (chained geometry)"
s_too_lop_225 : "Plunge turn (point geometry)"
s_too_lop_226 : "Turret park operation"
s_too_lop_227 : "Custom threading"
s_too_lop_228 : "B-axis contour turning (Mill-Turn only)"
s_too_lop_229 : "--------"
s_too_lop_230 : "Simple bar feed (Mill-Turn only)"
s_too_lop_231 : "Bar feed with tool stop or tool pull (Mill-Turn only)"
s_too_lop_232 : "Spindle clamp/unclamp (Mill-Turn only)"
s_too_lop_233 : "Spindle advance/retract (Mill-Turn only)"
s_too_lop_234 : "Spindle sync (Mill-Turn only)"
s_too_lop_235 : "Tailstock advance/retract (Mill-Turn only)"
s_too_lop_236 : "Turret park (Mill-Turn only)"
s_too_lop_237 : "Center operation(Mill-Turn only)"
s_too_lop_238 : "Steady rest operation(Mill-Turn only)"
s_too_lop_239 : "Steady rest point operation(Mill-Turn only)" 

s_too_lop_416 : "ENGRAVING"  					# +77          
s_too_lop_439 : "ART"                  
s_too_lop_309 : "5AXMSURF"           
s_too_lop_441 : "SWARF 5AX"            
s_too_lop_442 : "MORPH 5AX"            
s_too_lop_443 : "PARALLEL 5AX"        
s_too_lop_444 : "ALONGCURVE 5AX"      
s_too_lop_445 : "MESH 5AX"           
s_too_lop_446 : "ROUGHING 5AX"         
s_too_lop_447 : "PROJECT 5AX"          
s_too_lop_448 : "CONVERT 5AX"          
s_too_lop_449 : "PORT EXPERT"          
s_too_lop_450 : "BLADE EXPERT"         
s_too_lop_451 : "ROTARY ADV"           
s_too_lop_459 : "DEBURR"               
s_too_lop_460 : "EBAUCHE 3+2 AUTOM."  
s_too_lop_461 : "UNIFIE"               

s_too_lop : ""
fstrsel s_too_lop_0 tool_op$ s_too_lop 147 -1
#endregion

#region infos_outils_liste
#------------------Liste des OUTILS---------------------------------------------------
smanu : ""                      # string info outil texte dans "mandrin" (manufactured)
smand : ""                      # string info outil texte dans "mandrin" (chuck name)
snom_porte_outil : ""
snom_assemblage_outil_porte_outil : ""
sposi_porte_out_def : "Porte"   # string test prEsence "porte outil par dEfaut"
fmt   	7 posi_porte_out_defaut
fmt 	2 long_smanu
fmt   	2 longsmand
fmt   	5 paramT1               # N° outil
fmt   	5 paramT2               # Type d'outil
fmt   	5 paramT3               # Matiere de l'outil 1=Rapide 2=carbure 3=carbure revetu 4=cermet 5=borzon
fmt   	5 paramT4               # Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt "D=" 3 paramT5              # Diametre
fmt "R=" 3 paramT6              # Rayon de bout
fmt "P=" 3 paramT7              # PAS / Nombre de filet par mm
fmt "A=" 3 paramT8              # Angle de bout
fmt   	5 paramT9               # N° de correcteur de rayon
fmt   	5 paramT10              # N° de correcteur de longeur
fmt   	3 paramT11              # Avance travail
fmt   	3 paramT12              # Avance plongee
fmt   	3 paramT13              # Avance retraction
fmt   	5 paramT14              # Vitesse de broche
fmt   	5 paramT15              # Type de lubrification 0=arret 1=eau 2=air 3=broche 4=les 2
fmt "NBR-DENTS="  5 paramT16    # Nombre de dents

# géométrie de l'outil
fmt   	3 paramT20              # Diamètre pilote
fmt "EP=" 3 paramT21           	# Hauteur de coupe
fmt "HS=" 3 paramT22           	# Hauteur de sortie totale
fmt   	3 paramT23              # Hauteur helice
fmt   	3 paramT24              # Diametre de queue
fmt   	3 paramT25              # Diametre porte-outil
fmt   	3 paramT26              # Hauteur porte-outil
fmt   	5 paramT27              # 0=sens horaire 1=sens horaire
fmt   	5 paramT28              # % de la vitesse de coupe
fmt   	5 paramT29              # % de l'avance par dent
fmt   	4 paramT30              # 0=pouces 1=metrique

#RENVOIE D ANGLE Aggregate head parameters
fmt   	3 paramT41   			# Head axis in X
fmt   	3 paramT42   			# Head axis in Y
fmt   	3 paramT43   			# Head axis in Z
fmt   	3 paramT44   			# Head body type: (0 = cylinder, 1 = square)
fmt   	3 paramT45   			# Head body diameter
fmt   	3 paramT46   			# Head body length
fmt   	3 paramT47   			# Station body type (0 = cylinder, 1 = square)
fmt   	3 paramT48   			# Station body diameter
fmt   	3 paramT49   			# LONG: SORTIE / pince--> face  pince -- Station body length

stypT00 : "FORME"
stypT01 : "FORET A C."
stypT02 : "FORET A P."
stypT03 : "FORET"
stypT04 : "TARAUD A D."
stypT05 : "TARAUD A G."
stypT06 : "ALESOIR"
stypT07 : "BARRE D ALES."
stypT08 : "FR. COUTEAU"
stypT09 : "FR. A EBAVUR."
stypT10 : "FR."
stypT11 : "FR. BOULE"
stypT12 : "FR. A CHANF."
stypT13 : "TOURTEAU"
stypT14 : "FR. 3 T."
stypT15 : "FR. CONCAVE"
stypT16 : "FR. QUEUE D ARONDE"
stypT17 : "FR. CONIQUE TRONQUEE"
stypT18 : "FR. SPHERIQUE"
stypT19 : "FR. TORIQUE"
stypT20 : "SPECIALE"
stypT21 : "FRAISE A GRAVER"
stypT22 : "FORET BRAD"
stypT23 : "BARRE D ALESAGE"
stypT24 : "FRAISE A FILETER"
stypT25 : "FRAISE TONNEAU"
stypT26 : "FRAISE DEPOUILLE"
stypT27 : "FRAISE LENTILLE"
stypT28 : "FRAISE LENTILLE TONNEAU"
stypT29 : "DIVERS"
stypeT : ""
fstrsel stypT00 paramT2 stypeT 30 -1

smatT0  : ""
smatT1  : "HSS"
smatT2  : "CA."
smatT3  : "CA. REVETU"
smatT4  : "CERMET"
smatT5  : "BORZON"
smatT6  : "BORZON"
smatT7  : "BORZON"
smatT8  : "BORZON"
smatT9  : "BORZON"
smatT10 : "INCONNU"
smatT : ""
fstrsel smatT0 paramT3 smatT 11 -1

ppas       # afficher ou non le pas
    if paramT7 > 0, *paramT7

ptypeBoutT # afficher on non le rayon de bout
   if paramT4 <> 0, *paramT6

pangleT    # afficher on non l'angle de l'outil
   if paramT2 = 2 | paramT2 = 3 | paramT2 = 9 | paramT2 = 12 | paramT2 = 13 | paramT2 = 16 | paramT2 = 17, *paramT8

phauteurT  # afficher la hauteur de dent pour une fraise 3 tailles
   if paramT2 = 14, paramT21

ptype      # Pour afficher le texte des outils perso suivant comment. dans "mandrin" (chuck name)
    @longsmand
    #if longsmand > 5, *smand   # attention pas d'espaces dans cette case "mandrin"
    #else, *stypeT
    if longsmand > 3, *strtool$,
    else, *stypeT
    longsmand = 0

pporte_outil
    posi_porte_out_defaut = strstr(sposi_porte_out_def, snom_porte_outil)
    if posi_porte_out_defaut < 1, [
        if Nom_porte_outil_entete = 1, n$, s_com_open, "porte out.:", no_spc$, snom_porte_outil, *paramT22, s_com_close, e$
        if Nom_porte_outil_entete = 2, n$, s_com_open, "Assemblage:", no_spc$, snom_assemblage_outil_porte_outil, *paramT22, s_com_close, e$
        if Nom_porte_outil_entete = 3, n$, s_com_open, "porte out.:", no_spc$, snom_porte_outil, "Assemblage:", no_spc$, snom_assemblage_outil_porte_outil, *paramT22, s_com_close, e$
        if Nom_porte_outil_entete > 0 & ra_type$ = 1 & ra_block$ >0, n$, s_com_open, "RENVOIE D'ANGLE AVEC LONGUEUR DE L AXE Z A LA FACE DE :", *paramT49, s_com_close, e$
        ]

pwrttparam$    # lire les parametres (des outils) avant la sortie de l'ISO
    if affiche_prmcodes = 0, "-->pwrttparam DONNEES avant la sortie de l'ISO", ~prmcode$, "=", ~sparameter$, e$
    if syncaxis$ <> old_syncaxis, nbr_combi = nbr_combi + 1
    old_syncaxis = syncaxis$
    if prmcode$ = 15166, workofs_pwrtt = rpar(sparameter$, 1)    	#15166=Val origine de base
                                                                	#15181=Val Numéro de l'origine actif
                                                                	#15333=Val départ incrément, op transformation
    #if prmcode$ = 15334, workofs_dec = rpar(sparameter$, 1)		#15334=Val incrément, op transformation
    if prmcode$ = 20002, smanu = sparameter$
    if prmcode$ = 20003, smand = sparameter$
    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)
    if prmcode$ = 20007, paramT20 = rpar(sparameter$, 11)
    if prmcode$ = 20008, paramT41 = rpar(sparameter$, 9)
    #if prmcode$ = 12727, snom_porte_outil = sparameter$
    if prmcode$ = 20020, snom_porte_outil = sparameter$
    if prmcode$ = 20021, snom_assemblage_outil_porte_outil = sparameter$
    longsmand = strlen(smand)

parrosage  # affichage de "arrosage au centre"
    if paramT15 = 2, "ARROSAGE AU CENTRE"

pwrtt$      # Liste d'outils & infos (--> lecture avant traitement parcours)
    strtool$ = ucase(strtool$)
    # vErification des rotations avant le traitement ISO
    if m9$ <> 1, rotation_axe = 1               # Inclinaison des axes
    if nextop$ = 11, rotation_axe = 1           # useaxe = 1    #si pas de lecture def armoire en OP 5 axes seule
    if m1$ = 1 & m5$ <> 1, rotation_A = 1       # incliné en Y uniquement (et Z) = ROTATION SUR L'AXE X
    if m1$ <> 1 & m5$ = 1, rotation_B = 1       # incliné en X uniquement (et Z) = ROTATION SUR L'AXE Y
    if m1$ <> 1 & m5$ <> 1, rotation_axe = 2    # Erreur de plan
    if ra_type$ = 1 & ra_block$ >0, renvoi_d_angle = 1
	if ra_type$ = 1 & ra_block$ >0, rotation_axe = 0	# FORCE pas de 4 axes avec le RENVOI  
	
	# calcul nombre d'outils pour les temps
	# Temps de changement d'outil
	if t$ > 0, Nbr_outils = Nbr_outils + 1	# a changer
	
	if Affiche_temps_dll = 1, [ 	# TEMPS DE L OUTIL			
		if t$ > 0 & t$ <> old_t & old_t <> -9999, [	
			info_temps = 2, p_temps_affectation
			if Types_Temps_DLL = 2, [
				p_Convert_time_dll 
				n$, "  ", s_com_open, "TPS OUT. = ", *Heure, *min, *sec, s_com_close, e$
				Tot_time_Out = 0
				]
			]
		]	

    # pour info : Type_infos_outil
    # 1 = NOM de l'outil "texte NOM" --> strtool$
    # 3 = NOM MC de l'outil et Infos géométrique réelle de l'outil
    # 4 = NOM de l'outil "texte NOM" & Infos géométrique réelle de l'outil --> = 0 + 2
    if Liste_outils, [
        if nom_outil = 1, [
            if t$ > 0, [
                if strtool$ = svide, n$, s_com_open, "ERREUR-OUTIL SANS NOM", s_com_close, e$
                else, [
                    n$, s_com_open, "T", paramT1, '"', no_spc$, "T", no_spc$, *strtool$, no_spc$, '"',
                        if Type_infos_outil = 1, s_com_close, e$
                        if Type_infos_outil = 2 | Type_infos_outil= 4, "--", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
                        if Type_infos_outil = 3, "--", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
                    ]
                pporte_outil
                ]
            ]
        if nom_outil = 0, [
			!outils_param
            if outils_param = 0, [   # sans les parametres
                if t$ > 0, [
                    if Type_infos_outil = 1, n$, s_com_open, "T", paramT1, strtool$, s_com_close, e$
                    if Type_infos_outil = 2 | Type_infos_outil = 3, n$, s_com_open, "T", paramT1, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
                    if Type_infos_outil = 4, n$, s_com_open, "T", paramT1, strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
                    pporte_outil
                    ]
                ]
            if outils_param = 1,  [  # avec les parametres
                outil_paramT1 = paramT1
                paramT1 = paramT1 + 500
                if t$ > 0, [
                    if Type_infos_outil = 1, n$, 35, paramT1, no_spc$, "=", outil_paramT1, s_com_open, no_spc$,  "T", paramT1, strtool$, s_com_close, e$
                    if Type_infos_outil = 2 | Type_infos_outil = 3, n$, 35, paramT1, no_spc$, "=", outil_paramT1, s_com_open, no_spc$,  no_spc$, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
                    if Type_infos_outil = 4, n$, 35, paramT1, no_spc$, "=", outil_paramT1, s_com_open, no_spc$,  strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$
                    pporte_outil
                    ]
                ]
            ]
        ]
    # Décalages d'origines en entête à afficher --> NE PAS LAISSER DE DECALLAGES VIDES --> METTRE UN "0"
    if affiche_ori_entete > 0, [
        # 0|1=55 / 2=56 /.../ 6=54.1 P1 /...
		if xform_op_id$ <> op_id$, workofs_pwrtt = workofs$ & workofs_dec > 0, workofs_pwrtt = workofs_pwrtt +54   # OPERATIONS TRANSFORMEES 
		if xform_op_id$ = op_id$, workofs_pwrtt = workofs_pwrtt +54	  
        if affiche_ori_entete = 1 | affiche_ori_entete = 11, subout$ = 1    # sous la liste d'outil
        if affiche_ori_entete = 2 | affiche_ori_entete = 22, subout$ = 3    # dans un autre fichier
        compteur_workofs = compteur_workofs + 1
        if compteur_workofs = 1, n$, " ", e$, n$, s_com_open, "ORIGINES UTILISES :", s_com_close, e$
        if workofs_pwrtt <> old_workofs, [
            if (workofs_pwrtt = 53 | workofs_pwrtt = 54) & ori_1 =0, workofs_pwrtt = 54, n$, s_com_open, "G", *workofs_pwrtt, s_com_close, e$, ori_1 = 1
            if workofs_pwrtt = 55 & ori_2 =0, n$, s_com_open, "G", *workofs_pwrtt, s_com_close, e$, ori_2 = 1
            if workofs_pwrtt = 56 & ori_3 =0, n$, s_com_open, "G", *workofs_pwrtt, s_com_close, e$, ori_3 = 1
            if workofs_pwrtt = 57 & ori_4 =0, n$, s_com_open, "G", *workofs_pwrtt, s_com_close, e$, ori_4 = 1
            if workofs_pwrtt = 58 & ori_5 =0, n$, s_com_open, "G", *workofs_pwrtt, s_com_close, e$, ori_5 = 1
            if workofs_pwrtt = 59 & ori_6 =0, n$, s_com_open, "G", *workofs_pwrtt, s_com_close, e$, ori_6 = 1
            if workofs_pwrtt = 60 & ori_7 =0, workofs_pwrtt = workofs_pwrtt - 59, n$, s_com_open, "G54.1 P", *workofs_pwrtt, s_com_close, e$, ori_7 = 1
            if workofs_pwrtt = 61 & ori_8 =0, workofs_pwrtt = workofs_pwrtt - 59, n$, s_com_open, "G54.1 P", *workofs_pwrtt, s_com_close, e$, ori_8 = 1
            if workofs_pwrtt = 62 & ori_9 =0, workofs_pwrtt = workofs_pwrtt - 59, n$, s_com_open, "G54.1 P", *workofs_pwrtt, s_com_close, e$, ori_9 = 1
            ]
        old_workofs = workofs_pwrtt
        subout$ = 0
        ]
    #temps DLL POUR EVENTUELLEMENT L'AFFICHER EN ENTETE **BRUT DE Mc **SANS AFFINAGE POSSIBLE** & 
    sdllTimeOp = spathpst$ + "TimeOp.dll"	# A LAISSER DANS LE PWRTT$
	if Affiche_temps_dll = 1, [ 
	    if last_op_id_pwrtt <> op_id$,    [
	        sOpId = no2str(op_id$)
	        result = dll(sdllTimeOp,sOpId)
	        timeOp = rpar(spost_arg_1$,1)
	        timeTT = timeTT + timeOp
			Tot_time_Out = Tot_time_Out + timeOp		
			# TEMPS DE L OPERATION
			info_temps = 1, p_temps_affectation
			if Types_Temps_DLL = 1, [
				p_Convert_time_dll 	#"aaaaa", *Tot_time_op, e$
				n$, "  ", s_com_open, "TPS OPE. = ", *Heure, *min, *sec, s_com_close, e$
				]
	        ]	
        strtool$ = ucase(strtool$)
		last_op_id_pwrtt = op_id$
		]
    if t$ <> old_t, old_t = t$
	if arctype$ <> 5 & arctype$ <> 2 & erreur_type_arcs = 1, p_erreur_config_type_arc
    ptravel
    pwritbuf5
	
#endregion

#region entete_OP_commentaires
#**************************** Affichage des commentaires de début d'OP en entete Prog.
stextentete : ""
stextecoupe : ""
svirgule : ","
sposiNomprog : "/PROGRAMMEUR/"
sposiClient : "/CLIENT/"
sposiPiece : "/NOM PIECE/"
sposiNumplan : "/NUM PLAN/"
sposiIndiceplan : "/INDICE/"
#Textes origines
sposiX  : "/X/"
sposiY  : "/Y/"
sposiZ  : "/Z/"
#Texte Orientation
sposiOrient : "/ORIENTATION/"
#Texte Divers
sposInfos : "/INFO/"
#sposivirgule : ""    # la virgule indique le saut à la ligne
sSlash : "/"
sposiA  : "/A/"
ssansA  : "PAS DE A"

fmt 7 posiNomprog
fmt 7 posiClient
fmt 7 posiNomPiece
fmt 7 posiNumplan
fmt 7 posiIndiceplan
fmt 7 posiX
fmt 7 posiY
fmt 7 posiZ
fmt 7 posiOrientation
fmt 7 posiInfo
fmt 7 posivirgule
fmt 7 posicoupe
fmt 7 posiA
fmt 7 posiSlash
fmt 7 long_TEXTE

ptextentete
    stextentete = scomm$
    long_TEXTE = strlen(stextentete)
    posiNomprog = strstr(sposiNomprog, stextentete)
    posiClient = strstr(sposiClient, stextentete)
    posiNomPiece = strstr(sposiPiece, stextentete)
    posiNumplan = strstr(sposiNumplan, stextentete)
    posiIndiceplan = strstr(sposiIndiceplan, stextentete)
    posiX = strstr(sposiX, stextentete)
    posiY = strstr(sposiY, stextentete)
    posiZ = strstr(sposiZ, stextentete)
    posiOrientation = strstr(sposiOrient, stextentete)
    posiInfo = strstr(sposInfos, stextentete)
    posivirgule = strstr(svirgule, stextentete)
    posiA = strstr(sposiA, stextentete)
    #posivirgule = strstr(svirgule, stextentete)
    posiSlash = strstr(sSlash, stextentete)
    longTexte = 1
    if posiNomprog <>0,
        [
        posicoupe = posiNomprog+13
        pcoupetexte
        n$, " ( PAR.", stextecoupe, s_com_close, e$
        ]
    if posiClient >0,
        [
        posicoupe = posiClient+8
        pcoupetexte
        n$, " ( CLIENT.", stextecoupe, s_com_close, e$
        ]
    if posiNomPiece >0,
        [
        posicoupe = posiNomPiece+11
        pcoupetexte
        n$, " ( PIECE.", stextecoupe, s_com_close, e$
        ]
    if posiNumplan >0,
        [
        posicoupe = posiNumplan+10
        pcoupetexte
        n$, " ( PLAN.",stextecoupe, s_com_close, e$
        ]
    if posiIndiceplan >0,
        [
        posicoupe = posiIndiceplan+8
        pcoupetexte
        n$, " ( INDICE.",stextecoupe, s_com_close, e$
        ]
    if posiX >0,
        [
        posicoupe = posiX+3
        pcoupetexte
        n$, " ( ORIGINE.)", e$, n$, " ( X.", stextecoupe, s_com_close, e$
        ]
    if posiY >0,
        [
        posicoupe = posiY+3
        pcoupetexte
        n$, " ( Y.", stextecoupe, s_com_close, e$
        ]
    if posiZ >0,
        [
        posicoupe = posiZ+3
        pcoupetexte
        n$, " ( Z.",stextecoupe, s_com_close, e$
        ]
    if posiA >0,
        [
        posicoupe = posiA+3
        pcoupetexte
        if stextecoupe <> ssansA, n$, " ( A.",stextecoupe, s_com_close, e$, useaxe = 1
        ]
    if posiOrientation >0,
        [
        posicoupe = posiOrientation+13
        pcoupetexte
        n$, " ( ORIENTATION PIECE. )",e$, n$, " (", stextecoupe, s_com_close, e$
        ]
    if posiInfo >0,
        [
        posicoupe = posiInfo+6
        pcoupetexte
        n$, " ( *****************************)",e$
        n$, " (", stextecoupe, s_com_close, e$
        ]
    #if posivirgule > 0,
        #[
        #posicoupe = posivirgule+1
        #pcoupetexte
        #n$, " (",stextecoupe, s_com_close, e$
        #]
    if posiSlash = 0 & long_TEXTE > 0,
        [
        n$, " (", scomm$, s_com_close, e$
        ]

pcoupetexte #coupe le texte
            stextecoupe = brksps(posicoupe, stextentete)

#endregion

#region modif_nom_fichiers
#------------------------ RENOMMER LE FICHIER NC EN FONCTION DU NUMERO DE PROGRAMME -------------------------
snom_nc : ""             # STRING de stockage du non du NC complet avec chemin et extension style c:\cfao\prog-cn\TOTO.NC
snom_numero : ""         # STRING de stockage du non du NC sous forme O0123.nc avec chemin et extesion style c:\cfao\prog-cn\ous forme O0123.NC
spoint : ""              # STRING du POINT pour l'extenssion (.NC)
#stringo                 # STRING du O pour le non (O0123) en nom du Numero PRG
#seditor : "C:\WINNT\system32\notepad.exe"                                             # non de l'editeur pour les prog en nom du Numero PRG (avec chemin complet si pas dans Windows)
#seditor : "C:\WINDOWS\notepad.exe"                                                    # XP non de l'editeur pour les prog en nom du Numero PRG (avec chemin complet si pas dans Windows)
#seditor : "C:\Program Files\Microsoft Office\Office\WINWORD.EXE"                      # ouvrir avec WORD
#seditor : "C:\Mcam91\Common\Editors\Cedit\CIMCOEdit.exe"                              # ouvrir avec CIMCOEDIT (ne fonctionne pas)
#seditor : "C:\mcamx\common\editors\mastercam\MCXStart.exe"                            # ouvrir avec Editeur MCX
seditor  : "C:\Program Files\Mastercam 2022\Mastercam\Extensions\CodeExpert.exe"    # NOUVEL EDITEUR MC"

sdebut : "F"
smachine : "-SNH"
snouv_nom : ""
schange_nom_fichier : "" #nouveau nom uniquement, sans le chemin
snomprogentete : ""
#sfraisage_ "\FRAISAGE\"
#stous_clients "\TOUS_CLIENTS\"
sext : ""            # extention
spoint2 : "."          # STRING du POINT pour l'extenssion (.NC) UNIQUEMENT pour les entêtes prog.
fmt 7 posipoint
#fmt 7 posiFraisage_
#fmt 7 posiTous_clients
sfileops : ""                           # string du nom du fichier OPS
sops : ".ops"                           # extention des fichier OPS
spathnc_ : "C:\MASTERCAM FICAM\ISO\"     # chemin pour les fichiers ISO
sdebut2 : "PR"
snom_entete : ""
#sprogno = progno$

pnom_nc     # Génération des noms du fichier NC
    #snom_fichier = sdebut+snamenci+smachine+spoint+sextnc
    snom_nc = spathnc_+snamenc$+spoint+sextnc$             	#spathnc$ Fichier NC en cours de creation sous forme toto.nc
    #snom_numero = no2str (progno)
    snouv_nom = spathnc_+sdebut2+snamenci$+spoint+sextnc$  	#spathnc$ nouveau non de fichier NC sous forme F15662-A-2-HE.H
    schange_nom_fichier = snouv_nom
    snom_entete = sdebut+smcname$+smachine+spoint+sextnc$ 	#0300 nouveau non de fichier NC sous forme F15662-A-2-HE.H  AFFICHE EN COMMENTAIRE
    #smcpath$ = ucase (smcpath$)        #retourne le chemin du fichier CN
    #smcname$ = ucase (smcname$)        #Nom du fichier NC
    #smcext$ = ucase (smcext$)          #retourne l'extention du pst
    #snamepst$ = ucase (snamepst$)      #retourne le nom du pst

ptest_nom   # test du non du fichier NC si O0123.NC
    #progno2 = progno
    if fexist (snouv_nom), pchange_nom
        #[
        #Q10
         #pchange_nom   #ex #snom_numero
        #if remplace = 0, pchange_nom
        #if remplace = 1, result = remove (snouv_nom)
        #pchange_nom
        #snouv_nom = schange_nom_fichier
        #]
    pmodif_nom_entete

pchange_nom     # changer le numéro de prog si fichier exite déja
    while fexist (snouv_nom),       #(snom_numero)
        [
        q20
        #snom_numero = no2str (progno)
        #snouv_nom = spathnc+sdebut+snouv_nom+smachine+spoint+sextnc
        snouv_nom = schange_nom_fichier
        ]
    pmodif_nom_entete

pmodif_nom_entete   #modif nom au début et fin de l'ISO
    snomprogentete = snouv_nom
    #posiTous_clients = strstr(stous_clients, snomprogentete)
    #posiTous_clients = posiTous_clients + 14
    snomprogentete = brksps(25,snomprogentete)
    #if posiTous_clients > 15,
        #[
        #snomprogentete = brksps(posiTous_clients,snomprogentete)
        #]
    #else,
        #[
        #posiFraisage_ = strstr(sfraisage_, snomprogentete)
        #posiFraisage_ = posiFraisage_ + 10
        #snomprogentete = brksps(posiFraisage_,snomprogentete)
        #]
    #enlever l'extention de fichier ex: .H
    #ex. string2 = brksps (posipoint, string1)
    #   string1 = O1235     string2 = txt
    posipoint = strstr(spoint2, snomprogentete)
    sext = brksps (posipoint, snomprogentete)

ppost$       # traitement après post pro pour effacer le fichier OPS et renommer le fichier NC
	if change_nom = 0, ex$                      # pour 0 = pas de changement sur le fichier
    snouv_nom = ucase(snouv_nom)
    sfileops = spathnci$ + snamenci$ + sops     # non du fichier ops
    result = remove (sfileops)                  # éfface le fichier ops (si existant, en fonction de la question 1524 du PST
                                                # ou d'après la config MC, fichier utile pour les params surep_XY_2D...
    result = remove (snouv_nom)                 # efface fichier en nom numero
    result = rename (snom_nc, snouv_nom)        # renommer fichier NC en nom numero
    snouv_nom = sguillemet + snouv_nom + sguillemet
    result = launch (seditor, snouv_nom)        # lancer le blocnote
#endregion

#region infos_limites_parcours
ptravel    # Tool travel limit calculation
    if x_min$ < x_tmin, x_tmin = x_min$
    if x_max$ > x_tmax, x_tmax = x_max$
    if y_min$ < y_tmin, y_tmin = y_min$
    if y_max$ > y_tmax, y_tmax = y_max$
    if z_min$ < z_tmin, z_tmin = z_min$
    if z_max$ > z_tmax, z_tmax = z_max$

# --------------------------------------------------------------------------
# Buffer 5  Read / Write Routines
# --------------------------------------------------------------------------
pwritbuf5   # Write Buffer 1
    b5_gcode = gcode$
    b5_zmin = z_min$
    b5_zmax = z_max$
    b5_gcode = wbuf(5, wc5)

preadbuf5   # Read Buffer 1
    size5 = rbuf(5,0)
    b5_gcode = 1000
    min_depth = 999
    max_depth = -999
    while rc5 <= size5 & b5_gcode = 1000, [
      if rc5 <= size5, b5_gcode = rbuf(5,rc5)
      if b5_zmin < min_depth, min_depth = b5_zmin
      if b5_zmax > max_depth, max_depth = b5_zmax
        ]
#endregion

[ENDBIN]

#region TEXTES_XML
[CTRL_TEXT_XML_BEGIN]  # All post text edits must be made through Control Definition Manager
<?xml version="1.0" encoding="UTF-8"?>
<mp_xml_post_text xml:space="preserve">
	<control>
		<control_label>CTRL_MILL|DEFAULT</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>				
				<text>En 4 axes utiliser le Z sécu de l'OP : 1</text>
				<value>1</value>
			</misc_2>
			<misc_3>
				<text>Val. angulaire index. broche (mortaisage)</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>Bris outil 1=AXIAL-FORET 2=FRAISE 3=??</text>
			</misc_5>
			<misc_6>
				<text>Test_Bris_Out =1 (en FIN d OPERATION)</text>
			</misc_6>
			<misc_7>
				<text>Blocage déblocage AXES ROT. 1=OUI 0=NON</text>
				<value>1</value>
			</misc_7>
			<misc_8>
				<text>ORI.TRANSF. 1=G54.. 2=G52xyz 3=G92 </text>	
				<value>1</value>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>test</text>
				<inch_value>0</inch_value>
				<metric_value>-419.5</metric_value>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<description>
				<text>Perçage Lamage G81 G82</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Débourrage G83</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Inc Q</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Brise copeaux G73</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>""</text>	#<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Inc Q</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>	#dans param. machine 5114 <text>Remonté D</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>	#<text>Garde approche D</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>Taraudage G84 : débourrage</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Inc Q : débourrage si &gt; 0 </text>
				<value>0</value>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Alésage G85</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
				<value>0</value>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>Alésage indexe G75</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>""</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Profondeur</text>
			</depth>
			<first_peck>
				<text>Prof. de passe</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Retr. Br-copeaux</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc1>
		<misc2>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc2>
		<drill_cycle_9>
			<description>
				<text>Réf. Inter Exter rectangle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Long. en X</text>
			</first_peck>
			<subsequent_peck>
				<text>Larg. en Y</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_9>
		<drill_cycle_10>
			<description>
				<text>Réf. Inter Exter Cercle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Diametre nominal</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_10>
		<drill_cycle_11>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_11>
		<drill_cycle_12>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_12>
		<drill_cycle_13>
			<description>
				<text>Réf. PALPAGE en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_13>
		<drill_cycle_14>
			<description>
				<text>Réf. PALPAGE FACE X</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>VERS X+=1/X-=-1</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_14>
		<drill_cycle_15>
			<description>
				<text>Réf. PALPAGE FACE Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>VERS Y+=1/Y-=-1</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_15>
		<drill_cycle_16>
			<description>
				<text>Réf. ENTRE 2 FACES X</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Z BOUT PALP.</text>
			</first_peck>
			<subsequent_peck>
				<text>LONG. A PALPER</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_16>
		<drill_cycle_17>
			<description>
				<text>Réf. ENTRE 2 FACES Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Z BOUT PALP.</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>LONG. A PALPER</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_17>
		<drill_cycle_18>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_18>
		<drill_cycle_19>
			<description>
				<text>Brosse Ebavurage trous</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>Nombre de va et vient</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_19>
		<drill_cycle_20>
			<description>
				<text>Percage tres profond</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MAT.</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 1</text>
			</description>
			<parameter_1>
				<text>1-DEcomposer le cycle en G1-G0 = 1</text>
				<value>0</value>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>		
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 2</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>2-DEcomposer le cycle en G1-G0 = 1</text>
				<value>0</value>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 3</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>3-DEcomposer le cycle en G1-G0 = 1</text>
				<value>0</value>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>		
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Rectangle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter rectangle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter rectangle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Cercle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter Cercle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter Cercle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 11</text>
			</description>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 12</text>
			</description>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 13</text>
			</description>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>Réf. FACE en X</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Réf. FACE en Y</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Réf. Int./Ext. EN X</text>
			</description>
			<parameter_1>
				<text>Réf. Inter FACES = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter FACES = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Réf. Int./Ext. EN Y</text>
			</description>
			<parameter_1>
				<text>Réf. Inter FACES = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter FACES = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Percage tres profond</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Perçage G81 G82</text>
			</simple_drill>
			<peck_drill>
				<text>Débourrage G83</text>
			</peck_drill>
			<chip_break>
				<text>Brise copeaux G73</text>
			</chip_break>
			<tapping>
				<text>Taraudage G84 : débourrage</text>
			</tapping>
			<boring_1>
				<text>Alésage G85</text>
			</boring_1>
			<boring_2>
				<text>Alésage Indexe G75</text>
			</boring_2>
			<misc_drill_1>
				<text>""</text>
			</misc_drill_1>
			<misc_drill_2>
				<text>""</text>
			</misc_drill_2>
			<custom_drill_9>
				<text>Ref. Inter Exter. Rectangle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Poche rectangul INTER-EXTER_1.bmp</resource>
			</custom_drill_9>
			<custom_drill_10>
				<text>Réf. Inter Exter. Cercle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\CERCLE INTER-EXTER_1.bmp</resource>
			</custom_drill_10>
			<custom_drill_11>
				<text>""</text>
			</custom_drill_11>
			<custom_drill_12>
				<text>""</text>
			</custom_drill_12>
			<custom_drill_13>
				<text>Réf. FACE EN Z</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -Z-_1.bmp</resource>
			</custom_drill_13>
			<custom_drill_14>
				<text>Réf. FACE EN X</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -X-_1.bmp</resource>
			</custom_drill_14>
			<custom_drill_15>
				<text>Réf. FACE EN Y</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -Y-_1.bmp</resource>
			</custom_drill_15>
			<custom_drill_16>
				<text>Réf. EN X IN-OUT</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\ENTRE 2 FACES_X_1.bmp</resource>
			</custom_drill_16>
			<custom_drill_17>
				<text>Réf. EN Y IN-OUT</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\ENTRE 2 FACES_Y_1.bmp</resource>
			</custom_drill_17>
			<custom_drill_18>
				<text>Cycle 18</text>
			</custom_drill_18>
			<custom_drill_19>
				<text>Brosse Ebavurage</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Brosse Ebavurage.bmp</resource>
			</custom_drill_19>
			<custom_drill_20>
				<text>Percage trEs profond</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\PERCAGE TRES PROFOND_1.bmp</resource>
			</custom_drill_20>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>M00</text>
			</canned_text_1>
			<canned_text_2>
				<text>M01</text>
			</canned_text_2>
			<canned_text_3>
				<text>BLOC OPTIONNEL ON</text>
			</canned_text_3>
			<canned_text_4>
				<text>BLOC OPTIONNEL OFF</text>
			</canned_text_4>
			<canned_text_5>
				<text>REPRISE</text>
			</canned_text_5>
			<canned_text_6>
				<text>ZONE 1</text>
			</canned_text_6>
			<canned_text_7>
				<text>ZONE 2</text>
			</canned_text_7>
			<canned_text_8>
				<text>EBAUCHE</text>
			</canned_text_8>
			<canned_text_9>
				<text>FINITION</text>
			</canned_text_9>
			<canned_text_10>
				<text>AJOUT BRIDEs</text>
			</canned_text_10>
			<canned_text_11>
				<text>ENLEVER BRIDEs</text>
			</canned_text_11>
		</canned_text>
	</control>
<control>
		<control_label>CTRL_MILL|MILL_ST_FANUC_ROTATION-A-OU-B</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>En 4 axes utiliser le Z sécu de l'OP : 1</text>
				<value>1</value>
			</misc_2>
			<misc_3>
				<text>Val. angulaire index. broche (mortaisage)</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>Bris outil 1=AXIAL-FORET 2=FRAISE 3=??</text>
			</misc_5>
			<misc_6>
				<text>Test_Bris_Out =1 (en FIN d OPERATION)</text>
			</misc_6>
			<misc_7>
				<text>Blocage déblocage AXES ROT. 1=OUI 0=NON</text>
				<value>1</value>
			</misc_7>
			<misc_8>
				<text>ORI.TRANSF. 1=G54.. 2=G52xyz 3=G92 </text>
				<value>1</value>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>test</text>
				<inch_value>0</inch_value>
				<metric_value>-419.5</metric_value>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<description>
				<text>Perçage Lamage G81 G82</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Débourrage G83</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Inc Q</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Val retour (DECOMP. uniquement)</text>
				<value>0.5</value>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Brise copeaux G73</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
				<value>0</value>
			</dwell>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Inc Q</text>
			</first_peck>
			<subsequent_peck>
				<text>Val Q suivant (DECOMP. uniquement)</text>
				<value>0.5</value>
			</subsequent_peck>
			<peck_clearance>
				<text>Val retour (DECOMP. uniquement)</text>
				<value>0.5</value>
			</peck_clearance>
			<retract_amount>
				<text>Val. remontee (DECOMP. uniquement)</text>
				<value>0.7</value>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>Taraudage G84 : débourrage</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>Inc Q : débourrage si &gt; 0 </text>
				<value>0</value>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Alésage G85</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>Alésage indexe G75</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Saut bride</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Profondeur</text>
			</depth>
			<first_peck>
				<text>Prof. de passe</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Retr. Brise copeaux</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc1>
		<misc2>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc2>
		<drill_cycle_9>
			<description>
				<text>Réf. Inter Exter rectangle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Long. en X</text>
			</first_peck>
			<subsequent_peck>
				<text>Larg. en Y</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_9>
		<drill_cycle_10>
			<description>
				<text>Réf. Inter Exter Cercle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Diametre nominal</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_10>
		<drill_cycle_11>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_11>
		<drill_cycle_12>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_12>
		<drill_cycle_13>
			<description>
				<text>Réf. PALPAGE en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_13>
		<drill_cycle_14>
			<description>
				<text>Réf. PALPAGE FACE X</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>VERS X+=1/X-=-1</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_14>
		<drill_cycle_15>
			<description>
				<text>Réf. PALPAGE FACE Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>VERS Y+=1/Y-=-1</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_15>
		<drill_cycle_16>
			<description>
				<text>Réf. ENTRE 2 FACES X</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Z BOUT PALP.</text>
			</first_peck>
			<subsequent_peck>
				<text>LONG. A PALPER</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_16>
		<drill_cycle_17>
			<description>
				<text>Réf. ENTRE 2 FACES Y</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>1=G54 2=G55...NEW</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>Z BOUT PALP.</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>LONG. A PALPER</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_17>
		<drill_cycle_18>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_18>
		<drill_cycle_19>
			<description>
				<text>Brosse Ebavurage trous</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>Nombre de va et vient</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_19>
		<drill_cycle_20>
			<description>
				<text>Percage tres profond</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MAT.</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 1</text>
			</description>
			<parameter_1>
				<text>1-DEcomposer le cycle en G1-G0 = 1</text>
				<value>0</value>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 2</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>2-DEcomposer le cycle en G1-G0 = 1</text>
				<value>0</value>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>		
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 3</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>3-DEcomposer le cycle en G1-G0 = 1</text>
				<value>0</value>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>		
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Rectangle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter rectangle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter rectangle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Cercle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter Cercle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter Cercle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 11</text>
			</description>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 12</text>
			</description>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 13</text>
			</description>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>Réf. FACE en X</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Réf. FACE en Y</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Réf. Int./Ext. EN X</text>
			</description>
			<parameter_1>
				<text>Réf. Inter FACES = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter FACES = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Réf. Int./Ext. EN Y</text>
			</description>
			<parameter_1>
				<text>Réf. Inter FACES = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter FACES = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Percage tres profond</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Perçage G81 G82</text>
			</simple_drill>
			<peck_drill>
				<text>Débourrage G83</text>
			</peck_drill>
			<chip_break>
				<text>Brise copeaux G73</text>
			</chip_break>
			<tapping>
				<text>Taraudage G84 : débourrage</text>
			</tapping>
			<boring_1>
				<text>Alésage G85</text>
			</boring_1>
			<boring_2>
				<text>Alésage Indexe G75</text>
			</boring_2>
			<misc_drill_1>
				<text>""</text>
			</misc_drill_1>
			<misc_drill_2>
				<text>""</text>
			</misc_drill_2>
			<custom_drill_9>
				<text>Ref. Inter Exter. Rectangle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Poche rectangul INTER-EXTER_1.bmp</resource>
			</custom_drill_9>
			<custom_drill_10>
				<text>Réf. Inter Exter. Cercle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\CERCLE INTER-EXTER_1.bmp</resource>
			</custom_drill_10>
			<custom_drill_11>
				<text>""</text>
			</custom_drill_11>
			<custom_drill_12>
				<text>""</text>
			</custom_drill_12>
			<custom_drill_13>
				<text>Réf. FACE EN Z</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -Z-_1.bmp</resource>
			</custom_drill_13>
			<custom_drill_14>
				<text>Réf. FACE EN X</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -X-_1.bmp</resource>
			</custom_drill_14>
			<custom_drill_15>
				<text>Réf. FACE EN Y</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -Y-_1.bmp</resource>
			</custom_drill_15>
			<custom_drill_16>
				<text>Réf. EN X IN-OUT</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\ENTRE 2 FACES_X_1.bmp</resource>
			</custom_drill_16>
			<custom_drill_17>
				<text>Réf. EN Y IN-OUT</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\ENTRE 2 FACES_Y_1.bmp</resource>
			</custom_drill_17>
			<custom_drill_18>
				<text>Cycle 18</text>
			</custom_drill_18>
			<custom_drill_19>
				<text>Brosse Ebavurage</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Brosse Ebavurage.bmp</resource>
			</custom_drill_19>
			<custom_drill_20>
				<text>Percage trEs profond</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\PERCAGE TRES PROFOND_1.bmp</resource>
			</custom_drill_20>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>M00</text>
			</canned_text_1>
			<canned_text_2>
				<text>M01</text>
			</canned_text_2>
			<canned_text_3>
				<text>BLOC OPTIONNEL ON</text>
			</canned_text_3>
			<canned_text_4>
				<text>BLOC OPTIONNEL OFF</text>
			</canned_text_4>
			<canned_text_5>
				<text>REPRISE</text>
			</canned_text_5>
			<canned_text_6>
				<text>ZONE 1</text>
			</canned_text_6>
			<canned_text_7>
				<text>ZONE 2</text>
			</canned_text_7>
			<canned_text_8>
				<text>EBAUCHE</text>
			</canned_text_8>
			<canned_text_9>
				<text>FINITION</text>
			</canned_text_9>
			<canned_text_10>
				<text>AJOUT BRIDEs</text>
			</canned_text_10>
			<canned_text_11>
				<text>ENLEVER BRIDEs</text>
			</canned_text_11>
		</canned_text>
	</control>
</mp_xml_post_text>
[CTRL_TEXT_XML_END]
#endregion
