[POST_VERSION] #DO NOT MOVE OR ALTER THIS LINE# V27.00 P0 E1 W27.00 T1722257585 M27.00 I0 O0
# ----------------------------------------
# - REALISE PAR                	--> FS
# ---------------------------------------- config PP
# - TYPE PP                 	--> FRAISAGE
# - NOMBRE d'AXES            	--> 4
# - AXE                     	--> A ou B
# - TYPE DE LANGAGE         	--> HEIDENHAIN
#            VERSION            --> 530 ...
# ---------------------------------------- client / infos machine
# - CLIENT                    	--> 
# - NON MACHINE                	-->  
# - AXE ROTATIF(1)            	--> A/B
# ----------------------------------------
#
# Variables d'ajustement des temps d'usinage
# 	- Valeurs fixes en secondes, après être remonté au point haut ***changement UNIQUEMENT***
#	correction de la valeur définie dans "l'armoire" 1 Seconde par défaut 
Temps_chang_outil 	: 5		# secondes en +- par outil
# A configurer par type d'opération 
#	- en utilisant un FACTEUR 1=1 1.1= * 1.1 le temps de ces types d'opérations
coefficient_G0		: 10	# Facteur de correction des rapides en --> accélération & décélération 
							# exprimé en 1/10 de secondes d'accélération/décélération par "G0"
							# obligatoirement > 0 --> 1 mini 

#region possibilites_PP
# ---------------------------------------- infos complEmentaires
# - RESTRICTIONS            	--> OUI - numéro de clé/en durée/version MC
# - ENTETEs
#                   ANCIENNE    --> OUI
#                   NOUVELLE    --> OUI
#         OP MC COMMENTAIRE     --> OUI
# - LECTURE INFOS ARMOIRE    	--> OUI ou NON --> Suivant config choisie dans le PP
# - LECTURE INFOS MACHINE/AXES  --> OUI ou NON --> Suivant config choisie dans le PP
# - ORIGINES     
# 	               		Def 7	--> valeurs ou TABLEAU POINT ZERO
#			Depuis le palpage   --> OUI
#                CYCL DEF 247   --> OUI - figE A 1 au dEpart
# - INSPECTION D'OUTIL         	--> OUI
# - ARROSAGES VX            	--> OUI
# - AVANCES EN VARIABLES    	--> OUI
# - APPEL OUTILS EN VARIABLES	--> OUI
# - APPEL OUTILS SUIVANT EN NOM --> OUI
# - USURE INVERSE "DR-"			--> OUI / NON 
# - CYCLES PALPAGES            	--> OUI / OPTIONNEL
# - SOUS-PROGRAMMES
#                       en Z    --> OUI
#                translation    --> OUI
#                   Rotation    --> OUI
#                     Miroir    --> OUI
# - SUBSTITUTION D'AXES			--> OUI
# - TEXTES AVANT/AVEC/APRES 	--> OUI / NON a completer
# ---------------------------------------- infos complEmentaires
# - SIMULATION ISO				--> NON
# - PERCAGES AVANCé				--> OUI - ARROSAGES et ROTATIONS BROCHE
# - PERC. TRES PROFOND          --> OUI - M4,G1Z...,M3,M7...
# - PERCAGES "5 AXES" A ou B	--> OUI
#			TRANSITION SECU		--> OUI
# - MODIFICATION AUTO DU NOM    --> OUI	- F12345.H ou 12345-HERM.H ou F12345-HERM.H
# - OUVERTURE D'UN AUTRE EDITEUR--> OUI
# - AFFICHAGE DU TEMPS D'USINAGE
# 					PAR OUTIL 	--> OUI
#						TOTAL	--> OUI
#					TOTAL DLL	--> OUI
# - AJUSTEMENT DES TEMPS   		--> OUI	--> explications ci-dessous 
# - ARRET CONTROLE BRIS D'OUTIL	--> OUI 
# - CYCLE TEST BRIS D'OUTIL		--> OUI --> A VALIDER
# - OPTIMISATION AVANCES ARCS	--> NON/OUI MC
# - RENVOIE D'ANGLE				--> OUI
# - MORTAISAGE ANGULAIRE BROCHE --> NON --> A DEVELOPPER
# - ORIGINES EN ENTETE			--> OUI
# 						FICHIER	--> OUI
# - BLOCAGE-DEBLOCAGE axe A/B	--> OUI
# - GESTION DES PALETTES 		--> OUI
# - Axes A/B en DEG/Mn			--> OUI
# - CYCLE D EBAVURAGE BROSSE	--> OUI
# - ORIGINE par TRANSFORMATION	--> OUI --> A DEVELOPPER
# - RENVOI D'ANGLE
#					FIXE MANUEL --> OUI
#				CIRCULAIRE AUTO --> OUI ?
# ---------------------------------------- INFOS
# mi1$ utilisé pour "CYCLE 247 PT DE REF utilisé: 1,2,3...
# mi2$ utilisé pour FORCER le Z sécu de l'op si la config est remonter en Z HAUT 
# mi3$ utilisé pour "Val. angulaire index. broche (mortaisage)
# mi4$ utilisé pour "Parametres sur avances 0= OUI 0=NON
# mi5$ utilisé pour "Bris outil 1=AXIAL-FORET 2=FRAISE 3=??
# mi6$ utilisé pour "Test_Bris_Out =1 (en FIN d OPERATION)
# mi7$ utilisé pour Ecrire M10 M11 (blocage/dEblocage du diviseur)
# 	
# mr1$ 
# (n°de Décalage) 1. 2...SUIVANT mi3$ et def 7 suivant #1 #2... 
# ecriture des parametres dans NCI et du fichier OPS (pour lire les infos de surep)
#
# lecture de la def armoire pour :
#   l'extension de l'iso
#   les arcs /CONFIGURATION FORCEE dans le PP
#   les commentaires
#   la preparation de l'outil suivant
# Lecture de la def machine pour :
#   Le nom de la machine
#   Le nombre d'axes rotatif (1 seul supporté)
#   Le sens de rotation de l'axe rotatif
#
# Affichages (à activer): 
#	surepaisseurs OPs
#	type de compensations outils par OP 
#
# AJUSTEMENT DES TEMPS   		
# 	Acces au client aux variables pour ajuster 
#	suivant des types d'opérations uniquement
# ----------------------------------------
#endregion

# ----------------------------------------
erreur_type_arcs	= 1	# message d'alerte si les ARCS sont mal configurés dans la DEF. ARMOIRE

# ----- dEgagements au changement d'outil, rotations d'axes et inspection de plaquettes
smode_deg   : "R0 FMAX M91" 		# Mode de degagement des axes "R0 FMAX M91/M92"
smode_deg2  : "R0 FMAX M92" 		# Mode de degagement des axes "R0 FMAX M91/M92" --> Pour faire cohabiter les 2
S_macro_deg : "M130 ; RET. PT CHANG. OUTIL"				# NOM de la macro de dégagement si active
# configuration des dEgagements
# --------------------------------  0=SANS  1=Z  2=Z-X  3=Z-Y  4=Z-X-Y  5=Z-XY 6=MACRO_CN
deg_debut   		: 3     		# Degagement au debut du prog 
deg_outil			= 3    			# Degagement au changement d'outil       	          	
deg_4_axes 			= 1				# Degagement au changement de position en 4 axes ET RENVOI D'ANGLE
										# 0 = VALEURS MC DE L'OPERATION
deg_fin     		: 3     		# Degagement en fin de programme 
									# 0 = VALEURS MC DE L'OPERATION 
deg_inspection_plaq = 3     		# Degagement l'outil lors de l'inspection de l'état de l'outil 
deg_apres_outil		= 0				# >0 = Affichage des dégagements EGALEMENT apres l'appel de l'outil "sécurité" lors du démarrage à X outil 
									# type = idem au "deg_outil" 									 
deg_palette_deb_fin = 4     		# dEgagements au debut et fin prog pour rotation des palettes 
										# s'il y a un élément génant pour la rotation, ex: bloc du 4ème axe         
# CHANGEMENT D'OUTIL (Et en 3 axes)
# Exemple : "L Z-1, R0 FMAX M91"
degageX    = -1						# Valeur de degagement en X pour l'appel d'outil 
degageY    = -1  					# "    Y "
degageZ    = -1  					# "    Z "

# FIN
degageX_fin = -1					# Valeur de degagement en X UNIQUEMENT EN FIN DE PROGRAMME 
degageY_fin = -1  					# "    Y "
degageZ_fin = -1 					# "    Z "

# en 4 axes	--> ENTRE 2 opérations		SI "deg_4_axes" = 0 valeur X/Y & Z = à la valeur SECURITE de l'opération MASTERCAM
# et TETE A RENVOI
degageX4   = -1 					# Valeur de degagement en X avant rotation
degageY4   = -1  					# "    Y "
degageZ4   = -1 					# "    Z " 

# dEgagements palettes 				# si palettes actives "dEgagements au debut et fin prog pour rotation des palettes 	
degageX_pal = -1 					# Valeur de degagement en X avant rotation
degageY_pal = -1  					# "    Y "
degageZ_pal = -1 					# "    Z " 

# 	SI "deg_inspection_plaq " = 0 valeur X/Y & Z = à la valeur SECURITE de l'opération MASTERCAM
deg_insp_X = 0 						# Valeur de degagement en X avant inspection de l'état de la plaquette 
deg_insp_Y = 0  					# "    Y "
deg_insp_Z = 0						# "    Z " 

# ----------------------------------------------
Cycles_palpage_YN	= 0  	# activation ou pas de l'utilisation des cycles de palpages "BASICs" (en perCages)
change_nom  		= 0     # 1 = nomination des programmes avec un préfix "PF" + "numARTICLE" + "INDICE" + "CODE_CN"  = PF15662-A-2-HE.H ////	0 = NOM DANS MC	
F_variables        	= 0  	# utiliser les avances F en variables FQ
output_z    		= 0  	# Output Z Min and Z Max des parcours (1 ou 0)
program_stop        = 22    # Stop M00 ou M01
							# 1 = M00 AVANT le changement d'outil
							# 2 = M01 AVANT le changement d'outil
							# 11 = M00 APRES le changement d'outil
							# 22 = M01 APRES le changement d'outil
entete_questions	= 2 	# 0 = pas d'entEte
                        	# 1 = entEte suivant OP MC TEXTE
                        	# 2 = Nouvelle entEte questions
                        	# 3 = Ancienne entEte questions
affiche_ori_entete	= 1		# Affiche les origines du programme en entête
							# 0 = NON
							# 1 = APRES LA LISTE D'OUTILS
							# 11 = APRES LA LISTE D'OUTILS SI > 0
							# 2 = DANS UN FICHIER A PART
							# 22 = DANS UN FICHIER A PART si > 0
#Outils ----------------------------------------
Type_appel_outil	= 1		# 1 = NUMERO de l'outil 					"TOOL CALL 1...
							# 2 = NOM de l'outil 						"FRAISE D..."
							# 3 = VARIABLE suivie du NUMERO de l'outil 	"FN 0: Q1811 =11 ; FR. CA. D=8. 
							
Type_infos_outil	= 3		# 1 = NOM de l'outil "texte NOM" --> strtool$
							# 2 = Infos géométrique réelle de l'outil
							# 3 = NOM MC de l'outil et Infos géométrique réelle de l'outil
							# 4 = NOM de l'outil "texte NOM" & Infos géométrique réelle de l'outil --> = 1 + 2
Position_info_outil = 1		# 1 = Affichage AVANT l'appel de l'outil
							#		Nxx T2 M6
							# 2 = Affichage APRES l'appel de l'outil
						
utilise_palette		= 0		# Affiche la gestion des palettes, codes M début et fin pour rotations et degagements outils avant rotations
							# 1 = Fonctions M uniquement sans dEgagements spécifiques
							# 11 = Fonctions M ET dEgagements spécifiques

Type_decalages		= 2		# Cycle de décallages/origine en OPERATIONS DE TRANSFORMATIONS
							# 1 = CYCLE 247 UNIQUEMENT
							# 2 = CYCLE 247 au DEPART et CYCLE DEF 7 sur les autre origines
							
#prEparation de l'outil SUIVANT
bldnxtool$          = 1     # 0 = n'affiche pas la préparation de l'outil suivant
                            # 1 = affiche				
type_prep_outil     = 0     # 0 = Pas de prEparation du 1er outil
                            # 1 = PrEparation A chaque outil (ptlchg$)
                            # 2 = PrEparation A chaque outil et A LA FIN (peof)
# Déchargement de l'outil en broche
decharge_outil_fin  = 1     # 1 = affiche un "T0 M6" à la fin

# RENVOI D'ANGLE
S_maxi_renvoi_angle = 2000	#
prepa_out_renvoi	= 0		# 1 = préparation de l'outil avec le renvoi d'angle		

# ----						
Use_DR				= 0 	# Utiliser la commande DR-(rayon outil) pour correction "usure inverse"

lire_def_machine    = 1     # 1 = Lire les valeurs de la def machine / armoire --> AXES/ARCs/cycles ...
                            # 0 = suivant les données du PP
							
Systeme_rot_plans	= 0 	# SystEme de gestion des différentes valeurs lors d'une rotation
                                # 0  = pas de calculs --> origine gEnEralement au centre de la palette
                                # 1  = calculs AUTO "G68" --> origine oU on veut
                                # 2X =	Calcul suivant une transition de l'origine CALCULé
									# 21 = utilise le sous-programme O8000 pour calculer automatiquement les origines pour chaque face
                                    	# utilise_O8000 --> G54 au dEbut et ensuite G55 calculE, Exemple : G54 G90 B122.; M98 P8000 ...
                                    	# Fichier contenant le O8000 à integrer dans la CN et valider
									# 22 = suivant un décalage d'origine G52/92 calculé
									# 23 = création du G54 depuis un G55 ou G59 avec les coordonnées de l'axe de rotation 
										# rotation en A info de Y et Z
										# rotation en B info de X et Z
                                # 3  = un origine par angle de rotation dEfini par l'opérateur --> G54,G55 ...
                                # 4  = FONCTION "M" en ABSOLU module de rotation à part "automate" (1 ORIGINE PAR ANGLE)
                                # 5  = FONCTION "M" en RELATIF **chaque M=90°** module de rotation à part "capteur automate" (1 ORIGINE PAR ANGLE)
#
rot_AB_un_sens  	= 0			# sens AB 	0 = libre (en +/-) 	1 = SEULEMENT dans le sens + pour certaines CNs	

Affiche_temps_dll	: 0 # 1 = YES / 0 = NO							 
#string de reference	 654321								
s_Types_Temps_DLL 		"111111.00000000"	# configuration des différents affichages
					# OPTIMISES  
					# 	"100000.00000000" = Uniquement à la fin du programme 
					# 	"010000.00000000" = A chaque outil 
					# 	"001000.00000000" = A chaque Opération 
					# 	"110000.00000000" = 6+5
					# 	"111000.00000000" = 6+5+4
					# EN ENTETE --> NON optimisEs
					# 	"000100.00000000" = TOTAL 
					# 	"000010.00000000" = par OUTIL
					# 	"000001.00000000" = par OPERATION								

affiche_groupe 		: no$   	# 0/no$ = pas d'affichage des groupes d'usinage, 1/yes$ = affichage
info_corr   		: 1     	# afficher le type de correction
info_surep     		: 1  		# afficher les surepaisseurs
Nom_porte_outil_entete 	= 3		# Affiche le nom du porte outil avec la liste des outils en entête, s'il y en a un
									# 1 = porte outil & longueur de sortie
									# 2 = assemblage & longueur de sortie
									# 3 = porte outil & assemblage & longueur de sortie								

affiche_num_op_MC		= 2		# affiche le numéro de l'OP Masctercam extraite 
									# 1 = depuis la DLL
									# 2 = prmcode$

affiche_type_op_MC		= 1		# affiche le type de l'opération MC

groupe_descripteur		= 0		# Affiche en ENTETE 0 = NON
									# 1 Nom de la Machine
									# 2 Nom du groupe PRINCIPAL d'opErations
									# 3 Nom du groupe 1
									# 4 Descripteur de fichier
									# 5 Les 4 	

nom_programmeur_PC 		= 0 	# Affiche le nom du programmeur
									# 1 = Nom du programmeur
									# 2 = Non de l'ORDI
									# 3 = Les deux

type_dec_4x_percage		= 0		# Type de gestion du perçage 4/5 axes
									# 0 perçage en absolu, classique
									# 1 perçage en relatif depuis le nouveau pt XYZ passé à 0	

appel_param_outils 		= 1		# Affiche un LBL 999 et LBL 0 au debut et fin appel outil pour rafraichissement

block_form              = 1 	# Sortie du TYPE de BRUT et DIMENSIONS

convoyeur				= 1 #

compteur_pieces			= 1	#

#----------outils
affiche_M6		: no$ 			# Affichage ou pas du "M6"
Liste_outils	: yes$  		# A préviligier pour activer la liste d'outils au "tooltable$"  			
tooltable$     	: yes$  		# creation de la liste d'outil en entete -
								# Toujours ACTIVE pour lire d'autres infos depuis le PWRTT$
								# Output tool table  0=no, 1=before header, 2=after header 
                    			# 3= Pre-read, call the pwrtt postblock

#----------Blocs
seqmax$        	: 99999
omitseq$       	: no$  			# yes$ = pas de numerotation de blocs
seqno$ 			: 1
seqinc$ 		: 1 
force_n0     	: no$   		# Force le "0" au 1er N

# QUESTIONS ENTETE ----------------------------------------------------
# Questions UNIQUEMENT des STRINGS NON VIDES !!
s_texte_question_1 : "CLIENT"
s_texte_question_2 : "DESIGNATION PIECE"
s_texte_question_3 : "NUMERO DU PLAN"
s_texte_question_4 : "INDICE DU PLAN"
s_texte_question_5 : "NUM. PHASE :"
s_texte_question_6 : "ORIGINE PIECE"
s_texte_question_7 : "X :"
s_texte_question_8 : "Y :"
s_texte_question_9 : "Z :"
s_texte_question_10 : "COMMENTAIRE :"
s_texte_question_11 : ""
s_texte_question_12 : ""
s_texte_question_13 : ""
s_texte_question_14 : ""
s_texte_question_15 : ""
s_texte_question_16 : "NOMBRE DE PIECES EN PALETTE A :" 	# ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M..."
s_texte_question_17 : "NOMBRE DE PIECES EN PALETTE B :"	# ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
s_texte_question_18 : ""
s_texte_question_19 : ""
s_texte_question_20 : "Numero de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"

# CODES M -------------------------------------------------------------

# --------------------------------------------------------------------------
# Coolant output code selection for X style coolant
# Note: To enable X style coolant, click on the General Machine Parameters icon
#   in the Machine Definition Manager, Coolant tab, disable first check box
#   Output of X style coolant commands in this post is controlled by pcan, pcan1, & pcan2
scool50    : "M8 ; BUSE ON"                		#Coolant 1 on value
scool51    : "M9"                				#Coolant 1 off value
scool52    : "M56 ; AIR ON"                		#Coolant 2 on value
scool53    : "M9"                 				#Coolant 2 off value
scool54    : "M7 ; ARROSAGE AU CENTRE ON"    	#Coolant 3 on value
scool55    : "M9"   							#Coolant 3 off value
scool56    : "M8(Coolant4=ON)"    				#Coolant 4 on value
scool57    : "M9"   							#Coolant 4 off value
scool58    : "M8(Coolant5=ON)"    				#Coolant 5 on value
scool59    : "M9"   							#Coolant 5 off value
scool60    : "M8(Coolant6=ON)"    				#Coolant 6 on value
scool61    : "M9"   							#Coolant 6 off value
scool62    : "M8(Coolant7=ON)"    				#Coolant 7 on value
scool63    : "M9(Coolant7=OFF)"   				#Coolant 7 off value
scool64    : "M8(Coolant8=ON)"    				#Coolant 8 on value
scool65    : "M9(Coolant8=OFF)"   				#Coolant 8 off value
scool66    : "M8(Coolant9=ON)"    				#Coolant 9 on value
scool67    : "M9(Coolant9=OFF)"   				#Coolant 9 off value
scool68    : "M8(Coolant10=ON)"   				#Coolant 10 on value
scool69    : "M9(Coolant10=OFF)"  				#Coolant 10 off value
scoolantx : ""                    				#Target for string

fstrsel scool50 coolantx scoolantx 20 -1

#X coolant has the option - First coolant off command shuts off ALL coolant options
sall_cool_off  : "M09" #Coolant off command output with all_cool_off
# --------------------------------------------------------------------------
# Blocage déblocage 4ieme Axe -------------------------
sblo0 	: ""       	# pour pas de blocage ni deblocage
sblo1	: "M10"   	# blocage axe A
sblo2   : "M11"   	# déblocage axe A
sblo3 	: ""       	# pour Frein axe A
sbloque : ""
fstrsel sblo0 bloque sbloque 4 -1
#-------------------------------------------------------
sm_00   : "M4"
sm_01   : "M5"
sm_02   : "M3"
spdlon 	: ""
spdir2 = fsg3(spdir$)
fstrsel  sm_00 spdir2 spdlon 3 -1
#-------------------------------------------------------
# GESTION DES TEXTES OPTIONNELS
s_texte_0	 : ""
s_texte_1    : "M0" 					#N° 1                 		
s_texte_2    : "M1" 					#N° 2                 				
s_texte_3    : "; BLOC OPTIONNEL ON"                		
s_texte_4    : "; BLOC OPTIONNEL OFF"                 				
s_texte_5    : "; REPRISE"  
s_texte_6    : "; ZONE 1"                		
s_texte_7    : "; ZONE 2"                				
s_texte_8    : "; EBAUCHE"                		
s_texte_9    : "; FINITION"                 				
s_texte_10   : "; AJOUTER LES BRIDES"
s_texte_11   : "; ENLEVER LES BRIDES" 	#N° 11            				 	
s_liste_textes : ""                    				

fstrsel s_texte_0 liste_textes s_liste_textes 11 -1

#s_texte_12   : "BLOC OPTIONNEL ON"		#N° 1101  
#s_texte_13   : "BLOC OPTIONNEL OFF"	#N° 1102                  				
#s_texte_14   : "REPRISE"                		
#s_texte_15   : "BLOC OPTIONNEL OFF"                 				
#s_texte_16   : "REPRISE"  
#s_texte_17   : "ZONE 1"                		
#s_texte_18   : "ZONE 2"                				
#s_texte_19   : "EBAUCHE"                		
#s_texte_20   : "FINITION"				#N° 1109
#s_texte_20   : "FINITION"				#N° 1110 ... 1119   
# --------------------------------------------------------------------------
s_convoyeur_ON		: "M35 ;CONVOYEUR ON"
s_convoyeur_OFF		: "M36 ;CONVOYEUR OFF"
#
s_compteur_piece	: "G950 ;COMPTEUR PIECE"
#
# Remise à ZERO de la valeur du A/B pour éviter les déroulés d'axes
s_reset_AB			: "M31 (REMISE A ZERO AXE A-B)"		# HURCO M31

s_rot_plus_court_ON	: "M126 ; Rotation au plus court ON" 
s_rot_plus_court_OFF: "M127 ; Rotation au plus court OFF" 
# --------------------------------------------------------------------------

[STARTBIN]
#property of FICAM, Eric Dauvilliers, e.dauvilliers@ficam.com, +33 (0)2 37 26 28 10
scustpost_revision    : "25.3107" #:= Revision number for use by Resellers or customers.

#aide PPs
#if prmcode$ = 20005, perc_prof = rpar(sparameter$, 1)  #affecte la valeur de la ligne NCI 20005 - colonne 1 A  la variable "perc_prof"
#nextdc$ --> retourne la valeur du prochain type de perCage de 0 A  ....
	
#region autres switches
#infos communes AVEC LECTURE DEFINITION de la CN et SWITCH sans lecture de la DEFINITION de la CN
useaxe      		: -9999 	# -9999 = mode AUTO (DEF MACHINE) -- (utiliser l'axe A/B 1=oui 0=non)
sens_A_B        	: 1     	# pour inverser les calculs de l'axe A/B -1
diviseur    		: -1    	# diviseur tourne autour de X=1-->A autour de Y=2-->B // DEF MACHINE=-1

# ZONE de FORMULES  si : uniquement au dédut si = constante
no$            	= 0
yes$ 			: 1

#cc_1013$    	: 1     # pour connaitre cc dans l'appel d'outil
nobrk$         	: no$   # ne pas dEcomposer en xy puis z les mouvements en rapide
opcode$        	: 1
ncldr$         	: 20    # nbr de zero de queue utilisEs pour la fonction "fleader"
ldrcode$       	: 65
ltol$          	: 0.05
#tlchng_aft$    : 2     # Delay the tool change call until the first motion is read on all the NCI Gcode 1000, 1001, 1002 tool changes.
get_1004$       : 1     # Find gcode 1004 with getnextop?
cant_tlchng$   	: 1     # Ignorer entrée de texte programmé au changement avec tlchng_aft?
rpd_typ_v7$     : 0     # Use Version 7 style contour flags?
strtool_v7$    	: 2     # autorise la lecture des commentaires de la bibiotheque outil
skp_lead_flgs$  : 0 	# Do NOT use v9 style contour flags
getnextop$     	: 1     # Access to nextop, nextccomp, nextdc
no_updprv$  	: no$   # no$ = utilise / yes$ = non(message) 
spaces$        	: 1

texte 			= 1   	# Autorise les commentaires texte

#----------fichier-prog
sextnc$     	: "h"   		# extension des fichiers nc
progname$      	: 1
#----------Sous-prog
sub_level$  	: 2     		# Enable automatic subprogram support
subprg$        	: yes$
mergesub$      	: no$
extprg$ 		: 1				#'extprg$' doit Etre à  1 pour (remplacer/écraser) 
								#ou 2 (ajouter au fichier existant) pour ouvrir un fichier auxiliaire.
sextext$ 		: ".ext"
spathext$ 		= spathnc$
sextsub$ 		: ".sub"
spathsub$ 		= spathnc$
sextaux$ 		: ".aux"
spathaux$ 		= spathnc$

# POUR INFOS
type_test_bris_outils   : 0 # test de bris outil --> mi5$
								# 0 = non 
								# 1 = ecriture en cycle "TCH PROBE 481", 
								# 2 = appel sous programme qui est dans "sbris_outil" a configurer plus bas
								# 3 = "TCH PROB 586"
Test_bris_outils		: 0	# Valeur depuis 	--> mi6$
								# 1 = A la fin de chaque outil  --> ptlchg 
								#     A chaque opération --> ptlchg0 								

#endregion

#region REGLAGE_DEBUG
Mode_reglage_PP 	= 1        	# 1= affiche toutes les valeurs pour info
affiche_prmcodes 	= 1     	# 1= Affiche les prmcode$

# ----------------------------- Restrictions
# 1=actif    0=inactif
num_clEe_DEALER	: 104632		# Sergio = 104632	--> débloque toutes les restrictions
#
restric_version_MC    	: 0     # 0/1	1=actif    0=inactif
restric_version_num    	: 21    # 21=2019    22=2020
restric_num_clEe    	: 0     # 0/1	1=actif    0=inactif
num_clEe_client        	: 0     # numEro de la clEe atribuEe
#
restric_durEe        	: 0     # 0/1	1=actif    0=inactif
jour_                	: 23    # jour limite
mois_                	: 10    # mois limite
annEe_                	: 19    # annEe limite --> 20= 2020
#
#region Historique_modifs_versions
# -   DESCRIPTION DES MODIFICATIONS  
# Cycle d'ébavurage à la brosse
# Avances en DEG/mn en substitution et 4axes continus
# Palettes sur A/B
# 24/04/25	- Gestion du M0 entre 2 OPs avec la rotation de broche et lub
#endregion
#endregion

#region formats
# - FORMATS DES VARIABLES
# --------------------------------------------------------------------------
# Format statements - n=non modale, l=leading(devant), t=trailing(derriEre), i=inc, d=delta
# --------------------------------------------------------------------------
fs  1   +1.3     	# signe "+", Decimal, absolute, 2/3 place
fs  2   +1.3n    	# signe "+", Decimal, absolute, 2/3 place, NON MODALE
fs  3   1 0      	# 1 chiffre mini avant virgule, pas de virgule, pas de chiffre apres
fs  4   1 0n     	# 1 chiffre mini avant virgule, pas de virgule, pas de chiffre apres --> non modale
fs  5   +1.4n
fs  6   1.3ln		# 1 chiffre avant la vigule met . 3 chiffres apres la virgule non modal force 0 de tete
fs  7   +1.3ln		# signe "+", 1 chiffre avant la vigule met . 3 chiffres apres la virgule non modal force 0 de tete
fs  8   0.1n
fs  9   1.3n
fs  10  2 0ln
fs  11  1.3     	# 1 chiffre avant virgule met . 3 chiffres après la virgule
fs  12  1 3ln
fs  13  1.3l		# force 1 chiffre avant virgule met . 3 chiffres après la virgule si besoin
fs  14  +1.0     
fs  15  +1,9l    
fs  16  +1 0     
fs  17  +1%3li   	# force 1 chiffre avant virgule met . 3 chiffres apres virgule en incremental
fs  18  +1%3lni
fs  19  1^3n     	# pour la liste outil
fs  20  1^3l
fs  21  1.5ln
fs  22  +1^4ln
fs  23  1%3ln
fs  24  0.3n  		#Decimal, absolute, 3 place
fs  25  1.9l 
#endregion

#region fmt AFFECTATIONS_FORMATS
fmt      4 	Mode_reglage_PP
fmt      4 	affiche_prmcodes
fmt      4 	lire_def_machine
fmt      4 	Cycles_palpage_YN
fmt      4 	info_corr     	# flag pour correction outil
fmt      4 	info_surep    	# flag pour surep
fmt "R"  4  result
#brut
# --------------------------------------------------------------------------
fmt     	3  stck_crnr$  #Origin corner of stock (0 - 8)
fmt "X" 	2  stck_x$     #X origin of block
fmt "Y" 	2  stck_y$     #Y origin of block
fmt "Z" 	2  stck_z$     #Z origin of block
fmt "LX" 	2  stck_ht$    #X - Stock Height
fmt "LY" 	2  stck_wdth$  #Y - Stock Width
fmt "LZ" 	2  stck_thck$  #Z - Stock Thickness
fmt "X" 	2  stck_x_min  #Minimum stock block position (X)
fmt "Y" 	2  stck_y_min  #Minimum stock block position (Y)
fmt "Z" 	2  stck_z_min  #Minimum stock block position (Z)
fmt "X" 	2  stck_x_max  #Maximum stock block position (X)
fmt "Y" 	2  stck_y_max  #Maximum stock block position (Y)
fmt "Z" 	2  stck_z_max  #Maximum stock block position (Z)

fmt  "DIST"	2  bottomz      		#Bottom of stock
fmt  "L"  	2  topz         		#Top of stock
fmt  ""   	2  stck_ll_x    		#Stock lower left corner X value
fmt  ""   	2  stck_ll_y    		#Stock lower left corner Y value
fmt  ""   	2  stck_ur_x   			#Stock upper right corner X value
fmt  ""   	2  stck_ur_y    		#Stock upper right corner Y value
fmt  "R"  	2  stck_cyl_dia 		#Stock diameter for Cylindrical stock
fmt  "R0"	2  stck_cyl_dia_inter 	#Stock diameter for Cylindrical stock
# --------------------------------------------------------------------------
fmt  "X" 	2 xr$
fmt  "Y" 	2 yr$
fmt  "Z" 	2 zr$
fmt  "X" 	1 x$
fmt  "Y" 	1 y$
fmt  "Z" 	1 z$
fmt  "X" 	2 i$
fmt  "Y" 	2 j$
fmt  "Z" 	2 k$
fmt  "R" 	1 arcrad$
fmt  "X" 	1 xc$
fmt  "Y" 	1 yc$
fmt  "R" 	3 rayon        # valeur de rayon de l'arc pour N
fmt "OX"    13 old_tox4
fmt "OY"    13 old_toy4
fmt "OZ"    13 old_toz4
fmt "X"     13 tox4$
fmt "Y"     13 toy4$
fmt "Z"     13 toz4$
fmt "X"     13 tox4_
fmt "Y"     13 toy4_
fmt "Z"     13 toz4_

fmt  "IPA"  5 sweep$
fmt  "IPA"  5 old_sweep
fmt      	4 n$
fmt         4 gcode$
fmt  "opcode: "   4 opcode$
fmt         4 coolant$
fmt         4 lubrif
#outils
fmt         4 t$
fmt         4 next_tool$
fmt  "Q"    4 next_tool_      	
fmt         2 nom_outil     	
fmt  "D"    6 tldia$
fmt     	3 type_comp     	# type de correction
fmt "DR" 	2 DR           		# decalage de rayon de fraise pour correction usure
fmt      	2 Type_Comp_OP	
fmt         4 outils_param      
fmt         4 Type_infos_outil
fmt         4 Type_appel_outil
fmt         4 outil_paramT1     
fmt  "Q"    4 outil_paramT2     
fmt      	4 deg_debut
fmt      	4 deg_outil
fmt      	4 deg_4_axes
fmt      	4 deg_fin
fmt      	4 deg_inspection_plaq
fmt  "X"    3 degageX
fmt  "Y"    3 degageY
fmt  "Z"    3 degageZ
fmt  "X"    3 degageX_fin
fmt  "Y"    3 degageY_fin
fmt  "Z"    3 degageZ_fin
fmt  "X"    3 degageX4
fmt  "Y"    3 degageY4
fmt  "Z"    3 degageZ4
fmt  "X"    3 degageX_pal
fmt  "Y"    3 degageY_pal
fmt  "Z"    3 degageZ_pal
fmt  "X"    3 deg_insp_X
fmt  "Y"    3 deg_insp_Y
fmt  "Z"    3 deg_insp_Z
fmt  "X"    3 old_degageX
fmt  "Y"    3 old_degageY
fmt  "Z"    3 old_degageZ
fmt  "X"    3 old_degageX4
fmt  "Y"    3 old_degageY4
fmt  "Z"    3 old_degageZ4
fmt      	4 deg_apres_outil
fmt         4 deg_palette_deb_fin
fmt			4 old_type_deg	
fmt         4 old_t
fmt			4 output_z
fmt			4 program_stop
fmt			4 Position_info_outil
fmt			4 utilise_palette
fmt			4 type_prep_outil
fmt			4 decharge_outil_fin
fmt			4 S_maxi_renvoi_angle
# en plus pour lecture du fichier INI
fmt			4 Systeme_rot_plans   
fmt			4 rot_AB_un_sens
#fmt			16 Types_Temps_DLL_INI
fmt			4 Liste_outils
fmt			4 Nom_porte_outil_entete
fmt			4 affiche_num_op_MC
fmt			4 affiche_type_op_MC
fmt			4 old_affiche_type_op_MC
fmt			4 groupe_descripteur
fmt			4 nom_programmeur_PC
fmt			4 type_dec_4x_percage
fmt			4 block_form
fmt			4 convoyeur
fmt			4 compteur_pieces
#donnees de coupe
fmt  "F"    3 fr$
fmt  "F"    3 fr_pos$
fmt  "S"    4 ss$
fmt  "S"    4 ssa
fmt   	    4 posi_p_prof 			
fmt         4 old_ssa
fmt  "G"    4 cc$
fmt  ""     4 old_cc
#perCages
fmt  "Z"    2 depth$
fmt  "Z"    2 refht$
fmt         13 dwell$
fmt  "Z"    2 initht$
fmt  "Y"    2 initht_h
fmt  "G"    4 peckclr$
fmt         2 peck1$
fmt  "F"    4 frplunge$
fmt  "Q"    2 peck2$
fmt         2 passe
fmt         2 pas
fmt         4 perc_prof     
fmt    		4 drill_4_axes		#percage 5axes O/N
fmt         4 affichage_cycle   # perCage 5x

#variables pour les cycles de percages
fmt  "Q200 = " 	7 bq200
fmt  "Q201 = " 	7 bq201
fmt  "Q202 = " 	7 bq202
fmt  "Q203 = " 	7 bq203
fmt  "Q204 = " 	7 bq204
fmt  "Q205 = " 	7 bq205
fmt  "Q206 = " 	4 bq206
fmt  "Q208 = " 	4 bq208
fmt  "Q210 = " 	6 bq210
fmt  "Q211 = " 	6 bq211
fmt  "Q212 = " 	7 bq212
fmt  "Q213 = " 	7 bq213
fmt  "Q239 = " 11 bq239
fmt  "Q214 = " 	6 bq214
fmt  "Q256 = " 	7 bq256
fmt  "Q257 = " 	7 bq257
fmt  "Q334 = " 	7 bq334
fmt  "Q335 = " 	7 bq335
fmt  "Q336 = " 	7 bq336
fmt  "Q342 = " 	7 bq342

fmt  "Q260 = " 	7 bq260  
fmt  "Q261 = " 	7 bq261  
fmt  "Q262 = " 	7 bq262  
fmt  "Q263 = " 	7 bq263  
fmt  "Q264 = " 	7 bq264  
fmt  "Q294 = " 	7 bq294  
fmt  "Q301 = " 	7 bq301  
fmt  "Q321 = " 	7 bq321  
fmt  "Q322 = " 	7 bq322  
fmt  "Q323 = " 	7 bq323  
fmt  "Q324 = " 	7 bq324  
fmt  "Q333 = " 	7 bq333  
fmt  "Q311 = " 	2 bq311
fmt         	7 old_bq203
fmt         	7 old_bq203_5x
fmt         	7 old_bq204
fmt  "prof_perc_abs_5x"		7 prof_perc_abs_5x   
fmt            	7 drl_prm3$ 
fmt            	7 drl_prm4$ 
fmt            	7 drl_prm5$ 
fmt            	9 drl_prm6$ 
fmt            	9 drl_prm7$ 
fmt            	4 drl_prm8$ 
fmt            	9 drl_prm9$ 
fmt            	9 drl_prm10$ 
fmt         	7 x_pt_zero 
fmt         	7 y_pt_zero
fmt         	7 z_pt_zero
fmt "X"			2 x1   
fmt "Y"			2 y2   
fmt     		7 old_bq201
fmt "F" 		9 f_p_profond   
fmt "Z" 		2 z_dep_p_prof  
fmt     		2 drlcst7   

fmt "Z" 		2 tosz$    

#Sous-programmes
fmt  "LBL "         4 sub_prg_no$       # Numéro de sous-programe
fmt  "CALL LBL "    4 sub_op_id$        # appell sous-programe
fmt                 4 sub_sec_no$       # numero de passe de sous prog
fmt                 4 sub_totl_no$      # nombre total de passes
fmt "inc" 			1 incremental     	# mode incremental ou Absolue
fmt     			1 memo_incremental  # memeo du mode incremental ou Absolue
fmt     			1 inc_degage        # degagement machine en INCREMENTAL ou en ABSOLUE
fmt "O" 			6 debsousprog      	# Numéro du premier sous programe
fmt "CALL LBL " 	4 subprognum       	# numero du sous-programe pour l'appel
fmt "LBL " 			4 numsubprog       	# Numéro entete de sous-programe
fmt     			5 nomsubprog        # Numéro entete de sous-programe
fmt "DEC" 			2 decalage       	# flag pour savoir si on a ecrit un G52
fmt  "X" 			4 xrp
fmt  "Y" 			4 yrp
fmt  "Z" 			4 zrp
fmt 				5 end_sub_mny 
fmt  "X" 			4 sub_trnsx$
fmt  "Y" 			4 sub_trnsy$
fmt  "Z" 			4 sub_trnsz$
fmt 				4 Rot_ABS_SP
fmt 				4 Rot_INC_SP
fmt     		4 old_sub_trnstyp 
old_sub_trnstyp : -1
#
fmt         3 entete_             
fmt         3 entete_questions
fmt         2 change_nom 
fmt 		2 affiche_groupe 	      
fmt " "     2 mi4$
fmt  	    4 mi1$
fmt  	    4 mi1_prmcode       
fmt			4 old_mi1           
fmt         1 texte         	# flag pour textes
fmt         4 liste_textes
fmt     	4 old_comm_cnt  	# nombre d'enregistrement dans buffeur commentaires
fmt         3 affiche_ori_entete

#compteurs ops
fmt         4 increment_op_outil                     
fmt         4 old_op_id
fmt         4 old_op

# Axes A/B
fmt 		4 use_axeA
fmt  "S"    2 sens_A_B          # pour inverser le sens de l'axe
fmt  ""    	2 axeA             	# POSITION pour rotation plateau en ABS
fmt  "B"    2 axeB             	# POSITION pour rotation plateau en ABS
fmt  "A"   	11 axeAi           	# POSITION pour rotation plateau en INCREMENTAL
fmt  "D"    2 rotdia$       	# diam de sbstitution
fmt  ""    	2 axeAB_subs        # rotation pour continue substitutuion en ABS
fmt  "A"   	11 A_posi          	# rotation pour continue substitutuion en INCREMENTAL
fmt  "Z"    1 zdev             	# Z pour continue substitution
fmt  "Z"   	11 zdevi
fmt  "R"    2 rotaxis$
fmt         2 old_rotaxis
fmt  "A"    2 old_axeA      	# memo de l ancien A
fmt  "old_A" 2 memo_old_axeA    # memo du memo de l ancien A
fmt  "AM" 	2 memo_AB_subs		# Memo du A/B du plan pour Ajout/soustraire
fmt  "Sens" 2 sensA
fmt  "A"    2 epsi
fmt  "Ntour" 2 nbrtour      	# nombre de tour realise
fmt  "u"    1 u$
fmt  "v"    1 v$
fmt  "w"    1 w$
fmt "old_w" 1 old_w_
fmt  "vx"   1 vx
fmt  "vy"   1 vy
fmt  "vz"   1 vz
fmt  "VEC"  1 longvec
fmt  "VX2:" 1 vx2
fmt  "VY2:" 1 vy2
fmt  "VZ2:" 1 vz2
fmt  "Z"    13 zinitht
fmt  "X"    2 xp
fmt  "Y"    2 yp
fmt  "Z"    2 zp
fmt  "A"    1 axeA_cont
fmt  "A"    1 axeA1
fmt  "A"    1 axeA2
fmt  "X"    2 new_x
fmt  "Y"    2 new_y
fmt  "Z"    2 new_z
fmt  "A"    1 delta_axeA1
fmt  "A"    1 axeA1_dep
fmt  "A"   	11 axeA1_depi
fmt  "A"    1 old_axeA1
fmt         1 debutpmx      	# flag debut prog pmx
fmt         1 bloque        	# pour gestion M10 M11
fmt         1 utilise_bloque    # pour gestion M10 M11
fmt  "Z"    2 zr_
#---------------------------------------------------
fmt  "X"    2 xabs         # XYZ en Absolue pour NC
fmt  "Y"    2 yabs
fmt  "Z"    2 zabs
fmt  "Z" 	2 zabs_deb_fin_secu_p_5x
fmt  "IX"  11 xinc        # XYZ en incremental pour NC
fmt  "IY"  11 yinc
fmt  "IZ"  11 zinc
fmt "px"    2 old_x        # ancien XYZ du NC
fmt "py"    2 old_y
fmt "pz"    2 old_z
fmt "pXC"   2 old_xc       # ancien XC/YC/ZC du NC
fmt "pYC"   2 old_yc
fmt "pZC"   2 old_zc

# Cycle def 7 (décallages d'origine); avec plan C/U cocher décallage...
fmt    		3 workofs$
fmt    		3 workofs_
fmt    		4 workofs_pwrtt 
fmt    		3 old_workofs
fmt    		3 compteur_workofs
fmt    		4 workofs_dec
fmt    		4 workofs_pwrtt_aff 
#
fmt 		4 Val_origine_Z
fmt 		4 Val_origine_Y
fmt 		4 Val_origine_X
fmt 		4 Old_Val_origine_Z
fmt 		4 Old_Val_origine_Y
fmt 		4 Old_Val_origine_X
fmt 		2 pas_filetage        
# MINI/MAXI USINAGEs-------------------------------
fmt  "X" 	2 x_tmin           # Total x_min
fmt  "X" 	2 x_tmax           # Total x_max
fmt  "Y" 	2 y_tmin           # Total y_min
fmt  "Y" 	2 y_tmax           # Total y_max
fmt  "Z" 	2 z_tmin           # Total z_min
fmt  "Z" 	2 z_tmax           # Total z_max
fmt  "Z" 	2 min_depth        # Tool z_min
fmt  "Z" 	2 max_depth        # Tool z_max
#-------------------------------------------------------
fmt   		2 long_smanu
fmt   		1 debut         # flag pour debut de programme
# PARAMETRES, surep
fmt "SUREP. XY 2D = " 	11 surep_XY_2D  
fmt                 	11 old_surep_XY_2D  		
fmt "SUREP. Z 2D = "  	11 surep_Z_2D	
fmt                 	11 old_surep_Z_2D
fmt "SUREP. Z SURF = "  11 surep_Z_surf_2D 
fmt                 	11 old_surep_Z_surf_2D   	
fmt "SUREP. XY 3D = " 	11 surep_XY_3D	
fmt                 	11 old_surep_XY_3D 
fmt "SUREP. Z 3D = "  	11 surep_Z_3D 		
fmt                 	11 old_surep_Z_3D
# Parametres de DEF MACHINE-------------------------------
fmt    1 type_composant     # type de composant
fmt    1 compt_axes_rot     # compteur d'axes rotatif
fmt    3 erreur             # numero d'erreur
fmt    3 testerreur4        # flag pour erreur 4
fmt    1 diviseur           # Axe de l'axe rotatif
fmt    1 old_syncaxis       # memo du numero de combinaison d'axes
fmt    1 nbr_combi          # Nombre de combinaison d'axes
fmt    1 palette            # flag pour machine avec palette
fmt    1 fmaxi              # avance maxi de la machine
fmt    1 fmini              # avance mini de la machine
fmt    1 nbr_outil          # nombre d'outils maxi
# Axes Pwrtt$ --> lecture avant traitement parcours
fmt    1 rotation_axe
fmt    1 rotation_A
fmt    1 rotation_B

fmt   	 2 Angle_PLAN_MC_renvoie_angle
fmt      2 old_Angle_PLAN_MC_renvoie_angle
fmt   	 2 ANGLE_XY_renvoie_angle 
fmt   	 2 ANGLE_Z_renvoie_angle
fmt  	 4 type_renvoie_angle
fmt  "X" 2 decX         			# decalage d'origine en X pour G52
fmt  "Y" 2 decY         			# decalage d'origine en Y pour G52
fmt  "Z" 2 decZ         			# decalage d'origine en Z pour G52
fmt  	 4 renvoi_d_angle
fmt  	 4 ra_block$				# NUM. du BLOCK
fmt  	 4 sauve_ra_block_
fmt  	 4 ra_tc_type$				# type changement, auto, fixe, manuel
fmt  	 4 sauve_ra_tc_type_	
fmt  	 3 ra_rot_head$				# Rotation ou pas NCI line 1029/11	val-->11	0=fixe 1=rotatif
fmt  	 4 ra_type$					# type de bloc
fmt 	 3 lg_port_out_outil_block	# longueur du porte outil avec l'outil
fmt      4 prepa_out_renvoi
fmt 	 4 posi_nom_programmeur

fmt 	 4 old_usecandrill
fmt 	 4 old_usecanpeck
fmt 	 4 old_usecanchip
fmt 	 4 old_usecantap
fmt 	 4 old_usecanbore1
fmt 	 4 old_usecanbore2
fmt 	 4 old_usecanmisc1
fmt 	 4 old_usecanmisc2

fmt 	 4 usecanDRILL
fmt 	 4 usecanPECK
fmt 	 4 usecanCHIP

fmt 	 4 perc_1er_perc_pour_C_ou_mm
fmt 	 2 perc_Val_pour_Cent_mm
fmt 	 2 perc_AVANCE_pour_Cent_mm
fmt 	 2 P_er_perc_0
fmt 	 2 P_er_perc_1
fmt "Z"	 2 P_er_perc_2
fmt 	 2 angle_foret
#endregion

#region debug_tolerances
#--------------------------------------------------------------------------------------------------------
#   DEBUG POST PRO
fastmode$  		: yes$  # YES/NO    IDEM LIGNE DU DESSOUS
#fastmode$ 		: 0     # mode execution rapide du pst 0 pour utiliser les bug 1 2 3
bug1$   		: 1     # 1 = Output post to screen - 2 = output leader to screen
bug2$   		: 60    # Add postline label to each line at column 'bug2'
bug4$   		: no$   # Add nci no
whatno$ 		: yes$  # Ignore whatline branches to plin1 etc.?
newglobal$      : 0 	# Activer la vérification d'erreur pour les variables globales?
#--------------------------------------------------------------------------------------------------------
linktolvar$    	: 1         # Associer les variables de tolérance X aux variables V9-
linkplnvar$    	: 1         # Associer les variables spécifiques plan X aux variables V9-?
linklvar$      	: 1         # Associer les variables spécifiques X Tournage aux variables V9-
#endregion

#region valeurs_initiales
axeA1_dep     	: -999999
axeA          	: 999
nbrtour     	: 0
old_axeA     	: 0

z_min$     		: 999
z_tmin     		: 999
z_max$     		: -999
z_tmax     		: -999

m7$       		: 999
m8$       		: 999
longTexte     	: 0        
old_lubrif     	: -1
old_coolantx 	: -1
increment_op_outil 	: 1
debut_out     	: 1       # pour forcer l'affichage des avances après l'appel de l'outil.
#axes pwrtt$
rotation_axe 	: -9999
rotation_A     	: -9999
rotation_B     	: -9999
write_ops    	: 0     #Write NC operation information (True/False)

Z_dir        	: 0     #Z Axis direction flag
axis_label   	: 0     #Axis label - 1=X,2=Y,3=Z
rot_zero 		: 0    	#Rotary zero degree position
rot_dir			: 0  	#Rotary direction
rot_index    	: 0 	#Index or continuous
rot_angle    	: 0 	#Index step
rot_type     	: 0		#Rotary type
min_speed    	: 50 	#Minimum spindle speed
maxfrinv_m   	: 0		#Maximum feedrate - inverse time - metric - Minimum value from MD as this is inverse time
maxfrdeg     	: 0		#Maximum feedrate deg/min
maxfeedpm_m  	: 0		#Limit for feed in mm/min
palette 		: 0

spdir2        	: 1     #Copy for safe spindle direction calculation

#Sous-prog
incremental 	: 0     # init en Absolue
decalage 		: 0
sav_absinc   	: 0     # Absolute/Incremental Saved Value
mr_rt_actv   	: 0     #Flag to indicate if G51/G68 is active
                     	#0=Off, 1=Toolchange, 2=Subprogram call/start, G68
                     	#3=Absolute start, both
end_sub_mny  	: 0     #Many tool setting captured at transform sub end
# WORKPIECE variables - used to define the stock for Siemens graphics / simulation on control
stock_cyl_axis 	: -1    #Stock cylinder axis 0=X,1=Y,2=Z
stock_shape    	: -1    #Stock shape from toolpath group parameters. 0=Rectangular/Box, 1=Cylinder

srot_label 		: ""  	#Rotary Axis label (Generally A, B or C) - Not yet available.
s_axe_brut_cyl	: ""	#Axe du brut cylindrique

#temps
fr_rapid_mach   : 12000 # Machine Rapid feedrate
tlchg_time  	: 0  	# Tool Change Time (Minutes) OK VALEUR DANS LA CN

old_sweep 		: 0 
helice 			: 0

#temps DLL
fmt    			1 last_op_id_pwrtt 	# Derniere operation
fmt 			2 timeTT
fmt 			2 timeOp
fmt 			25 Heure	"H "
fmt 			25 min		"M "
fmt 			25 sec		"S "
fmt             4 Affiche_temps_dll
fmt "time_OP :" 	15 Tot_time_op 	# Total operation time
fmt "total_time :"  15 time_total	# Total time programme
fmt "OPs_time :"  	15 time_OPs		# Time operations
fmt    				4 Time_hrs      # Time in hours
fmt    				4 Time_min      # Time in minutes
fmt    				4 Time_sec      # Time in seconds
fmt    				8 F_USI_prmcode # Feedrate
fmt "time_OUT :"    15 Tot_time_Out
fmt 				15 nbr_correct_XY_G0_time
fmt 				15 correc_dwell_time
fmt					4 Nbr_outils
fmt					4 Temps_chang_outil
fmt             	4 info_temps
fmt             	4 prof_temps
fmt             	4 div_prof_temps
sdllTimeOp 			: ""
sOpId 				: ""
stimeTT 			: ""
reste 				: 0
sNcPath 			: ""
last_op_id_pwrtt 	: 0
Types_Temps_DLL  	: -1	# Temps depuis la DLL
Types_Temps_DLL_1  	: -1
Nbr_outils 			: 0
time_correction_op	: 0

ori_1 : 0
ori_2 : 0
ori_3 : 0
ori_4 : 0
ori_5 : 0
ori_6 : 0
ori_7 : 0
ori_8 : 0
ori_9 : 0	

old_cc 		: -1
old_t 		: -9999

#Définir les opérations à inclure dans la catégorie Perçage
OP_percage =				# 0 ou 1
      (
      tool_op$ = 2   |  # Drill
      tool_op$ = 28  |  # 5-axis drilling
      tool_op$ = 37  |  # Non-associative drilling
      tool_op$ = 104 |  # Solid drill control operation
      tool_op$ = 136 |  # FBM drill control operation
      tool_op$ = 306    # Block drill
      )
#endregion

#region affectations_calculs
xinc        = xabs
yinc        = yabs
zinc        = zabs
axeA1_depi 	= axeA1_dep
zdev 		= z$ +(rotdia$ /2)
zdevi 		= zdev
A_posi 		= axeAB_subs      # A incremental
#endregion

#region Buffer
# --------------------------------------------------------------------------
# Buffer 5 - Min / Max
# --------------------------------------------------------------------------
b5_gcode : 0
b5_zmin  : 0
b5_zmax  : 0
rc5     : 2
wc5     : 1
size5   : 0

fbuf 5 0 3 0 0          #Min / Max
# --------------------------------------------------------------------------
#endregion

#region strings
s_m0            		: "M0" 
Sold_snom_RUD   		: ""       	
snom_RUD        		: ""
sguillemet      		: ""  		
sinfo_origine   		: "" 
snomgroupe_op 			: ""   		# STRING du nom du groupe d'opération
snomgroupe_op_old 		: ""   		# STRING de l'ancien nom du groupe d'opération
s_nom_machine_entete	: ""   		# STRING du nom de la machine ****VALEUR DANS MC****       
spalette        		: "PALETTE" # STRING du nom de la palette
s_axe_rot_label 		: ""        # Nom de l'axe rotatif (ABC)
s_axe_rot_A     		: "A"
s_axe_rot_B     		: "B"
scomentsprog 			: ""    	# STRING du commentaire pour le titre du sous prog
s_CC 					: "CC"
s_CR 					: "CR"
s_CP 					: "CP"
sguillemet 				= no2asc(34) 
s_old_spost_arg_2		: ""
s_old_sinfo_origine 	: ""
s_nom_ORDI				: ""
s_nom_ORDI2				: ""
s_nom_programmeur		: ""
s_slash					: "\"
#endregion

#region questions_NOUVEAU_ANCIEN
#region NOUVEAU
# QUESTIONS ENTETE ----------------------------------------------------
svide2 : ""
# A modifier si besoin
s_com_open 	: ";"   # Caractere de DEBUT de commentaire
s_com_close : ""    # Caractere de FIN de commentaire

s_question_1 : s_texte_question_1
s_question_2 : s_texte_question_2
s_question_3 : s_texte_question_3
s_question_4 : s_texte_question_4
s_question_5 : s_texte_question_5
s_question_6 : s_texte_question_6
s_question_7 : s_texte_question_7
s_question_8 : s_texte_question_8
s_question_9 : s_texte_question_9
s_question_10 : s_texte_question_10
s_question_11 : s_texte_question_11
s_question_12 : s_texte_question_12
s_question_13 : s_texte_question_13
s_question_14 : s_texte_question_14
s_question_15 : s_texte_question_15
s_question_16 : s_texte_question_16
s_question_17 : s_texte_question_17
s_question_18 : s_texte_question_18
s_question_19 : s_texte_question_19
s_question_20 : s_texte_question_20

#----
fq 1 s_question_1 "//s_texte_question_1//"
fq 2 s_question_2 "//s_texte_question_2//"
fq 3 s_question_3 "//s_texte_question_3//"
fq 4 s_question_4 "//s_texte_question_4//"
fq 5 s_question_5 "//s_texte_question_5//"
fq 6 s_question_6 "//s_texte_question_6//"
fq 7 s_question_7 "//s_texte_question_7//"
fq 8 s_question_8 "//s_texte_question_8//"
fq 9 s_question_9 "//s_texte_question_9//"
fq 10 s_question_10 "//s_texte_question_10//"
fq 11 s_question_11 "//s_texte_question_11//"
fq 12 s_question_12 "//s_texte_question_12//"
fq 13 s_question_13 "//s_texte_question_13//"
fq 14 s_question_14 "//s_texte_question_14//"
fq 15 s_question_15 "//s_texte_question_15//"
fq 16 s_question_16 "//s_texte_question_16//"
fq 17 s_question_17 "//s_texte_question_17//"
fq 18 s_question_18 "//s_texte_question_18//"
fq 19 s_question_19 "//s_texte_question_19//"
fq 20 s_question_20 "//s_texte_question_20//"
# Nombre de questions jusqu'a  25 maxi

# ICI Questions avec valeurs numériques
fmt 2 Var_1_question
#
fmt 4 Var_16_question
fmt 4 Var_17_question
Var_1_question : 1
Var_20_question : 1
#...

p_questions_entete
    # A enrichir si besoin --> apres Q13
    if s_texte_question_1 <> svide2, q1
    if s_texte_question_2 <> svide2, q2
    if s_texte_question_3 <> svide2, q3
    if s_texte_question_4 <> svide2, q4
    if s_texte_question_5 <> svide2, q5
    if s_texte_question_6 <> svide2, q6
    if s_texte_question_7 <> svide2, q7
    if s_texte_question_8 <> svide2, q8
    if s_texte_question_9 <> svide2, q9
    if s_texte_question_10 <> svide2, q10
    if s_texte_question_11 <> svide2, q11
    if s_texte_question_12 <> svide2, q12
    if s_texte_question_13 <> svide2, q13
	#
	if palette = 1, if s_texte_question_16 <> svide2, q16
    if palette = 1, if s_texte_question_17 <> svide2, q17

    s_question_1 = ucase(s_question_1)
    s_question_2 = ucase(s_question_2)
    s_question_3 = ucase(s_question_3)
    s_question_4 = ucase(s_question_4)
    s_question_5 = ucase(s_question_5)
    s_question_6 = ucase(s_question_6)
    s_question_7 = ucase(s_question_7)
    s_question_8 = ucase(s_question_8)
    s_question_9 = ucase(s_question_9)
    s_question_10 = ucase(s_question_10)
    s_question_11 = ucase(s_question_11)
    s_question_12 = ucase(s_question_12)
    s_question_13 = ucase(s_question_13)
	#
	if palette = 1, s_question_16 = ucase(s_question_16)
    if palette = 1, s_question_17 = ucase(s_question_17)

    # Pour toute string a convertir en valeur numerique --> faire la meme chose pour d'autres si besoin
    Var_1_question = rpar(s_question_20, 1)    # convertir la valeur texte en valeur numerique
	Var_16_question = rpar(s_question_16, 1)
	Var_17_question = rpar(s_question_17, 1)
    schange_nom_fichier = s_question_20    # dans le "Pbloc" --> "pnom_nc" peut-etre modifier le nom de la string --> test si fichier existant

    spathnc$ = ucase(spathnc$)
    stck_matl$ = ucase(stck_matl$)
    snamenc$ = ucase(snamenc$)

    spaces$ = 0
    #s_com_open, "DATE LE ", date$," A ", time$, s_com_close, e$
    #s_com_open, "DESSIN MASTERCAM - ", smcname$, s_com_close, e$
    #s_com_open, "NC FILE - ", *spathnc$, *snamenc$, *sextnc$, s_com_close, e$
    #s_com_open, "MATIERE - ", *stck_matl$, s_com_close, e$
    #s_com_open, "NOM DU PROGRAMME - ", sprogname$, s_com_close, e$
    #n$, " ", e$
    spaces$ = 1
    if s_texte_question_1 <> s_question_1, n$, s_com_open, s_texte_question_1, "-", s_question_1, s_com_close, e$, longTexte = 1
    if s_texte_question_2 <> s_question_2, n$, s_com_open, s_texte_question_2, "-", s_question_2, s_com_close, e$, longTexte = 1
    if s_texte_question_3 <> s_question_3, n$, s_com_open, s_texte_question_3, "-", s_question_3, s_com_close, e$, longTexte = 1
    if s_texte_question_4 <> s_question_4, n$, s_com_open, s_texte_question_4, "-", s_question_4, s_com_close, e$, longTexte = 1
    if s_texte_question_5 <> s_question_5, n$, s_com_open, s_texte_question_5, "-", s_question_5, s_com_close, e$, longTexte = 1
    if s_texte_question_6 <> s_question_6, n$, s_com_open, s_texte_question_6, "-", s_question_6, s_com_close, e$, longTexte = 1
    if s_texte_question_7 <> s_question_7, n$, s_com_open, s_texte_question_7, "-", s_question_7, s_com_close, e$, longTexte = 1
    if s_texte_question_8 <> s_question_8, n$, s_com_open, s_texte_question_8, "-", s_question_8, s_com_close, e$, longTexte = 1
    if s_texte_question_9 <> s_question_9, n$, s_com_open, s_texte_question_9, "-", s_question_9, s_com_close, e$, longTexte = 1
    if s_texte_question_10 <> s_question_10, n$, s_com_open, s_texte_question_10, "-", s_question_10, s_com_close, e$, longTexte = 1
    if s_texte_question_11 <> s_question_11, n$, s_com_open, s_texte_question_11, "-", s_question_11, s_com_close, e$, longTexte = 1
    if s_texte_question_12 <> s_question_12, n$, s_com_open, s_texte_question_12, "-", s_question_12, s_com_close, e$, longTexte = 1
    if s_texte_question_13 <> s_question_13, n$, s_com_open, s_texte_question_13, "-", s_question_13, s_com_close, e$, longTexte = 1
    #n$, s_com_open, "*****************************", s_com_close, e$

#endregion
#region ANCIEN-QUESTIONS
#  ----------QUESTIONS------------------
spiece 		: ""
snumplan 	: ""
sindiceplan : ""
squi 		: ""
sclient 	: ""
sorx 		: ""
sory		: ""
sorz 		: ""
sor_A_B 	: ""
sorc 		: ""
remplace 	: 1
use_axeA 	: 0

fmt 2 remplace

# convertir textes en MAJUSCULES
sclient = ucase(sclient)
spiece = ucase(spiece)
snumplan = ucase(snumplan)
sindiceplan = ucase(sindiceplan)
sorx = ucase(sorx)
sory = ucase(sory)
sorz = ucase(sorz)
sor_A_B = ucase(sor_A_B)

#fq 1 spiece "Nom de la piece"
#fq 2 snumplan "Numero du plan"
#fq 3 squi "Nom du programmeur"
#fq 4 sclient "Nom du client"
#fq 5 sorx "Origine en X"
#fq 6 sory "Origine en Y"
#fq 7 sorz "Origine en Z"
#fq 8 sor_A_B "Origine en A"
#fq 9 sorc "Origine en C"
#fq 10 schange_nom_fichier "Numéro de programme //snouv_nom// existant, ENTREZ UN NOUVEAU NUMERO"# progno
#fq 11 remplace "Numéro de programme //snouv_nom// existant, LE REMPLACER ?      0 pour NON - 1 pour OUI" 
#fq 12 use_axeA "UTILISER L'AXE A (0=NON 1=OUI)"
#fq 13 sindiceplan "Indice du plan"
#fq 14 useaxe "(pour OP modif) UTILISER L'AXE A ?  0 pour NON 1 pour OUI"
#fq 15 vtol$    "TOLERANCE CORDALE POUR DEVELOPPE"    #plus utilisé

p_entete_questions_3
	q4, q1, q2, q13, q5, q6, q7   #,q8,q9
    n$," ; PAR : xxxxx ", e$
    n$," ; CLIENT  :", sclient, e$
    n$," ; PIECE   :", spiece, e$
    n$," ; NUMERO  :", snumplan, e$
    n$," ; INDICE PLAN  :", sindiceplan, e$
    n$," ; ORIGINE :", e$
    n$," ; X :", sorx, e$
    n$," ; Y :", sory, e$
    n$," ; Z :", sorz, e$
	n$," ; A_B :", sor_A_B, e$
    n$," ; ORIENTATION PIECE", e$
    n$," ;                               ", e$
    n$," ; *****************************", e$
    n$," ;                               ", e$
#endregion
#endregion

#region codes_M
#-------------------------------------------------------
sg00    : "FMAX"
sg01    : "L"
sg02    : "DR-"
sg03    : "DR+"
sgcode 	: ""
fstrsel  sg00 gcode$ sgcode 4 -1
#-------------------------------------------------------
drillref    : 0     #Select drill reference
# Reference dEpart de perCages
sg98    : " "     #Reference INIT/SECU
sg99    : " "     #Reference DEPART
sgdrlref : ""
fstrsel sg98 drillref sgdrlref 2 -1
#-------------------------------------------------------
# Table de l'affichage du type de correction
stc0       	: "CORREC. AUCUNE "
stc1       	: "CORREC. ARMOIRE D. "
stc2       	: "CORREC. ARMOIRE G. "
stc3       	: "CORREC. ORDI. D. "
stc4       	: "CORREC. ORDI. G. "
stc5       	: "CORREC. USURE D. "
stc6       	: "CORREC. USURE G. "
stc7       	: "CORREC. USURE INVERSE D. "
stc8       	: "CORREC. USURE INVERSE G. "
stc9		: "CORREC. ORDI. 3D "		
stype_comp 	: ""
fstrsel  stc0 type_comp stype_comp 10 -1
#-------------------------------------------------------
#endregion

#region commentaires
sm0 		: "M0"
sm0_2 		: "M00"
fmt	4 affiche_m0
affiche_m0 : -1

pcomment$   # pour gcode = 1005-1008
    pcomment2

#pcomment_end$  # post traitement des commentaires
    #if entete = 1, comm_cnt$ = old_comm_cnt            # pour pouvoir relire les commentaires apres appel de comment dans pheader

pcomment2
    scomm$ = ucase(scomm$)
    if debut = 1 & groupe_descripteur > 0, pcomment3
	if entete_ = 0, [
        if gcode$ = 1005, n$, s_com_open, scomm$, e$    						# FONCTION MACHINE avec numéro de ligne
        if entete_ = 0 & gcode$ = 1006, [										# Usinage commentaire - FONCTION CN AVEC NUM. BLOC       
			if scomm$ = sm0 | scomm$ = sm0_2 & affiche_m0 = 1, 
				[
				n$, scomm$, e$ 
				n$, *spdlon, *ssa, e$
    			old_lubrif = -1
				n$, *scoolantx, e$
				affiche_m0 = 0
				]
			else, n$, scomm$, e$
			]		
		if gcode$ = 1007, n$, s_com_open, scomm$ 								# avec numéro de ligne
        #if gcode$ = 1008, scomentsprog = scomm$ 
		if gcode$ = 1008, n$, s_com_open, scomm$, s_com_close, e$  				#Operation comment using MSG("") *op_number,         
        #if gcode$ = 1008 & affiche_num_op_MC = 2, n$, s_com_open, *op_number, scomm$, s_com_close, e$  	# Operation comment using MSG("")
		if gcode$ = 1026, scomm$												# Entrée manuelle - code avec mouvement - pas de "e$"
		]	
    if entete_questions = 1 & entete_ = 1 & gcode$ = 1006 & scomm$ <> svide, ptextentete    # pour informer l'entete prog.
    #if entete_ = 1 & gcode = 1008 & scomm, n$, "MSG(", 34, scomm, 34, ")"  				# sur la ligne "TEXTE DU RUD"
														
pcomment3   # Affichage des commentaires d'entete de prog /GROUPES/DESCRIPTEUR
    scomm$ = ucase (scomm$)
    if gcode$ = 1051 & (groupe_descripteur = 1 | groupe_descripteur = 5), n$, s_com_open, "MACHINE :", scomm$, s_com_close, e$    	# Nom Machine	--> DEJA DANS LE DEBUT
	if gcode$ = 1052 & (groupe_descripteur = 2 | groupe_descripteur = 5), n$, s_com_open, scomm$, s_com_close, e$  					# Commentaire de groupe Machine
    if gcode$ = 1053 & (groupe_descripteur = 3 | groupe_descripteur = 5), n$, s_com_open, "GROUPE :", scomm$, s_com_close, e$  		# Nom du Groupe PRINCIPAL Machine	    
    if gcode$ = 1054 & (groupe_descripteur = 4 | groupe_descripteur = 5), n$, s_com_open, scomm$, s_com_close, e$     				# Descripteur de fichier
    old_comm_cnt = comm_cnt$

pnomgroupe  # Affichage du nom du groupe d'operation
    if affiche_groupe = 1,	[
        if snomgroupe_op <> svide & snomgroupe_op <> snomgroupe_op_old,
            [
            n$, s_com_open, "*", snomgroupe_op, "*", s_com_close, e$       		# nom du groupe d'operation
            snomgroupe_op_old = snomgroupe_op                   				# memo du nom du groupe d'operation
            ]
        ]
#endregion

#region avances_variables
#--------- avance variable -------------------
fmt  "FQ" 3 frQ
fmt  "Q50=" 16  varq50  #AVANCE PLONGEE
fmt  "Q51=" 7   varq51  #AVANCE TRAVAIL
fmt  "oldQ" 16  old_q50
fmt  "oldQ" 7   old_q51
fmt  "oldQ" 7   old_q52
fmt  "PRVZ" 2 	prvz
fmt  "PRVZ" 2 	prvz_pzr
fmt     	7   F_variables
fmt  "F" 	14  F_plongee
fmt  "F" 	3   F_micro_remontee 
fmt  "F" 	3   F_G1_ugv_3D  
fmt  "F" 	3   F_G1_ugv_2D 
fmt  "F" 	3   F_retract  
fmt     	4   debut_out   

pfr  
    #motst$ ="type de mouvement" 1=X 2=Y 3=X&Y 4=Z 5=X&Z 6=Y&Z 7=XY&Z
    #tool_op <> 2 pas au perçage
    #tool_op$ <> 102 pas au surfaçage
    #F_variables = 0 POUR LES QUESTIONS "fq1"
    #fr$ = -1 lorsque la valeur n'est pas différente
	@frQ
	if rotaxis$ <> 0 | nextop$ = 11, p_avances_avec_rot_A_B # SUBSTITUTION D'AXES --> EN DEGRES
	else, [
	    #"  ", *F_variables, *fr$, *nextop$, *mi4$, *tool_op$
	    if (F_variables = 1) & (nextop$ <> 11) & (mi4$ = 0) & (OP_percage <> 1) & (tool_op$ <> 102), [       
	        if fr$ <> -1, [	                        
				if fr_pos$ = F_plongee, frQ = 50, *frQ
				if (fr_pos$ = F_USI_prmcode) & (F_USI_prmcode <> F_plongee), frQ = 51, *frQ	
				if fr_pos$ <> F_plongee & fr_pos$ <> F_USI_prmcode, *fr_pos$ 
				#if fr_pos$ = F_G1_ugv_3D, F_G1_ugv_3D
				#if fr_pos$ = F_G1_ugv_2D, F_G1_ugv_2D
				#if fr_pos$ = F_retract, F_retract
				#if (fr_pos$ = F_micro_remontee) & ((F_G1_ugv_3D <> F_micro_remontee) | (F_G1_ugv_2D <> F_micro_remontee)), F_micro_remontee
	            ]
	        ]
	    if F_variables = 1 & tool_op$ = 102 & fr$ <> -1 & (mi4$ = 0), fr$ = 51, frQ = fr$, *frQ	# surfaçage
	    if fr_pos$ >= 0 & (nextop$ = 11 | mi4$ <> 0), fr_pos$  					# pas de FRQ -- OP 5 AXES
	    if F_variables = 0 & fr_pos$ <> -1, fr_pos$                				# pas de FRQ	  			
	    debut_out = 0
		]   
    p_erreur_avanceS    
    # gestion de l'avance entre 2 passes en surfaçage prmcode = 10116 avec tool_op = 102

pfrvar   # ecriture des avances variables
    if F_variables = 1 & nextop$ <> 11 & mi4$ = 0 & (OP_percage <> 1) & rotaxis$ = 0, [
        varq51 = fr$
        if opcode$ = 4 | opcode$ = 13 | opcode$ = 14, varq50 = F_plongee, else, varq50 = varq51  #fr$/sqrt(tldia$*2) OPs de poches = avance MC
        @varq50,@varq51,@old_q50,@old_q51
		varq50 = F_plongee
        if debut_out = 1, [
			n$, *varq50, "; AVANCE PLONGEE", e$
            n$, *varq51, "; AVANCE TRAVAIL", e$
            ]
         if debut_out = 0, [       
			if old_q50 <> varq50, n$, *varq50, "; AVANCE PLONGEE", e$
            if old_q51 <> varq51, n$, *varq51, "; AVANCE TRAVAIL", e$
            ]
        old_q50 = varq50
        old_q51 = varq51
        #debut_out = 0 
        ]
#endregion

#region Avances en "DEG/Minutes"
fmt "D"     2 deltaXYZ
fmt "Dx"    2 Delta_F_X
fmt "Dy"    2 Delta_F_Y
fmt "Dz"    2 Delta_F_Z
fmt         2 old_F_X
fmt         2 old_F_Y
fmt         2 old_F_Z
fmt "F"     11 fr_deg_inv
fmt         11 old_fr
fmt "DA"    2 Delta_Angle
fmt "A"     2 delta_A_sub
fmt ""      2 circum	
fmt         2 ldelta
fmt         2 cldelta
fmt         2 cdelta
fmt  "F" 	11 avance  
#Feedrate calculation variables
frdelta      : 0     #Calculation for deg/min
frinv        : 0     #Feedrate inverse time
frdeg        : 0     #Feedrate deg/min actual
prvfrdeg     : 0     #Feedrate deg/min actual
ldelta       : 0     #Calculation for deg/min, linear
cldelta      : 0     #Calculation for deg/min, linear and rotary
     	
p_avances_avec_rot_A_B
    # calculs en "DEG/Minutes"
    spaces$ = 1
    if rotaxis$ <> 0,    # SUBSTITUTION X/Y
        [
        #"1111", *memo_AB_subs, *epsi, *old_axeA, "delta_A_sub", *delta_A_sub, e$
		Delta_Angle = delta_A_sub
		#circum = sqrt(Delta_F_X) * 2 * pi$
        circum = zabs * 2 * pi$			# Calcul du périmètre
        if circum = 0, circum = 9999
		ldelta = sqrt((xabs-prv_xabs)^2+(yabs-prv_yabs)^2+(zabs-prv_zabs)^2)
        cdelta = Delta_Angle
        if ldelta = 0, cldelta = cdelta
        else, cldelta = sqrt(cdelta^2 + ldelta^2)
        if cldelta = 0, cldelta = 9999
        Delta_F_Z = 0			
        if rotaxis$ = -2 | rotaxis$ = 2,    # ROTATION SUR X SUBSTITUTION DE Y
            [          
            Delta_F_X = x$ - old_F_X
            Delta_F_Y = ((2*pi$*zabs)/360) * Delta_Angle
            if Delta_F_X > 0, deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y)
            else, deltaXYZ = Delta_F_Y 
            old_F_X = x$
            ]
        if rotaxis$ = -1 | rotaxis$ = 1,    # ROTATION SUR Y SUBSTITUTION DE X
            [			
            Delta_F_Y = y$ - old_F_Y
            Delta_F_X = ((2*pi$*zabs)/360) * Delta_Angle
            if Delta_F_Y > 0, deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y)
            else, deltaXYZ = Delta_F_X          		
            old_F_Y = y$
            ]
		#"uuu", *ldelta, *deltaXYZ, *Delta_Angle
              #Delta_Angle = ((abs(cabs - prvcabs))/360)*circum
        ]
    if nextop$ = 11,                       # si  4 axes avec fonction 5 axes
        [
        #"2222", *epsi, *old_axeA, *delta_axeA1
        Delta_Angle = abs(epsi)
        Delta_F_X = y$ - old_F_X
        Delta_F_Y = y$ - old_F_Y
        Delta_F_Z = y$ - old_F_Z
        deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y + Delta_F_Z * Delta_F_Z)
        Delta_Angle = sqrt(Delta_Angle^2 + deltaXYZ^2)
        circum = sqrt(deltaXYZ) * 2 * pi$
        old_F_X = x$
        old_F_Y = y$
        old_F_Z = z$
        ]
    #"Delta_Angle", *Delta_Angle, " deltaXYZ:", *ldelta, *deltaXYZ, "lcircum", *circum
	@Delta_Angle
    if Delta_Angle > 0 | (nextop$ = 11 & epsi > 0),
        [
        #" ", *Delta_F_Y, *zabs, *rotaxis$, e$
        #deltaXYZ = sqrt(Delta_F_X * Delta_F_X + Delta_F_Y * Delta_F_Y + Delta_F_Z * Delta_F_Z)
        ##fr_deg_inv = abs(cdelta/cldelta) * abs(fr_pos$ * (360/circum))
        fr_deg_inv = abs(Delta_Angle/deltaXYZ) * abs(fr_pos$ * (360/circum))
        if abs(fr_deg_inv - prvfrdeg) > 10, prvfrdeg = fr_deg_inv
        if fmtrnd(fr_deg_inv) = 0, fr_deg_inv = fr_pos$
        if fr_deg_inv > 2000, fr_deg_inv = 2000
        if fr_deg_inv < 50, fr_deg_inv = 50
        fr_deg_inv = round(fr_deg_inv)
        #if inversefeed$, [  #Feedrate in seconds --> DEPUIS DEF MACHINE (valeurs très petites)
            #fr_deg_inv = (fr_pos$*(1/60))/cldelta
            #]
        ]
	# Avance sans rotation --> pas de calculs
	if Delta_Angle = 0, avance = fr_pos$, *avance  
    if rotaxis$ <> 0 & Delta_Angle > 0, [
        #if Delta_Angle > 0 & (Delta_F_X > 0 | Delta_F_Y > 0 | Delta_F_Z > 0) & fr_deg_inv < 10000, fr_deg_inv
        #else, avance = fr_pos$, if avance <> old_fr, avance
        if Delta_Angle > 0 & (Delta_F_X > 0 | Delta_F_Y > 0 | Delta_F_Z > 0) & fr_deg_inv < 10000, if fr_deg_inv <> prv_fr_deg_inv, *fr_deg_inv
        Delta_Angle = 0
        Delta_F_X = 0
        Delta_F_Y = 0
        Delta_F_Z = 0
        ]
    if nextop$ = 11,                       # si  4 axes avec fonction 5 axes
        [
        #"3333", *Delta_Angle, *epsi, *Delta_F_X, *Delta_F_Y, *Delta_F_Z, *old_fr#*fr_deg_inv
        if epsi = 0, avance = fr_pos$, avance
        if epsi > 0 & fr_deg_inv < 10000, fr_deg_inv, old_fr = -9999        # & (Delta_F_X <> 0 | Delta_F_Y <> 0 | Delta_F_Z <> 0)
		]
#endregion

#region restrictions
#strings
s_coordonnees           : "VEUILLEZ CONTACTER LA SOCIETE FICAM M. Dauvilliers Eric, e.dauvilliers@ficam.com, +33 (0)2 37 26 28 10"
s_erreur_version_MC     : "Ce POST-PROCESSEUR NE PEUT ETRE UTILISE AVEC CETTE VERSION DE MASTERCAM "
s_limite_utilisation    : "ATTENTION **CE POST-PRO n'est valide que jusqu'au :" 
s_erreur_num_clee       : "VOTRE NUMERO DE CLEE NE PERMET PAS D'UTILISER CE POST-PROCESSEUR, VEUILLEZ CONTACTER "
s_annEe                 : ""

#pour calculs
Val_annEe_limite		: 0
Val_mois_limite			: 0
Val_Jour_limite			: 0
Val_year_				: 0
Val_month_				: 0
Val_day_				: 0

#formats
fmt     	4    restric_version_MC    	# 0/1
fmt     	4    restric_num_clEe    	# 0/1
fmt     	4    restric_durEe        	# 0/1
fmt "-"    	4    jour_                	# jour limite
fmt "-"    	4    mois_                	# mois limite
fmt "-"    	4    annEe_                	# annEe limite
fmt     	4    num_clEe_client

p_restriction_PP
    if sim_no$ <> num_clEe_DEALER,   # CLEE autorisEe
        [
        #restriction VERSION MASTERCAM
        if restric_version_MC = 1, [    #pour info 21 = version MC2019
            if vers_no$ <> restric_version_num, [
                result = mprint(vers_no$)
                result = mprint(restric_version_num)
                result = mprint(s_erreur_version_MC)
                result = mprint(s_coordonnees)
                exitpost$
                ]
            ]
        #restriction en durEe
        #year$ --> 20= 2020
        if restric_durEe = 1,    [
            # "VOIR: ", *year$, *annEe_, *month$, *mois_, *day$, *jour_, e$
			# calcul en jours "du jour ACTUEL"
			Val_year_ = year$ * 100
			Val_month_ = month$ * 30
			Val_day_ = Val_year_ + Val_month_ + day$ # totaux en jours du jour actuel
			# calcul en jours "du jour LIMITE"
			Val_annEe_limite = annEe_	* 100
			Val_mois_limite	= mois_ * 30
			Val_Jour_limite = Val_annEe_limite + Val_mois_limite + jour_ 	
					  
            if Val_day_ > Val_Jour_limite, [                     	
                result = mprint(s_limite_utilisation)
                result = mprint(jour_)
                result = mprint(mois_)
                annEe_ = annEe_ + 2000
                result = mprint(annEe_)
                result = mprint(s_coordonnees)
                exitpost$
                ]			
            ]
        #restriction en numero de clEe
        #sim_type$
        if sim_no$ = num_clEe_DEALER, ex$   # CLEE autorisEe
        if sim_no$ <> num_clEe_client & restric_num_clEe = 1, [
            result = mprint(s_erreur_num_clee)
            result = mprint(s_coordonnees)
            exitpost$
            ]
        ]
#endregion

#region pprep_ lecture def armoire et traitememt au debut
pprep$      # bloc init post pro en remplacement de la def armoire
    rd_mch_ent_no$ = -1     		# forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    rd_cd$                  		# lecture de la definition armoire
    rd_md$                  		# lecture de la definition machine
	rd_tlpathgrp$      				# Lecture des éléments dans "param_read$. outils- BRUT" 
    if write_ops = 0, erreur = 1   	# Write NC Operation information MUST be enabled in CD
	arctype$ = 5
    !erreur
    !serreur
    if erreur <> 0, [
        result = mprint(serreur, 2)
        exitpost$
        ]
    # bloc init post-pro en remplacement de la def armoire
    #pdebug
	if lire_def_machine = 0, p_force_config_pp, p_cycles_valides
	smcpath$ = ucase (smcpath$)
    smcname$ = ucase (smcname$)
    smcext$ = ucase(smcext$)
    snamepst$ = ucase (snamepst$)
	snamenc$ = ucase (snamenc$)
	
p_cycles_valides	#pour réactivation après renvoie d'angle		
	#   UTILISER LES CYCLES MACHINE ou DECOMPOSITION en G1 G0
	# ATTENTION !!!!! PRENDS LE DESSSUS SUR LA DEFINITION DE L'ARMOIRE
	usecandrill$ = yes$   	# utiliser cycle percage lamage
	usecanpeck$  = yes$   	# utiliser cycle debourrage
	usecanchip$  = yes$   	# utiliser cycle brise copeaux
	usecantap$   = yes$   	# utiliser cycle taraudage
	usecanbore1$ = yes$   	# utiliser cycle alesage a l'alesoir
	usecanbore2$ = yes$   	# utiliser cycle alesage a la barre
	usecanmisc1$ = yes$		# utiliser cycle divers 1
	usecanmisc2$ = yes$    	# utiliser cycle divers 2
	
pdebug
    err_file$ = 4
    bug2$ = 60
    fastmode$ =0    #1 = Affiche les erreurs du pst dans un fichier .err

psynclath$      #Read NCI Axis-Combination (950) line
	#if lire_def_machine = 1, p_lire_axes    # axes valeur de la def_machine
	p_lire_axes   #Set rotary switches by reading machine def parameters
	#Rotaxtyp = 1 sets initial matrix to top
	#Rotaxtyp = -2 sets initial matrix to front
	#rotaxtyp$ = 4 donne les valeurs XYZ par rapport au RUD utilisé QUEL QUE SOIT LE PLAN
	#                    XYZ A plat
	#                    XZY EN FACE...
	#if vmc, rotaxtyp$ = one
	#else, rotaxtyp$ = -2

p_force_config_pp
    #REGLAGE ARCS
    # The following three initializations are used for full arc and helix arc output when the CD
    # is set to output R or signed R for arcs
	# 1 = CC(Centre du Cercle, valeurs en ABSOLU) ou 5 = CR(Rayon du Cercle)
    arctype$     	= 1    #Arc center type XY plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé
    arctypexz$   	= 1    #Arc center type XZ plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé
    arctypeyz$   	= 1    #Arc center type YZ plane 1=abs(IJ), 2=St-Ctr, 3=Ctr-St, 4=unsigned inc., 5=rayon, 6=rayon non signé

    breakarcs$  	= 1    # Break arcs, 0 = no, 1 = quadrants, 2 = 180deg. max arcs
    do_full_arc$ 	= 0    # Allow full circle output? 0=no, 1=yes; 1 POUR LE FILETAGE A LA FRAISE (SUR 360DEG)
    helix_arc$   	= 1    # Support helix arc output, 0=no, 1=all planes, 2=XY plane only
    arccheck$       = 1

    #Blocs
    seqmax$        	= 99999
    omitseq$       	= no$    # no$ = forcer la numerotation des blocs de 10 en 10	yes$ = pas de numérotation
#endregion

#region lubrifications
sav_coolant  	: 0 # Coolant saved
sav_coolant_on 	: 0 # XCoolant saved
# --------------------------------------------------------------------------
# Define coolant binary value for X style coolant
flktbl  2       20      #Lookup table definition - table no. - no. entries
        1       50      #Coolant 1 on value
        2       51      #Coolant 1 off value
        4       52      #Coolant 2 on value
        8       53      #Coolant 2 off value
        16      54      #Coolant 3 on value
        32      55      #Coolant 3 off value
        64      56      #Coolant 4 on value
        128     57      #Coolant 4 off value
        256     58      #Coolant 5 on value
        512     59      #Coolant 5 off value
        1024    60      #Coolant 6 on value
        2048    61      #Coolant 6 off value
        4096    62      #Coolant 7 on value
        8192    63      #Coolant 7 off value
        16384   64      #Coolant 8 on value
        32768   65      #Coolant 8 off value
        65536   66      #Coolant 9 on value
        131072  67      #Coolant 9 off value
        262144  68      #Coolant 10 on value
        524288  69      #Coolant 10 off value

#Lubrification Classique et VX
p_lubrif_ON
    lubrif = coolant$
    if v9_coolant & tool_op$ <> 114, 	[
        if lubrif > 0,	[
            #if old_lubrif = 0, "M8"
            if lubrif = 1 & old_lubrif <> 1, coolantx = 0, *scoolantx
			if lubrif = 2 & old_lubrif <> 2, coolantx = 2, *scoolantx
            if lubrif = 3 & old_lubrif <> 3, coolantx = 4, *scoolantx
			old_lubrif = lubrif
            ]
        else, if old_lubrif = -1, scool50, lubrif = 1, old_lubrif = 1  #FORCE M08 si pas de lubrif d'actif
        ]  
	if v9_coolant = 0, pcan1_cool #X style coolant

pinsp_cool_on   # LUBRIFICATION APRES l' "INSPECTION OUTIL"
      coolant_on = sav_coolant_on
      if v9_coolant, [coolant$ = sav_coolant], e$
      if coolant_on,
        [
        local_int = zero
        coolantx = zero
        while local_int < 20 & coolant_on > 0,
          [
          coolantx = and(2^local_int, coolant_on)
          local_int = local_int + one
          if coolantx > zero,
            [
            coolantx = local_int - one
            p_bloc_O, n$, *scoolantx, e$ #X style coolant on after tool inspection
            ]
          coolantx = zero
          ]
        ]
	
p_lubrif_OFF
    #if lubrif_complex_on = 1 | tool_op$ = 114, p_lubrif_OFF_VX   # on arrete tout les arrosages
    if v9_coolant & tool_op$ <> 114,     [
		if old_lubrif = 1, coolantx = 1, n$, scoolantx, e$
        if old_lubrif = 2, coolantx = 3, n$, scoolantx, e$
		if old_lubrif = 3, coolantx = 5, n$, scoolantx, e$
        old_lubrif = 0
        ]
	if v9_coolant = 0, pcool_off

pcool_off  #All Coolant off
      sav_coolant = coolant$ #Save V9 coolant
      sav_coolant_on = coolant_on #Save X coolant
      coolant$ = zero
#      if nextop$ = 1003, #Uncomment this line to leave coolant on until eof unless
        [                 #  explicitely turned off through a canned text edit
        if all_cool_off, [
          #all coolant off with a single off code here
          if coolant_on, p_bloc_O, n$, sall_cool_off, e$
          coolant_on = zero
          ]
        else, [
          local_int = zero
          coolantx = zero
          while local_int < 20 & coolant_on > 0, [
            coolantx = and(2^local_int, coolant_on)
            local_int = local_int + one
            if coolantx > zero, [
              coolantx = local_int
              p_bloc_O, n$, scoolantx, e$
              ]
            coolantx = zero
            ]
          coolant_on = zero
          ]
        ]
#endregion

#region Motion output components
# --------------------------------------------------------------------------
# Motion output components
# --------------------------------------------------------------------------
bloc_O         : 0     	#Block delete active

p_bloc_O            	#Canned text - bloc OPTIONNEL
      if bloc_O, '/'

p_f_bloc_O           	#Force - le bloc OPTIONNEL
      "/"
#endregion

#region Textes_et_arrosages
#Define Constants
m_one        = -1
zero         = 0
one          = 1
two          = 2
three        = 3
four         = 4
five         = 5
c9k          = 9999

#Coolant variables for X style coolant
cant_pos     : 0     #Read from current canned text (cant_pos1 - cant_pos20)
coolant_bin  : 0     #Binary value for current coolant command
coolant_on   : 0     #Binary value holding the sum of all coolants currently on
coolantx     : 0     #Selector variable for coolant string selector
local_int    : 0     #Local variable for output of coolant off commands
result2      : 0     #Return value for functions
suppress     : 0     #Flag used to suppress redundant coolant on commands
all_cool_off : 0     #SET_BY_MD - First coolant off command shuts off ALL coolant options
v9_coolant   : 0     #SET_BY_MD - Use V9 coolant options - read from General Machine Parameters

# --------------------------------------------------------------------------
#String and string selector definitions for NC output
# --------------------------------------------------------------------------
#Address string definitions
strm         : "M"
strn         : "N"
stro         : "O"
strp         : "P"
srad         : "R"
srminus      : "R-"
sblank       : ""

#Cantext string definitions (spaces must be padded here)
sm00         : "STOP M0"
sm01         : "M01"	
strtextno    : ""
strcantext   : ""


# --------------------------------------------------------------------------
# Insertion des Textes / ARROSAGES
# --------------------------------------------------------------------------
pcan            #Insertion des Textes - LIGNE D'AVANT 
      strcantext = sblank
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "PCAN : ", *cant_no$, e$
		if cant_pos1$ = zero | cant_pos1$ = three, pcant_1
        if cant_pos2$ = zero | cant_pos2$ = three, pcant_2
        if cant_pos3$ = zero | cant_pos3$ = three, pcant_3
        if cant_pos4$ = zero | cant_pos4$ = three, pcant_4
        if cant_pos5$ = zero | cant_pos5$ = three, pcant_5
        if cant_pos6$ = zero | cant_pos6$ = three, pcant_6
        if cant_pos7$ = zero | cant_pos7$ = three, pcant_7
        if cant_pos8$ = zero | cant_pos8$ = three, pcant_8
        if cant_pos9$ = zero | cant_pos9$ = three, pcant_9
        if cant_pos10$ = zero | cant_pos10$ = three, pcant_10
        if cant_pos11$ = zero | cant_pos11$ = three, pcant_11
        if cant_pos12$ = zero | cant_pos12$ = three, pcant_12
        if cant_pos13$ = zero | cant_pos13$ = three, pcant_13
        if cant_pos14$ = zero | cant_pos14$ = three, pcant_14
        if cant_pos15$ = zero | cant_pos15$ = three, pcant_15
        if cant_pos16$ = zero | cant_pos16$ = three, pcant_16
        if cant_pos17$ = zero | cant_pos17$ = three, pcant_17
        if cant_pos18$ = zero | cant_pos18$ = three, pcant_18
        if cant_pos19$ = zero | cant_pos19$ = three, pcant_19
        if cant_pos20$ = zero | cant_pos20$ = three, pcant_20
		if strcantext <> sblank, p_bloc_O, n$, strcantext, e$
        strcantext = sblank
        ]

pcan1           #Insertion des Textes - AVEC LA LIGNE 
      strcantext = sblank
      if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "PCAN1 1: " *cant_no$, ": ",
		if cant_pos1$  = one, pcant_1
        if cant_pos2$  = one, pcant_2
        if cant_pos3$  = one, pcant_3
        if cant_pos4$  = one, pcant_4
        if cant_pos5$  = one, pcant_5
        if cant_pos6$  = one, pcant_6
        if cant_pos7$  = one, pcant_7
        if cant_pos8$  = one, pcant_8
        if cant_pos9$  = one, pcant_9
        if cant_pos10$ = one, pcant_10
        if cant_pos11$ = one, pcant_11
        if cant_pos12$ = one, pcant_12
        if cant_pos13$ = one, pcant_13
        if cant_pos14$ = one, pcant_14
        if cant_pos15$ = one, pcant_15
        if cant_pos16$ = one, pcant_16
        if cant_pos17$ = one, pcant_17
        if cant_pos18$ = one, pcant_18
        if cant_pos19$ = one, pcant_19
        if cant_pos20$ = one, pcant_20
		]
	  if cstop$, strcantext = strcantext + sm00
      if cgstop$, strcantext = strcantext + sm01
      #Output of strcantext occurs at the end of the output line

pcan1_cool      #Insertion des Textes AVEC l'ARROSAGE - ***SUR LA LIGNE***
	  if cant_no$ > zero,
        [
        if Mode_reglage_PP = 0, "pcan1_cool : ", *cant_no$, *cant_pos1$, "--", *cantext$, *tool_op$,    
		if cant_pos1$  = four, pcant_1
        if cant_pos2$  = four, pcant_2
        if cant_pos3$  = four, pcant_3
        if cant_pos4$  = four, pcant_4
        if cant_pos5$  = four, pcant_5
        if cant_pos6$  = four, pcant_6
        if cant_pos7$  = four, pcant_7
        if cant_pos8$  = four, pcant_8
        if cant_pos9$  = four, pcant_9
        if cant_pos10$ = four, pcant_10
        if cant_pos11$ = four, pcant_11
        if cant_pos12$ = four, pcant_12
        if cant_pos13$ = four, pcant_13
        if cant_pos14$ = four, pcant_14
        if cant_pos15$ = four, pcant_15
        if cant_pos16$ = four, pcant_16
        if cant_pos17$ = four, pcant_17
        if cant_pos18$ = four, pcant_18
        if cant_pos19$ = four, pcant_19
        if cant_pos20$ = four, pcant_20
        ]
		
pcan2           #Insertion des Textes - APRES LA LIGNE
      strcantext = sblank
      if cant_no$ > zero,
        [
        if cant_pos1$ = two | cant_pos1$ = five, pcant_1
        if cant_pos2$ = two | cant_pos2$ = five, pcant_2
        if cant_pos3$ = two | cant_pos3$ = five, pcant_3
        if cant_pos4$ = two | cant_pos4$ = five, pcant_4
        if cant_pos5$ = two | cant_pos5$ = five, pcant_5
        if cant_pos6$ = two | cant_pos6$ = five, pcant_6
        if cant_pos7$ = two | cant_pos7$ = five, pcant_7
        if cant_pos8$ = two | cant_pos8$ = five, pcant_8
        if cant_pos9$ = two | cant_pos9$ = five, pcant_9
        if cant_pos10$ = two | cant_pos10$ = five, pcant_10
        if cant_pos11$ = two | cant_pos11$ = five, pcant_11
        if cant_pos12$ = two | cant_pos12$ = five, pcant_12
        if cant_pos13$ = two | cant_pos13$ = five, pcant_13
        if cant_pos14$ = two | cant_pos14$ = five, pcant_14
        if cant_pos15$ = two | cant_pos15$ = five, pcant_15
        if cant_pos16$ = two | cant_pos16$ = five, pcant_16
        if cant_pos17$ = two | cant_pos17$ = five, pcant_17
        if cant_pos18$ = two | cant_pos18$ = five, pcant_18
        if cant_pos19$ = two | cant_pos19$ = five, pcant_19
        if cant_pos20$ = two | cant_pos20$ = five, pcant_20
		if Mode_reglage_PP = 0, "pcan2 ", *cant_no$, e$
        if strcantext <> sblank, p_bloc_O, n$, strcantext, e$
        strcantext = sblank
        ]

pcant_1         #Insertion du Texte
      cant_pos = cant_pos1$
      cantext$ = cant_val1$
      pcant_out

pcant_2         #Insertion du Texte
      cant_pos = cant_pos2$
      cantext$ = cant_val2$
      pcant_out

pcant_3         #Insertion du Texte
      cant_pos = cant_pos3$
      cantext$ = cant_val3$
      pcant_out

pcant_4         #Insertion du Texte
      cant_pos = cant_pos4$
      cantext$ = cant_val4$
      pcant_out

pcant_5         #Insertion du Texte
      cant_pos = cant_pos5$
      cantext$ = cant_val5$
      pcant_out

pcant_6         #Insertion du Texte
      cant_pos = cant_pos6$
      cantext$ = cant_val6$
      pcant_out

pcant_7         #Insertion du Texte
      cant_pos = cant_pos7$
      cantext$ = cant_val7$
      pcant_out

pcant_8         #Insertion du Texte
      cant_pos = cant_pos8$
      cantext$ = cant_val8$
      pcant_out

pcant_9         #Insertion du Texte
      cant_pos = cant_pos9$
      cantext$ = cant_val9$
      pcant_out

pcant_10        #Insertion du Texte
      cant_pos = cant_pos10$
      cantext$ = cant_val10$
      pcant_out

pcant_11        #Insertion du Texte
      cant_pos = cant_pos11$
      cantext$ = cant_val11$
      pcant_out

pcant_12        #Insertion du Texte
      cant_pos = cant_pos12$
      cantext$ = cant_val12$
      pcant_out

pcant_13        #Insertion du Texte
      cant_pos = cant_pos13$
      cantext$ = cant_val13$
      pcant_out

pcant_14        #Insertion du Texte
      cant_pos = cant_pos14$
      cantext$ = cant_val14$
      pcant_out

pcant_15        #Insertion du Texte
      cant_pos = cant_pos15$
      cantext$ = cant_val15$
      pcant_out

pcant_16        #Insertion du Texte
      cant_pos = cant_pos16$
      cantext$ = cant_val16$
      pcant_out

pcant_17        #Insertion du Texte
      cant_pos = cant_pos17$
      cantext$ = cant_val17$
      pcant_out

pcant_18        #Insertion du Texte
      cant_pos = cant_pos18$
      cantext$ = cant_val18$
      pcant_out

pcant_19        #Insertion du Texte
      cant_pos = cant_pos19$
      cantext$ = cant_val19$
      pcant_out

pcant_20        #Insertion du Texte
      cant_pos = cant_pos20$
      cantext$ = cant_val20$
      pcant_out

pcant_out       #Canned text - build the string for output
	#Assign string select type outputs
	if Mode_reglage_PP = 0, "cantext 1 : ", *cantext$, " : ", *cant_pos, e$
	if cant_pos < three, #cant_pos indicates canned text output
        [
        if cantext$ = three, bloc_O = one
        if cantext$ = four, bloc_O = zero
        #Build the cantext string
        if cantext$ = one, strcantext = strcantext + sm00
        if cantext$ = two, strcantext = strcantext + sm01
        if cantext$ > four, [								#-----------LISTE DE TEXTES 
		  strtextno = no2str(cantext$)	  
          #strcantext = strcantext + strm + strtextno 	 
		  liste_textes = cantext$ #strtextno	  
		  strcantext = s_liste_textes #LISTE DE TEXTES
		  #strcantext
		  #*cant_pos, "XXXX",
		  if cant_pos = 1, s_liste_textes										#AVEC
		  if cant_pos = 0 | cant_pos = 2, n$, s_liste_textes, s_com_close, e$	#AVANT et APRES
          ]
        ]
	else, #cant_pos indicates coolant output --> ARROSAGES SI cant_pos > 2
        [
		#"ici1 ", e$
		coolant_bin = flook (two, cantext$) #Create binary value for each coolant using lookup table
        if frac(cantext$/two),  # ARROSAGES **OFF** 
			[
			if all_cool_off, [
				#"ici_2", e$
				if coolant_on, p_bloc_O, n$, sall_cool_off, e$
				coolant_on = zero
				]
			else, [
				#"ici3 ", e$
				if coolant_on > 0, [
					  #"ici4 ", e$
					  coolant_on = coolant_on - coolant_bin/2 #Odd = off command, subtract appropriate binary value.
					  coolantx = cantext$ - 50                #Create a coolantx value for string select
					  p_bloc_O, n$, *scoolantx, e$
					  ]
				]
			]
		else, [                    # ARROSAGES **ON**         #Even = on command
			#Determine if this coolant is already on
			local_int = zero
			coolantx = zero
			suppress = zero
			while local_int < 20 & coolant_on > 0, [
				result2 = and(2^local_int, coolant_on)
				local_int = local_int + one
				if result2 = coolant_bin, suppress = one
				]
			if suppress <> 1, [ #Don't output an on code for a coolant that is already on
				if Mode_reglage_PP = 0, "cantext 2: ", *cantext$, e$
				#"ici4 ", e$
				coolant_on = coolant_on + coolant_bin 	#Maintain binary sum of all coolants currently on
				coolantx = cantext$ - 50              	#Create a coolantx value for string select
				if cant_pos = four, *scoolantx        	#Coolant "AVEC"
				else, p_bloc_O, n$, *scoolantx, e$  	#Coolant "AVANT" ou "APRES"
				]
			]
		]

#endregion

#region valeurs_suivant_NCI
fprmtbl   1    4
	10010   surep_XY_2D
    10068   surep_Z_2D
    12665	surep_XY_3D
    12666   surep_Z_3D
	#12068   surep_Z_surf_2D 	 

fprmtbl 19000   2    #Table Number, Size
    19133   stock_shape     #0=RECTANG. 1=CYLIND. 2=SOLIDE 3=FICHIER STL
    19135   stock_cyl_axis  #Stock cylinder axis 0=X,1=Y,2=Z
#endregion

#region Temps
p_temps_affectation
	Types_Temps_DLL_1 = plcval (s_Types_Temps_DLL, info_temps) 
	if Types_Temps_DLL_1 = 1, Types_Temps_DLL = info_temps	# pour rester dans le format 654321

p_temps_dll		#temps DLL
    if Affiche_temps_dll = 1, [	#évite également les messages si pas de DLL
		sOpId = no2str(op_id$)
	    result = dll(sdllTimeOp,sOpId)
	    timeOp = rpar(spost_arg_1$,1)
	    #timeTT = timeTT + timeOp
	    strtool$ = ucase(strtool$)
		]

p_Convert_time_dll
    # pour info "timeTT" est en secondes
	# tlchg_time = temps de changement d'outil dans la def machine
	@Types_Temps_DLL
		
	if Types_Temps_DLL > 3, [
		# / OUTIL ne pas additionner juste avant l'affichage	
		if Types_Temps_DLL <> 5, Tot_time_Out = Tot_time_Out + timeOp			
		# / TOTAL FIN 
		if Types_Temps_DLL <> 5 & Types_Temps_DLL <> 6, time_total = time_total + timeOp
		]	
	
	# NON CORRIGE EN ENTETE
	if Types_Temps_DLL < 4, [
		
		]
	
	if Types_Temps_DLL = 3, Tot_time_op = timeTT 		# / TOTAL 
	if Types_Temps_DLL = 2, Tot_time_op = Tot_time_Out	# / par OUTIL 	
	if Types_Temps_DLL = 1, Tot_time_op = timeOp		# / par OPERATION
	#
	
	# CORRIGE DANS LE CORPS
	time_correction_op = (coefficient_G0/10) * nbr_correct_XY_G0_time	# nbr de G0
	time_correction_op = time_correction_op  + correc_dwell_time		# ajout des tempos 
	#"VOIR : " *time_correction_op, e$
	if Types_Temps_DLL = 4, [							# / OP
		Tot_time_op = timeOp
		Tot_time_op = Tot_time_op + time_correction_op
		#"VOIR OP en S: ", *timeOp, e$ 
		]	
	if Types_Temps_DLL = 5, [							# / OUTIL
		Tot_time_op = Tot_time_Out + Temps_chang_outil + time_correction_op
		Tot_time_Out = 0
		#"VOIR OUTIL en S: ", *Tot_time_op, *Tot_time_Out, *Temps_chang_outil, e$  
		]
	if Types_Temps_DLL = 6, [							# / FIN					
		Temps_chang_outil = Temps_chang_outil * Nbr_outils 
		Tot_time_op = (time_total + time_correction_op) + Temps_chang_outil
		#"VOIR : ", *time_total, " ", *Tot_time_op, "Nbr de passages :", *nbr_correct_XY_G0_time, *time_correction_op, " T CH out", *Temps_chang_outil, e$
		#"VOIR TOTAL en S: ", *Tot_time_op, e$ 
		]	
		
	Time_hrs = Tot_time_op / 3600	#xx.yy
	Time_min = Time_hrs 			# --> mem
	Time_hrs = int(Time_hrs)		#xx		H
	
	Time_min = frac(Time_min)		#0.xx	M
	Time_min = Time_min * 60		#xx.yy 	M
	Time_min = int(Time_min)		#xx		M	
	
	Time_sec = Tot_time_op / 60		#yy.xx 	S
	Time_sec = frac(Time_sec)		#0.xx 	S
	Time_sec = Time_sec * 60		#xx.yy	S
	Time_sec = int(Time_sec)		#xx		S
	    	
	Heure = Time_hrs
	Heure = int(Heure)
	min = Time_min
	min = int(min)
	sec = Time_sec
	sec = int(sec)
	
p_correc_time_G0
	if drillcyc$ < 0, nbr_correct_XY_G0_time = nbr_correct_XY_G0_time + 1
	if drillcyc$ >= 0, [
		prof_temps = drl_depth_z$ - drl_sel_ref$	# Z matière -->drl_sel_tos$	# Profondeur
		prof_temps = abs(prof_temps)
		if peck1$ > 0, div_prof_temps = int(prof_temps/peck1$) 
		if peck1$ > 0, nbr_correct_XY_G0_time = nbr_correct_XY_G0_time + int(prof_temps/peck1$) 
		if dwell$ <> 0, correc_dwell_time = correc_dwell_time + (dwell$ * div_prof_temps) 	# temps en plus par profondeur de débourrage/brise-copeaux tempo
		#"VOIR :", *prof_temps, " ", *nbr_correct_XY_G0_time, " ", *correc_dwell_time, " ", *dwell$, e$
		]			
	
#endregion

#region pmachineinfo_ lecture des parametres de def armoire et def machine
# Machine Definition Parameters
fprmtbl 17000   11   #13 Table Number, Size
#   Param   Variable to load value into
	17391   axis_label   #Axis label - 1=X,2=Y,3=Z	
    17397   srot_label   #Rotary Axis label (Generally A, B or C) - Not yet available.
	17401   rot_zero     #Rotary zero degree position	
	17402   rot_dir      #Rotary direction
	17408   rot_index    #Index or continuous
    17409   rot_angle    #Index step
    17410   rot_type     #M3/M4 Rotary type	
    17605   min_speed    #50 tr/min Minimum spindle speed	
    #17066   maxfrinv_m  #Maximum feedrate - inverse time - metric - Minimum value from MD as this is inverse time
    #17933   maxfrdeg     #Maximum feedrate deg/min
	17063   maxfeedpm_m  #Limit for feed in mm/min
    17101   all_cool_off #First coolant off command shuts off ALL coolant options
    17102   v9_coolant   #Use V9 coolant option

fprmtbl 18000   2           # Lecture des Param de def armoire
    18171   write_ops       # Autoriser l'ecriture de l'information CN d'operation
    18458   texte           # Nombre de caracteres pour les commentaires
    #18713   sous_prog_type  # type de merge des sous prog (0 apres prog principal 1 avant)
    #18705   cor_arc         # compensation sur les arcs autorisee

pmachineinfo$    # lecture des parametres de def armoire et def machine
    #rd_md is used to call pmachineinfo postblock and read the parameters of the selected axis
    #combination machine entity set in rd_mch_ent_no
    #rd_cd is used to call pmachineinfo postblock and read the active control definition parameters
    #rd_tlpathgrp is used to call pmachineinfo postblock and read the active toolpath group parameters

    if affiche_prmcodes = 0, "-->pmachineinfo DONNEES MACHINE ", ~prmcode$, "=", sparameter$, e$        # pour afficher tous les parametres

    #if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$
    #if prmcode$ = 18458, "nombre de caracteres de commentaire", sparameter$, e$
    #if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$         # Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$                        # LABEL DE L'AXE
    #if prmcode$ = 17696, *prmcode$, "nom de la combinaison =", sparameter$, e$

    if prmcode$ = 17063, fmaxi = rpar(sparameter$, 1)               # avance maxi en G1
    if prmcode$ = 17062, fmini = rpar(sparameter$, 1)               # avance mini en G1
    if prmcode$ >= 17000 & prmcode$ < 18000, result = fprm(17000)   # Run the parameter table for Machine Definition Parameters
    if prmcode$ >= 18000 & prmcode$ < 19000, result = fprm(18000)   # Lecture de la table de parametre Control Definition
	if prmcode$ >= 19000 & prmcode$ < 19900, result = fprm(19000)   # Run the parameter table for Toolpath Group Parameters
    if prmcode$ = 17012, s_nom_machine_entete = sparameter$                     # Nom de la machine
    #if prmcode$ = 17201, [                                   		# nom du composant
        #if ucase(sparameter$) = spalette, palette = 1               # si c'est une palette, activer la gestion de palette
        #]
    if prmcode$ = 19958, [                                   		# type de composant pour voir si on a un axes rotatif
        type_composant = rpar(sparameter$, 1)
        if type_composant = 5,  [                                   # si c'est un axe rotatif  5 = axe rotatif
            #useaxe = 1												#--> oui mais pas forcément utilisé
            compt_axes_rot = compt_axes_rot + 1                     # compter le nombre d'axes rotatif
            ]
        ]
    # AXE DE ROTATION UTILISé --> la configuration machine doit Etre dEfinie correctement
	#Direction de l'axe Z - Vers Y = ROTATION AXE A / Vers X = ROTATION AXE B
    if prmcode$ = 17392 & axis_label = 3, [
        Z_dir = rpar(sparameter$, 1)  #Z axis direction - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
        if Z_dir <> 3 & Z_dir <> 9, #vmc = 0   #0 = Horizontal Machine, 1 = Vertical Mill
        else, #vmc = 1
        ]
	if prmcode$ = 17399,    [                                       # AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
        diviseur = rpar(sparameter$, 1)
        if diviseur > 3, diviseur = diviseur - 6                    # ne garder que x y z
        ]
    if prmcode$ = 17402,    [                                       # sens de l'axe rotatif 0=trigo 1=horaire
        sens_A_B = rpar(sparameter$, 1)
        if sens_A_B = 0, sens_A_B = 1                               # variable sens pour le post pro
        else, sens_A_B = -1
        ]
    if prmcode$ = 17598, nbr_outil = rpar(sparameter$, 1)           # nombre d'outils du changeur de la def machine
    if prmcode$ = 17932, s_axe_rot_label = sparameter$              # 17391 AXE rotatif (ABC) (NOM DE L'axe -- PAS le LABEL)	
	if prmcode$ = 17921, fr_rapid_mach = rpar(sparameter$, 1)     	# ou 17925 avance rapide de la machine     
	if prmcode$ = 17597, tlchg_time = rpar(sparameter$, 1)    		# temps de changement d'outil de la machine
		
p_lire_axes   # Lecture des parametres de la combinaison d'axes uniquement
    #"p_lire_axes", syncaxis$, e$
    if syncaxis$ <> old_syncaxis, [
        compt_axes_rot = 0
        erreur = 0
        ]
    rd_mch_ent_no$ = syncaxis$                  # pour avoir les infos de la conbinaison d'axe utilisE
    #rd_mch_ent_no$ = -2                        # forcer la lecture de toute la def machine -1 que la combinaison d'axe -2 que la base machine 0
    #rd_cd$                                     # lecture de la def armoire
    if lire_def_machine = 1, rd_md$          # lecture de la def machine
    result = nwadrs(s_axe_rot_label, axeA)      # affectation du nom de l'axe rotatif en ABS
    #s_axe_rot_label = "I" + s_axe_rot_label    # affectation du nom de l'axe rotatif en INC
    #result = nwadrs(s_axe_rot_label, axeAi)    # affectation du nom de l'axe rotatif en INC
    p_test_machine
    old_syncaxis = syncaxis$

p_test_machine    # verif de la def machine
    #*nbr_combi, "---------", e$
    if nbr_combi > 1, erreur = 3                # le pst ne supporte q'une combinaison d'axe par programme
    if compt_axes_rot > 1, erreur = 2           # le pst ne supporte q'un axe rotatif
    #if write_ops = 0, erreur = 1               # Write NC Operation information MUST be enabled in CD
    #p_erreur

p_erreur
    !erreur
    !serreur
    if erreur <> 0, [
        if erreur = 4 & testerreur4 = 0, [
            serreur2 = serreur + no2str(increment_op_outil)
            result = mprint(serreur2, 3)
            if result = 3, serreur2 , e$, exitpost$ 	# abandonner
            if result = 4, serreur2                 	# recommencer
            if result = 5, testerreur4 = 1             	# ignorer
            ]
        if erreur <> 4, [
            result = mprint(s_erreur_nbr_axes_rot, 2)
            exitpost$
            ]
        ]

p_affiche_infos_config_armoire
    #affichage des prmcode$
    if Mode_reglage_PP = 0, [
        "***INFOS DONNEES -CONFIG DE LA MACHINE-***", e$
        "fmaxi: ", *fmaxi, e$
        "fmini: ", *fmini, e$
        "smachine: ", s_nom_machine_entete, e$
        "spalette: ", spalette, e$
        "type_composant ", *type_composant, e$
        "INFOS CONFIG GROUPE MACHINE : diviseur +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9: : ", *diviseur, e$
        "sens de l'axe rotatif 0=trigo 1=horaire: ", *sens_A_B, e$
        "nbr_outil: ", *nbr_outil, e$
        "s_axe_rot_label NOM: ", s_axe_rot_label, e$
        ]
#endregion

#region pparameter_ lecture parametres d'OP
pparameter$
    #rd_params is used to call pparameter postblock and read the parameters of the operation specified in rd_param_op_no
    if affiche_prmcodes = 0, "-->pparameter DONNEES OPERATIONS ", ~prmcode$, "=", ~sparameter$, e$        # pour afficher tous les parametres

    #if prmcode$ = 15545, diviseur = rpar(sparameter$, 1)                        #"COMBINAISON D'AXE ROTATIF -ID:5999= A -ID:6002= B "
    #if prmcode$ = 18171, *prmcode$, "ecriture ops =", sparameter$, e$
    #if prmcode$ = 18458, "nombre de caracteres de commentaire",  sparameter$, e$
    #if prmcode$ = 19958, *prmcode$, "type de composant", "=", sparameter$, e$  # type de composant 5 = axe rotatif
    #if prmcode$ = 17399, *prmcode$, "AXE DE L'AXE ROTATIF", "=", sparameter$, e$   # AXE ROTATIF - +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17402, *prmcode$, "sens de laxe", "=", sparameter$, e$       # sens de l'axe rotatif 0=trigo 1=horaire
    #if prmcode$ = 17401, *prmcode$, "position 0", "=", sparameter$, e$         # Position angle 0 deg  +X=1,+Y=2,+Z=3,-X=7,-Y=8,-Z=9
    #if prmcode$ = 17398, *prmcode$, "=", sparameter$, e$
    #if prmcode$ = 17201, *prmcode$, "nom de l'element =", sparameter$, e$
	
	if prmcode$ = 10030, F_USI_prmcode = rpar(sparameter$, 1)
	if prmcode$ = 10031, F_plongee = rpar(sparameter$, 1)
	if prmcode$ = 12068, surep_Z_surf_2D  = rpar(sparameter$, 1) 
	if prmcode$ = 15140, F_retract = rpar(sparameter$, 1)
    if prmcode$ = 12718, F_G1_ugv_2D   = rpar(sparameter$, 1)
    if prmcode$ = 12194, pas_filetage = rpar(sparameter$, 1)    # "valeur du pas du filetage à la fraise"
	if prmcode$ = 12662, F_G1_ugv_3D   = rpar(sparameter$, 1)
    if prmcode$ = 15163, Val_origine_Z = rpar(sparameter$, 1)   # "valeur de l'origine MC en Z"
    if prmcode$ = 15164, Val_origine_Y = rpar(sparameter$, 1)   # "valeur de l'origine MC en Y"
    if prmcode$ = 15165, Val_origine_X = rpar(sparameter$, 1)   # "valeur de l'origine MC en X"
	if prmcode$ = 15166, workofs_ = rpar(sparameter$, 1)    	# 15166=Val origine de base 
																# 15181=Val Numéro de l'origine actif
																# 15333=Val départ incrément, op transformation 
	if prmcode$ = 15334, workofs_dec = rpar(sparameter$, 1)		# 15334=Val incrément, op transformation 
	if prmcode$ = 15190, mi1_prmcode = rpar(sparameter$, 1) 	# valeur sûr de mi1$
	if prmcode$ = 15240, op_number = rparsngl(sparameter$, 1)	# Numéro OP MC réelle
	if prmcode$ = 15346, Type_Comp_OP = rpar(sparameter$, 1)    # Type de compensation outil par OP / 0=ORDI 1=ARMOIRE 2=USURE 3=USURE inverse 4=SANS 
	if prmcode$ = 20002, smanu = sparameter$
    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)        # lecture des parametres d'outil
    if prmcode$ = 20011, sinfo_origine = sparameter$            #
    if prmcode$ = 20014, snom_RUD = sparameter$                 #
	if prmcode$ = 20018, snomgroupe_op = ucase (sparameter$)    # Lecture du nom de groupe d'usinage   
    if prmcode$ = 40270, F_micro_remontee = rpar(sparameter$, 1)#
	if prmcode$ = 15071, usecanDRILL = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGE
	if prmcode$ = 15072, usecanPECK = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGE/deb
    if prmcode$ = 15073, usecanCHIP = rpar(sparameter$, 1)		# Décomposer ou pas les cycles de PERCAGES/brise copeaux
	if prmcode$ = 15074, perc_1er_perc_pour_C_ou_mm = rpar(sparameter$, 1)	# CHOIX DU MODE - Valeur de la 1ère plongée en % ou MM (& décomposé) 
	if prmcode$ = 15075, perc_Val_pour_Cent_mm = rpar(sparameter$, 1)		# VALEUR de la 1ère plongée en % ou MM (& décomposé) 	
	if prmcode$ = 15076, perc_AVANCE_pour_Cent_mm = rpar(sparameter$, 1)	# VALEUR de la 1ère plongée en % ou MM (& décomposé) 
	
	if opcode$ <> 19, result = fprm (1)                         # Surep. pour le surfacage
    if opcode$ = 19, result = fprm (2)                          # Surep. pour 2D 3D
	
    #if Mode_reglage_PP = 0, [
        #"pparameter --> COMBINAISON D'AXE ROTATIF -ID:5999= A -ID:6002= B : ", *diviseur, e$
        #]
#endregion

#region sous_programmes
p_info_sous_prog
	if Mode_reglage_PP = 0, [
        n$, "num du sous-prog. : ", *main_prg_no$, e$
		n$, "NOM du sous-prog. : ", *sub_prg_no$, e$ 
		n$, "ID du sous-prog. : ", *sub_trns_id$, e$ 
		n$, "num de la chaine : ", *sub_chn_no$, e$ 
		n$, "Absolu ou relatif : ", *sub_inc$, e$
        n$, "(PASSE ", *sub_sec_no$, "SUR ", *sub_totl_no$, ")", e$
        "Subprogram number :", *sub_op_id$, e$
        "Actual operation ID :", *sub_grp_id$, e$
        "Transform/non-transform indicator :", *sub_ref_id$, e$
        "Iteration counter :", *sub_sec_no$, e$
        "Total number of instances :", sub_totl_no$, e$
        "0=mirror, 1=rotate, 2=scale, 3=translate :", *sub_trnstyp$, e$
        "(mirror) - 0=X axis, 1=Y axis, 2=line :", *sub_trnmthd$, e$
        "(rotate) - 0=tplane, 1=tplane origin only, 2=coordinates :", *sub_trnmthd$, e$
        *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, *sub_nxt_t$, *sub_nxt_h$, *sub_nxt_tid$, *sub_mny_t$, e$
        *wdum3$, "----", *rcc_flg$, *sub_prg_no$, *subout$, *sub_level$, *absinc$, e$
        ]

#---------------- BLOCS DE TRAITEMENT DES SOUS-PROG EN Z ---------------------------------		
psub_call_s$       # appel sous prog en Z
	if sub_sec_no$ = 1, n$, s_com_open, "APPEL SOUS-PROGRAMME", s_com_close, e$
	if sub_sec_no$ = 1, n$, s_com_open, "PASSES EN Z", s_com_close, e$
	n$, s_com_open, "PASSE ", sub_sec_no$, "SUR ", sub_totl_no$, "EN Z", s_com_close, e$
    n$, sub_op_id$, e$

psub_st_s$    # entete sous prog en Z
    n$, s_com_open, "SOUS-PROGRAMME- PASSES EN Z", s_com_close, e$
    n$, sub_prg_no$, e$
	n$, ";", no_spc$, strtool$, e$

psub_end_s$    # fin sous prog en Z
    n$, "LBL 0", e$
    n$, ";", e$
	
#-------------------------BLOCS DE TRAITEMENT DES SOUS PROG EN TRANSFORMER ---------------------------
ptranslation    # pour usinage transformer en translation
	if sub_trnsx$ = 0 & sub_trnsy$ = 0 & sub_trnsz$ = 0,   [   # si pas de decalage
		#MEMO POINT DE DEPART XYZ
		xrp = xr$
		yrp = yr$
		zrp = zr$
		]
	else, [                         # si decalage, ecriture du G52
		memo_incremental = incremental
		incremental = 0
		n$, " ", e$
		n$, "; ACTIVATION DU CYCLE DEF 7", e$
	    if sub_trnsx$ <> 0 | sub_trnsy$ <> 0 | sub_trnsz$ <> 0, [
	        n$, "; SUIVANT VALEURS MC", e$
	        n$, "CYCL DEF 7.0 POINT ZERO", e$
	        n$, "CYCL DEF 7.1 ", sub_trnsx$, e$
	        n$, "CYCL DEF 7.2 ", sub_trnsy$, e$
	        n$, "CYCL DEF 7.3 ", sub_trnsz$, e$
			]
		n$, "L", *xrp, *yrp, *zrp, *sgcode, e$ #*sinc_abs,		
		#n$, "(FAIRE UN DECALGE G52)", e$
		#n$, sinc_abs, "G52", *sub_trnsx$, *sub_trnsy$, *sub_trnsz$, e$   # ecriture des valeur de decalage d'origine
		decalage = 1                            # memo de mise en place de decalage pour l'annuler
		incremental= memo_incremental
		#n$, sinc_abs, e$
		]

psub_mirror     #Mirror start code, user
	n$, "CALL LBL 888 ; ANNUL. ROT", e$
	n$, " ", e$
	n$, "CYCL DEF 8.0 IMAGE MIROIR", e$	
	n$, "CYCL DEF 8.1",  	#"CYCL DEF 8.1 X Y U V W A B C 
		if sub_trnmthd$ = 0, "X", e$
		if sub_trnmthd$ = 1, "Y", e$
		if sub_trnmthd$ = 2, "X Y", e$ 
	
psub_rotate     #Rotate start code, user
	Rot_ABS_SP = atan2(sub_m2$, sub_m1$)
	if sub_sec_no$, [
		Rot_INC_SP = prv_Rot_ABS_SP - Rot_ABS_SP
		while Rot_INC_SP > 180, Rot_INC_SP = Rot_INC_SP- 360
		while Rot_INC_SP < -180, Rot_INC_SP = Rot_INC_SP + 360
		#if rot_ccw_pos = one, Rot_INC_SP = - Rot_INC_SP
		!Rot_ABS_SP
		absinc$ = zero
		]
	else, [
	    !Rot_ABS_SP
	    ]	 
	n$, "CALL LBL 888 ; ANNUL. ROT", e$
	n$, " ", e$
	n$, "CYCL DEF 10.0 ROTATION", e$
	if sub_trnmthd$ = 2, n$, "CYCL DEF 10.1 ROT ", *Rot_ABS_SP, e$	
	n$, "L", *xrp, *yrp, *zrp, *sgcode, e$ #*sinc_abs,	

s_sous_p_en_ABSOLU_HS	: "ATTENTION ! Les sous-programmes doivent être en RELATIF autrement il va y avoir des parcours en trop ! PASSEZ EN mode RELATIF"
p_type_sous_prog
	if sub_trnstyp$ <> old_sub_trnstyp, [   	
		n$, s_com_open, "APPEL SOUS-PROGRAMME ", s_com_close, e$
		if sub_trnstyp$ = 0, n$, s_com_open, "TRANSFORMATION PAR MIRROIR ", s_com_close, e$
		if sub_trnstyp$ = 1, n$, s_com_open, "TRANSFORMATION PAR ROTATION ", s_com_close, e$
		if sub_trnstyp$ = 2, n$, s_com_open, "TRANSFORMATION PAR ECHELLE ", s_com_close, e$
		if sub_trnstyp$ = 3, n$, s_com_open, "TRANSFORMATION PAR TRANSLATION ", s_com_close, e$
		]
	if sub_inc$ = 0, result = mprint(s_sous_p_en_ABSOLU_HS)

psub_call_mm$     # appel sous prog en transformation pour outils multiples
	p_info_sous_prog
	#"appel sous prog en transformation pour outils multiples", e$
	!main_prg_no$                    				# mise a jour du numero interne de sous prog en transformation pour outils multiples
	subprognum = debsousprog + main_prg_no$ +100   	# affectation du numero de sous-programme
	if sub_trnstyp$ = 3, ptranslation       		# si on fait de la translation aller avant dans bloc ecriture decalage origine
	if sub_trnstyp$ = 0, psub_mirror
	if sub_trnstyp$ = 1, psub_rotate
	p_type_sous_prog
	if sub_trnstyp$ <> old_sub_trnstyp, n$, s_com_open, "AVEC OUTILS MULTIPLES ", s_com_close, e$
	n$, subprognum, e$       				# appel du sous prog
	old_sub_trnstyp = sub_trnstyp$  
	
psub_call_m$   # appel sous prog en transformation pour outil unique
	p_info_sous_prog
	#"appel sous prog en transformation", e$
	!main_prg_no$              						# mise a jour du numero interne de sous prog en transformation pour outils multiples
	subprognum = debsousprog + main_prg_no$ +100   	# affectation du numero de sous prog
	if sub_trnstyp$ = 3, ptranslation  				# si on fait de la translation aller avant dans bloc ecriture decalage orignie
	if sub_trnstyp$ = 0, psub_mirror
	if sub_trnstyp$ = 1, psub_rotate
	p_type_sous_prog
	if sub_trnstyp$ <> old_sub_trnstyp, n$, s_com_open, "AVEC UN SEUL OUTIL ", s_com_close, e$            	# affecation du parametre CN pour memo du numéro de ligne
	n$, subprognum, e$       				# appel du sous prog
	old_sub_trnstyp = sub_trnstyp$  
	
psub_end_m_r$    # bloc system non explique dans doc des PST (a voir)
	#NESTING
    #n$, "; TEST - psub_end_m_r$", e$

psub_st_m$    # entete sous prog en transformation
    !main_prg_no$                   		# mise a jour du numero interne de sous prog en transformation pour outils multiples
    numsubprog = debsousprog + main_prg_no$ +100    # affectation du numero de sous prog
    nomsubprog = numsubprog                 # affectation du nom de sous prog en Z
    memo_incremental = incremental          # memorisation du mode ABS INC Actuel
    # **** VOLONTAIREMENT PAS DE DEPLACEMENTS EN MODE RELATIF **** UTILISE ET force en ABSOLU SUITE A un PROBLEME de REPETITION 
    #incremental = sub_inc$                  # Sous prog en incremental ou absolue
	# ****
    #n$ = 10                                 # numero de ligne de sous prog
    #"%", e$
    #if incremental = 1, p_casse_modalite    # casser la modalité pour les sous prog en relatif
    #p_casse_modalite_avance                 # casser la modalité le l'avance pour les sous prog
    #omitseq$ = 1                            # pas du numero de ligne pour les sous prog
    if texte <> 0,   [                      # entete avec commentaires
        #old_spaces = spaces$
        spaces$ = 1
        if scomentsprog <> svide2, n$, *numsubprog, " ", s_com_open, scomentsprog, s_com_close, e$
        else, n$, *numsubprog, e$
        if snomprogentete <> svide2, n$, s_com_open, snomprogentete, s_com_close, e$
        if snom_entete <> svide2, n$, s_com_open, *snom_entete, s_com_close, e$
        n$, s_com_open, "SOUS-PROGRAMME PAR -TRANSFORMATION-", s_com_close, e$
		xrp = xr$
		yrp = yr$
		zrp = zr$
        ]
    else,       [               			# entete sans commentaires
        n$, *numsubprog,  e$
        ]
    n$, s_com_open, strtool$, s_com_close, e$
    #n$, *sinc_abs, e$           			# ecrire si sous prog en ABS ou INC
    gcode$ = 5              				# pour forcer l'ecriture de code G du premier bloc du sous prog
    !gcode$

psub_end_m$   # fin sous-prog en TRANSFORMATION/ROTATION ...
	n$, "LBL 0", e$
	prv_absinc$ = m_one
	#Reset update variables for subs at main level
	#Mirror or Rotate cancel, output is forced
	if (sub_trnstyp$ = zero & esub_sec_no$ > zero)
	| (sub_trnstyp$ = one & esub_sec_no$ = esub_totl_no$-one
	& sub_trnmthd$ = two),[
		subout$ = zero
		no_nc_out$ = m_one
		sav_absinc = absinc$
		#Mirror cancel
		if sub_trnstyp$ = zero,[
			absinc$ = zero
			n$, " A CREER -ANNUL SOUS PROG MIRROIR-", e$
			n$, "DEC", *sub_trnsx$, *sub_trnsy$, e$
			n$, "CYCL DEF 8.0 IMAGE MIROIR", e$	
			n$, "CYCL DEF 8.1 ",  	#"CYCL DEF 8.1 X Y U V W A B C 
				if sub_trnsx$ & sub_trnsy$ = 0, *sub_trnsx$, e$
				if sub_trnsy$ & sub_trnsx$ = 0, *sub_trnsy$, e$ 
				if sub_trnsx$ & sub_trnsy$, *sub_trnsx$, sub_trnsy$, e$
			]
		absinc$ = sav_absinc
		no_nc_out$ = zero
		]
	if sub_trnstyp$ = 1, [ #Rotate cancel
		n$, "LBL 888", e$
		n$, s_com_open, "-ANNULATION SOUS-PROG EN ROTATION-", s_com_close, e$
		n$, "CYCL DEF 10.0 ROTATION", e$
		n$, "CYCL DEF 10.1 ROT 0", e$
		n$, "LBL 0", e$
		]
	if sub_trnstyp$ = 1, [ #Rotate cancel
		n$, "LBL 887", e$
		n$, s_com_open, "-ANNULATION SOUS-PROG EN MIROIR-", s_com_close, e$
		n$, s_com_open, "-A DEFINIR-", s_com_close, e$
		n$, "CYCL DEF 8.0 IMAGE MIROIR", e$	
		n$, "CYCL DEF 8.1 ",  
		n$, "LBL 0", e$
		]
	end_sub_mny = sub_mny_t$

#psub_end_mny    #End in main level for many tools sub, user
	##Check for coming out of xform with stage tool.
	#if end_sub_mny & bldnxtool$ = one, [
	#*t$
	#end_sub_mny = zero
	#]	  
#endregion

#region decallages_origines
#   Gestion des décallages d'origine CYCLE DEF 7 POINT ZERO (G54 ...) ou valeur reelle (PLAN de construstion)
s_INFO_tab_pt_0 		: ""
s_INFO_NEW_CYCLE_247 	: " " 
s_INFO_NEW_CYCLE_247_2 	: "VERIFIEZ les -valeurs optionnelles - Entiers NUM: 1- de cette OP et mettre à 0 ou 1 si necessaire !"
nbr_info_err_1	: -1
nbr_info_err_2	: -1
p_ori_usi
    # OPERATIONS TRANSFORMATIONS 
		# MODE 1 "AUTO ORIGINES" PASSENT A 1
		# MODE 2 
		# MODE 3 "INCREMENTAL" --> ok avec workofs$ 
	@workofs_,@old_workofs
	if Mode_reglage_PP = 0, [
	    n$, "workofs_", *workofs_, e$
		n$, "workofs$", *workofs$, e$
	    n$, "old_workofs", *old_workofs, e$ 
		n$, "op_transformation :", *xform_op_id$, " ", *op_id$, "dec transf:", *workofs_dec, e$
		n$, "mi1_prmcode, old_mi1 :", *mi1_prmcode, *old_mi1, e$
		# xform_op_id$ & op_id$ même numéro = pas de transformation 
		]
    s_INFO_tab_pt_0 = "ATTENTION ! utilisation du TABLEAU PT ZERO, à activer sur la CN -.D ! OP. MC: " + s_old_spost_arg_2 + " AVEC L'OUTIL " + no2str(t$)
	s_INFO_NEW_CYCLE_247 = "ATTENTION ! utilisation d'un autre ORIGINE CYCLE 247 sur une même pièce OP. MC: " + s_old_spost_arg_2 + " AVEC L'OUTIL " + no2str(t$) 
	# CYCLE 247 PT DE REF --> A utiliser plutot pour un origine par pièce
		# Uniquement si changement dans mi1$
		# FORCE à l'appel de chaque outil		
	if mi1_prmcode <> old_mi1 & workofs_dec < 1, [	# changement du PT DE REF 247 avec la "valeur optionnel"
		n$, "CYCL DEF 247 INIT. PT DE REF.~", e$
		if mi1_prmcode < 1, "  Q339= +1 ; NUMERO DE PT DE REF.", e$
    	if mi1_prmcode > 0, "  Q339=", mi1_prmcode, "; NUMERO DE PT DE REF.", e$
		if mi1_prmcode > 1 & nbr_info_err_1 < 0, [		
			result = mprint(s_INFO_NEW_CYCLE_247)
			result = mprint(s_INFO_NEW_CYCLE_247_2)
			nbr_info_err_1 = 1 
			]
		old_mi1 = mi1_prmcode
		]
	# OPERATIONS TRANSFORMEES
	if xform_op_id$ <> op_id$ & workofs$ <> old_workofs & workofs_dec > 0, [	
		workofs_ = workofs$
		if Type_decalages = 1 | debut = 2, 	[	# 1er en 247
			n$, "CYCL DEF 247 INIT. PT DE REF.~", e$
	    	"  Q339=", *workofs_, "; NUMERO DE PT DE REF.", e$
			]
		if Type_decalages = 2 & debut <> 2, [
			n$, "; SUIVANT TABLEAU POINT ZERO", e$
            n$, "CYCL DEF 7.0 POINT ZERO", e$
            n$, "CYCL DEF 7.1", 35, *workofs_, e$
			]
		old_workofs = workofs$ 
		]
	# CYCLE DEF 7 --> DECALLAGE DEPUIS l'ORIGINE 247 ACTIF
		# DECALLAGES AVEC LES VALEURS MC X/Y/Z
		# ou DECALLAGES : SUIVANT TABLEAU POINT ZERO (utilisé pour les palpages)	
	if workofs_ >0 & xform_op_id$ = op_id$, [
		if (workofs_ <> old_workofs) & (old_workofs <> -2), [
            n$, "CALL LBL 99", e$
            n$, "; ACTIVATION DU CYCLE DEF 7", e$
            if tox4$ <> 0 | toy4$ <> 0 | toz4$ <> 0, [
                n$, "; SUIVANT VALEURS MC", e$
                n$, "CYCL DEF 7.0 POINT ZERO", e$
                n$, "CYCL DEF 7.1 ", *tox4$, e$
                n$, "CYCL DEF 7.2 ", *toy4$, e$
                n$, "CYCL DEF 7.3 ", *toz4$, e$
                ]
            else, [
                # ACTIF SI ORIGINE SANS DECALLAGE
				n$, "; SUIVANT TABLEAU POINT ZERO", e$
                n$, "CYCL DEF 7.0 POINT ZERO", e$
                n$, "CYCL DEF 7.1", 35, *workofs_, e$
				if nbr_info_err_2 < 0, result = mprint(s_INFO_tab_pt_0)
				nbr_info_err_2 = 1
                ]
            ]
        old_workofs = workofs_
        ]
	if sinfo_origine <> svide2 & sinfo_origine <> s_old_sinfo_origine,	[
        n$, s_com_open, "INFO DECALAGE :", *sinfo_origine, s_com_close, e$
		s_old_sinfo_origine = sinfo_origine 
        ]		

p_ori_usi_annul
    n$, "CALL LBL 99", e$
#endregion

#region block_form
p_block_form
	if stock_shape <> zero & stock_shape <> one, result = mprint(s_erreur_stock_shape)  #Only Rectangular and Cylindrical are supported
	if block_form & stock_shape = zero,
        [
        if stck_crnr$ = 0,  #Top - Center
          [
          stck_x_min = stck_x$ - stck_ht$/2
          stck_y_min = stck_y$ - stck_wdth$/2
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$ + stck_ht$/2
          stck_y_max = stck_y$ + stck_wdth$/2
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 1,  #Top - Upper Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$ + stck_ht$
          stck_y_max = stck_y$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 2,  #Top - Upper Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 3,  #Top - Lower Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$
          stck_y_max = stck_y$ + stck_wdth$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 4,  #Top - Lower Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$
          stck_z_min = stck_z$ - stck_thck$
          stck_x_max = stck_x$ + stck_ht$
          stck_y_max = stck_y$ + stck_wdth$
          stck_z_max = stck_z$
          ]

        if stck_crnr$ = 5, #Bottom - Upper Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$ + stck_thck$
          ]

        if stck_crnr$ = 6,  #Bottom - Upper Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$ - stck_wdth$
          stck_z_min = stck_z$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$ + stck_thck$
          ]

        if stck_crnr$ = 7,  #Bottom Lower Right
          [
          stck_x_min = stck_x$ - stck_ht$
          stck_y_min = stck_y$
          stck_z_min = stck_z$
          stck_x_max = stck_x$
          stck_y_max = stck_y$
          stck_z_max = stck_z$ + stck_thck$
          ]

        if stck_crnr$ = 8,  #Bottom - Lower Left
          [
          stck_x_min = stck_x$
          stck_y_min = stck_y$
          stck_z_min = stck_z$
          stck_x_max = stck_x$ + stck_ht$
          stck_y_max = stck_y$ + stck_wdth$
          stck_z_max = stck_z$ + stck_thck$
          ]
        stck_x_min = vsub(stck_x_min, t_orgin_x$) #(add or) subtract the tool origin from the 1027 line
        stck_x_max = vsub(stck_x_max, t_orgin_x$) #(add or) subtract the tool origin from the 1027 line
        if stck_x_min = 0 & stck_y_min = 0 & stck_z_min = 0 & stck_x_max = 0 & stck_y_max = 0 & stck_z_max = 0,
			n$, s_com_open, "BRUT NON DEFINI", s_com_close, e$
		else, [
			n$, "BLK FORM  0.1 Z", *stck_x_min, *stck_y_min, *stck_z_min, e$
	        n$, "BLK FORM  0.2  ", *stck_x_max, *stck_y_max, *stck_z_max, e$
	        ]
		]
		
      if block_form & stock_shape = one,  # Cylinder
        [
		if stock_cyl_axis >= 0,  # Cylinder about Z or cylinder about same axis as rotary centerline
          [
          # Build & output the WORKPIECE line - "WORKPIECE(,"",,"CYLINDER", par2, ztop, zbottom, -80, diameter)"
          # Absolute stock length dim in Siemens
          if stock_cyl_axis = 0,  # Stock about X-axis
            [
            topz = stck_x$ + stck_wdth$  #Define X+ end of stock
            bottomz = stck_x$            #Define X- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          if stock_cyl_axis = 1,  # Stock about Y-axis
            [
            topz = stck_y$ + stck_wdth$  #Define Y+ end of stock
            bottomz = stck_y$            #Define Y- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          if stock_cyl_axis = 2,  # Stock about Z-axis
            [
            topz = stck_z$ + stck_wdth$  #Define Z+ end of stock
            bottomz = stck_z$            #Define Z- end of stock
            stck_cyl_dia = stck_ht$      #Define stock diameter
            ]
          # Output WORKPIECE line using values determined above / Define the stock for graphics - Cylinder
		  stck_cyl_dia = stck_cyl_dia / 2 # Ici valeur au rayon
		  if stock_cyl_axis = 0, s_axe_brut_cyl = "X"
		  if stock_cyl_axis = 1, s_axe_brut_cyl = "Y" 
		  if stock_cyl_axis = 2, s_axe_brut_cyl = "Z" 
          n$, "BLK FORM CYLINDER", *s_axe_brut_cyl, *stck_cyl_dia, *topz, *bottomz, *stck_cyl_dia_inter, e$ # Z R50 L105 DIST+5 R110 = AXE DE BROCHE, RAYON, LONGUEUR, "DIST", RAYON INTER
          ]
        ]
	if block_form & stock_shape = two, n$, "; Brut solide-Maillage utilisé dans MasterCam", e$		# Solide-Maillage
    if block_form & stock_shape = three, n$, "; Brut depuis fichier STL utilisé dans MasterCam", e$	# Stl					
#endregion

#region 4_axes

#region rotations_axes_continu
# continu -------------------------------------------------------
p_axeAB_pmx
    #*old_axeA1, *axeA1
    delta_axeA1 = axeA1 - old_axeA1
    if delta_axeA1 >  180, delta_axeA1 = delta_axeA1 - 360
    if delta_axeA1 <  -180,delta_axeA1 = delta_axeA1 + 360
    axeA1_dep = axeA1_dep + delta_axeA1
    old_axeA1 = axeA1
    axeA = axeA1_dep
    old_axeA = axeA1_dep
    nbrtour = int (axeA / 360) * sens_A_B
    if debutpmx = 1, *axeA, else, if prv_axeA <> axeA, axeA,   #, !axeAi
    #if incremental = 0, axeA, !axeAi
    #if incremental = 1, !axeA, axeAi

p_calcul_rot_pmx
    #"VOIR", *x$, *y$, *z$, *u$, *v$, *w$, e$
    vx = u$ - x$
    vy = v$ - y$
    vz = w$ - z$
    if diviseur = 1, axeA1 = atan2(vy,vz) # on tourne autour de x
    if diviseur = 2, axeA1 = atan2(vx,vz) # on tourne autour de Y
	axeA = axeA * sens_A_B
    if axeA1 >  180, axeA2 = 360 - axeA1
    if axeA1 <= 180, axeA2 = axeA1 * -1
    if diviseur = 1, [          # on tourne autour de x
        new_x = x$
        new_y = z$*sin(axeA2) + y$*cos(axeA2)
        new_z = z$*cos(axeA2) - y$*sin(axeA2)
            ]
    if diviseur = 2, [          # on tourne autour de Y
        new_x = z$*sin(axeA2) + x$*cos(axeA2)
        new_y = y$
        new_z = z$*cos(axeA2) - x$*sin(axeA2)
        ]
    xabs = new_x
    yabs = new_y
    zabs = new_z
	epsi = old_axeA - axeA1  	# regarder si on tourne
    epsi = abs(epsi)
	old_axeA = axeA1
	
#endregion

#region pmx_
pmx$        # Gestion 4 axes continue avec fonction 5 axes
    if Mode_reglage_PP = 0, n$, "--> pmx$", *x$, *y$, *z$, *zr$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$, 
		*m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$
		
	# ***** ATTENTION ! LE perçage 5 axes en 4AXES NE PASSE PAS ICI********
	# ***** PAS de gestion complète du perçage 5 axes ICI
	#		- pmx$ 
	# 		- p_drill_5axes pour le début XY/A/HZ/A ..
	# 		- p_drill_5axes_2 suivants	 
			 
	if debutpmx = 1 & opcode$ <> 16 , p_debut_pmx, ex$
	# 5 AXES classique
    if debutpmx = 0 & opcode$ <> 16,	[	#pas pour le perçage 5 axes
		if Mode_reglage_PP = 0, "pmx_ CONTOURS: ", e$
        p_calcul_rot_pmx
		if m1$ <> 1 & m5$ <> 1, p_erreur_inclinaison_OP_5axes 	# TEST si mauvaise inclinaison
        if fr$ = -2, gcode$ = 0
        else, gcode$ = 1
        if gcode$ = 1,	[
			@xabs, @yabs, @old_x, @old_y
            if xabs <> old_x | yabs <> old_y, n$, "L", xabs, yabs, zabs, p_axeAB_pmx, pfr, e$	#pxyz, 
            else, n$, "L", xabs, yabs, zabs, p_axeAB_pmx, pfr, e$	#pxyz,
            ]
        else, n$, "L", xabs, yabs, zabs, p_axeAB_pmx, *sgcode, e$	#pxyz,
        ] 
    # Uniquement perçage 5 axes
	#if debutpmx = 0 & opcode$ = 16 & gcode$ = 11 & nextop$ = 11,	[ 
		#if Mode_reglage_PP = 0, "pmx_ PERCAGES: ", e$        
		#p_calcul_rot_pmx	  
		#if fr$ = -2, gcode$ = 0, else, gcode$ = 1
		#n$, "L", sgcode, *xabs, *yabs, *zabs, p_axeAB_pmx, [if gcode$ =1, pfr], e$
		#old_op_id = op_id$
		#old_op = 11			#pour forcer le "A/B" après le pmx$
		#]
	#if debutpmx = 0 & opcode$ = 16 & gcode$ = 11 & nextop$ = 1003, #FIN DE PERCAGES --> Z HAUT SECU
		#[
		#p_calcul_rot_pmx
		#gcode$ = 0
		#n$, "L", *zabs, *sgcode, e$ 
		#]
	old_x = xabs
    old_y = yabs
    old_z = zabs

p_debut_pmx
    if Mode_reglage_PP = 0, n$, "p_debut_pmx", e$
	@new_z
    if opcode$ <> 16, p_calcul_rot_pmx
	if mi7$ = 1, bloque = 2, n$, sbloque, e$			# déblocage de l'axe A/B    
    gcode$ = 0
	old_axeA = -99999
    if opcode$ <> 16, n$, "L", p_axeAB_pmx, *sgcode, e$

	if diviseur = 1, new_y = nextz$*sin(axeA2) + nexty$*cos(axeA2)
	if diviseur = 2, new_x = nextz$*sin(axeA2) + nextx$*cos(axeA2)
		
    if diviseur = 1, n$, "L", *xabs, *new_y, ssa, spdlon, *sgcode, e$
	if diviseur = 2, n$, "L", *new_x, *yabs, ssa, spdlon, *sgcode, e$
	zr_ = zr$
	#*xabs, *yabs, e$
	#if opcode$ <> 16, n$, "L", *sgcode, *zr$, e$ 	   
    if opcode$ <> 16, n$, "L", *zabs, p_lubrif_ON, *sgcode, e$  
	if opcode$ = 16, new_z = old_z, n$, "L", *sgcode, *zr_, p_lubrif_ON, e$ 	# *new_z, p_lubrif_ON, e$
	!x$, !y$, !z$, !xr$, !yr$, !zr$
    old_x = xabs
    old_y = yabs
    old_z = zabs
    debutpmx = 0

pmx_end$	#FIN de chaque BLOC pmx$
	if Mode_reglage_PP = 0, "pmx_end_: ", e$
	
#endregion 
#endregion

#region mouvements pxyz et 4 axes
pxyz        # ecriture des x, y, z en abs ou incremental pour corps ISO
	xabs = x$
    yabs = y$
    zabs = z$
	pxyz_new
    #p_modal     #affectation en format modal
    !x$, !y$, !z$  # mise a jour xyz
    old_x = xabs
    old_y = yabs
    old_z = zabs
	prvz = z$   

#region calculs TETE DE RENVOIE
pcalcul_plan    
	angle_autour_Y = asin (m3$)
    cos_angleY = cos (angle_autour_Y)
    angle_autour_Y = angle_autour_Y *-1
    if cos_angleY > 0.005 ,
    [
        #3 angle autour de X
        tr_x = m9$ / cos_angleY
        tr_y = -m6$ / cos_angleY
        angle_autour_X  = atan2 (tr_y,tr_x)
        if angle_autour_X > 180 , angle_autour_X = angle_autour_X - 360
        angle_autour_X = angle_autour_X * -1
        #4 angle autour de Z
        tr_x = m1$ / cos_angleY
        tr_y = -m2$ / cos_angleY
        angle_autour_Z  = atan2 (tr_y,tr_x)
        if angle_autour_Z > 180 , angle_autour_Z = angle_autour_Z - 360
        angle_autour_Z = angle_autour_Z * -1
    ]
    else,
    [
        # angle autour de X
        angle_autour_X  = 0
        # angle autour de Z
        angle_autour_Z  = atan2 (m4$,m5$)
        if angle_autour_Z > 180 , angle_autour_Z = angle_autour_Z - 360
        angle_autour_Z = angle_autour_Z * -1
    ]	
	
pcalcul_xyz_absolu
    !angle_autour_X, !angle_autour_Y, !angle_autour_Z
    angle_autour_X_2 = angle_autour_X * -1
    angle_autour_Z_2 = angle_autour_Z * -1
    angle_autour_Y_2 = angle_autour_Y * -1
	#"voir les angles tournés ", *angle_autour_X_2, *angle_autour_Z_2 , *angle_autour_Y_2 , e$
    #   tourne le point autour X
    y1 = zdep * sin(angle_autour_X_2) + ydep * cos(angle_autour_X_2)
    z1 = zdep * cos(angle_autour_X_2) - ydep * sin(angle_autour_X_2)
    #   tourne le point autour Y
    zabs = xdep * sin(angle_autour_Y_2) + z1  * cos(angle_autour_Y_2)
    x1 = xdep * cos(angle_autour_Y_2) - z1  * sin(angle_autour_Y_2)
    # tourne le point autour de Z
    xabs = y1  * sin(angle_autour_Z_2) + x1  * cos(angle_autour_Z_2)
    yabs = y1  * cos(angle_autour_Z_2) - x1  * sin(angle_autour_Z_2)
		
angle_autour_X_2 : 0
angle_autour_Z_2 : 0
angle_autour_Y_2 : 0
angle_autour_Z : 0
angle_autour_Y : 0 
angle_autour_X : 0
xplan_inter : 0
yplan_inter : 0
zplan_inter : 0	
tr_y : 0
tr_x : 0
cos_angleY : 0
x1 : 0
y1 : 0
z1 : 0
xplan : 0
yplan : 0
zplan : 0
xdep : 0
ydep : 0
zdep : 0
sauvX : 0
sauvY : 0
sauvZ : 0

p_calcul_xyz_tete_renvoie
	pcalcul_plan
	sauvX = x$
	sauvY = y$
	sauvZ = z$
	xdep = x$
	ydep = y$
	zdep = z$
	pcalcul_xyz_absolu
	x$ = xabs
	y$ = yabs
	z$ = zabs
	#AUTRE CEDRIC
 	#xabs = x$ * m1$ + y$ * m2$ + z$ * m3$
	#Yabs = x$ * m4$ + y$ * m5$ + z$ * m6$
	#Zabs = x$ * m7$ + y$ * m8$ + z$ * m9$

#endregion 

pxyz_new 	# ecriture des positions X Y Z et A pour XYZ CLASIQUE et substitution
	if ra_block$ >0, p_calcul_xyz_tete_renvoie #RENVOIE D'ANGLE	
	
    if rotaxis$ = 0, [    # XYZ CLASSIQUE 
        if cc$ <> old_cc & cc$ <> 140 & cc$ <> 0, *xabs, *yabs, [if zabs <> prvz, zabs] #  | cc$ = 140  !xinc, !yinc, !zinc
        else, x$, y$, z$ 
        ]
		
 	if drillcyc$ < 0, [
	 	#POUR SUBSTITUTION "incrémental" ?	
	    #if incremental = 0, xabs, yabs, axeA, zabs, !xinc, !yinc, !axeAi, !zinc
	    #else, !xabs, !yabs, !axeA, !zabs, xinc, yinc, axeAi, zinc   
		if rotaxis$ = -2 | rotaxis$ = 2, [    # SUBSTITUTION Y par A (diviseur tourne autour de X)
			p_calcul_AB_pos_Subs
			yabs = 0
			xabs = x$
	        xabs, [if yabs <> old_y, yabs], zdev, axeAB_subs, !yabs, !zabs     #, !xinc, !yinc, !zinc, !A_posi, !zdevi
	        axeA = axeAB_subs
			old_x = xabs
			old_y = 0
			old_z = zdev
	        old_axeA = axeAB_subs
	        nbrtour = int (axeA / 360)
	        ]
	    if rotaxis$ = -1 | rotaxis$ = 1, [    # SUBSTITUTION X par A (diviseur tourne autour de Y)
			p_calcul_AB_pos_Subs
			xabs = 0
			yabs = y$
	        [if xabs <> old_x, xabs], yabs, zdev, axeAB_subs, !xabs, !zabs     #, !xinc, !yinc, !zinc, !A_posi, !zdevi
	        axeA = axeAB_subs
			old_x = 0
			old_z = zdev
	        old_axeA = axeAB_subs
	        nbrtour = int (axeA / 360)
	        ]
		]
	if rotaxis$ <> 0 & drillcyc$ >= 0, zdev	
#endregion

#region CALCUL & AFFICHAGE EN POSITIONNE
prot0$
prot$

p_rotation_tlchg      				# affichage de l'angle au changemant d'outil
    if Mode_reglage_PP = 0, n$, "--> p_rotation_tlchg", e$
	#Perreur_origine_plan
    Perreur_nom_RUD
    if ra_type$ = 0, perreur_tranf_plan   	# pas de broche à RENVOIE d'ANGLE 
    if subout$ = 0, [       				# afficher les angles que dans le programme principal
       if useaxe <> 0, [
            @old_axeA, @axeA
            epsi = old_axeA - axeA
            epsi = abs(epsi)
			if Mode_reglage_PP = 0, n$, "--> p_rotation_tlchg", "old:", *old_axeA, "axe:", *axeA, "epsi:", *epsi, e$
            #if epsi <> 0,[
                if mi7$ = 1, bloque = 2, n$, sbloque, e$			# déblocage de l'axe A/B
				if s_rot_plus_court_ON <> svide2, n$, s_rot_plus_court_ON, e$
                p_affiche_type_rot
                if mi7$ = 1, bloque = 1, n$, sbloque, e$     		# bloquer l'axe A/B
                #]
            ]
        old_axeA = axeA
        ]

p_rot_tlchg0      			# affichage de l'angle au chg outil nul pour positionné
    #Perreur_origine_plan    		
    Perreur_nom_RUD         		
    if ra_type$ = 0, perreur_tranf_plan   	# pas de broche à RENVOIE d'ANGLE 
    if subout$ = 0, [           			# afficher les angles que dans le prog principal
       if useaxe <> 0 | opcode$ = 16, [
            @old_axeA, @axeA
            epsi = old_axeA - axeA
            epsi = abs(epsi)
            if Mode_reglage_PP = 0, n$, "--> p_rot_tlchg0", "old:", *old_axeA, "axe:", *axeA, "epsi:", *epsi, *memo_old_axeA, e$
            if epsi <> 0, [
                p_degage_4_axes
                if mi7$ = 1, bloque = 2, n$, sbloque, e$			# déblocage de l'axe A/B 
				if s_rot_plus_court_ON <> svide2, n$, s_rot_plus_court_ON, e$
				p_affiche_type_rot             
                if mi7$ = 1, bloque = 1, n$, sbloque, e$     		# bloquer l'axe A/B			
				gcode$ = 0       
				xabs = xr$
				yabs = yr$ 
				#xabs = nextx$
				#yabs = nexty$
				if xabs <> prv_xabs | yabs <> prv_yabs, n$, "L", *xabs, *yabs, *sgcode, e$
				#n$, sgcode, *zabs, e$           
                !x$, !y$#, !z$
                ]
            ]
            old_axeA = axeA
        ]
		
# POUR LE MODE DE ROTATION **5**
# ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M..."
s_M_ROT_PO_P1_1 : "M56 ; palette A"	# ROTATION POSITIVE PALETTE A(1)	type palette commandée "A"
s_M_ROT_PO_P1_2 : "M55 ; + 90DEG"	# ROTATION POSITIVE PALETTE A(1)	ROT en +
s_M_ROT_NE_P1_1 : "M56 ; palette A"	# ROTATION NEGATIVE PALETTE A(1)	type palette commandée "A"
s_M_ROT_NE_P1_2 : "M54 ; - 90DEG"	# ROTATION NEGATIVE PALETTE A(1)	ROT en -

# ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
s_M_ROT_PO_P2_1 : "M57 ; palette B"	# ROTATION POSITIVE PALETTE B(2)	type palette commandée "B"	
s_M_ROT_PO_P2_2 : "M55 ; + 90DEG"	# ROTATION POSITIVE PALETTE B(2)	ROT en +
s_M_ROT_NE_P2_1 : "M57 ; palette B"	# ROTATION NEGATIVE PALETTE B(2)	type palette commandée "B"
s_M_ROT_NE_P2_2 : "M54 ; - 90DEG"	# ROTATION NEGATIVE PALETTE B(2)	ROT en -

s_M_ROT_PO_1 : ""
s_M_ROT_PO_2 : ""
s_M_ROT_NE_1 : ""
s_M_ROT_NE_2 : ""	
	
p_affiche_type_rot
	gcode$ = 0	
	if Systeme_rot_plans = 0, [	#pas de calculs "TOUJOURS EN G54"
		if incremental = 0, n$, "L", *axeA, "R0 ", sgcode, !axeAi, e$  #sinc_abs	
    	else, n$, "L", *axeAI, "R0 ", sgcode, !axeA, e$
		] 
	if Systeme_rot_plans = 1, [	#PLANS "CYCLE19/plane$ SPACIAL..."
		"SYSTEME DE PLANS 1 A DEFINIR", e$
		n$, " ; Annulation de toutes les transformations", e$ 
		if incremental = 0, n$, sgcode, "CYCLE19", *axeA, !axeAi, e$
	    else, n$, sgcode, !axeA, "CYCLE19 i", *axeAi, e$
		] 
	if Systeme_rot_plans = 2, [	#SOUS-PROGRAMME de calcul --> usi en G55
		"SYSTEME DE PLANS 2 A DEFINIR", e$	
		if incremental = 0, n$, sgcode, *axeA, !axeAi, e$
	    else, n$, sgcode, !axeA, *axeAi, e$
		n$, "M98 P8000", e$
		n$, s_com_open, "G55 ACTIF",  s_com_close, e$
		] 
	if Systeme_rot_plans = 3, [	#1 ORIGINE PAR ANGLE
		"SYSTEME DE PLANS 3 A DEFINIR", e$
		if incremental = 0, n$, sgcode, s_com_open, *axeA, s_com_close, !axeAi, e$
	    else, n$, sgcode, !axeA, s_com_open, *axeAi, s_com_close, e$	
		]
	if Systeme_rot_plans = 4, [	#MODULE DE ROTATION A PART "automate" --> FONCTION "M" -- 1 ORIGINE PAR ANGLE
		n$, "M21", s_com_open, , "ROTATION AXE A", s_com_close, e$
		if incremental = 0, n$, sgcode, s_com_open, *axeA, s_com_close, !axeAi, e$
	    else, n$, sgcode, !axeA, s_com_open, *axeAi, s_com_close, e$
		dwell$ = 2, p_temporisation 
		]
	if Systeme_rot_plans = 5, [	# 5 = FONCTION "M" en RELATIF **chaque M=90°** module de rotation à part "capteu automate" (1 ORIGINE PAR ANGLE)
		if axeA = -270, axeA = -90
		if axeA = 270, axeA = -90
		if axeA = -180, axeA = 180
		if epsi <>0, n$, s_com_open, "ROTATION AXE :", *axeA, " ANCIEN :", *old_axeA , s_com_close, e$
		
		if Var_16_question > 0, [	# ACTIVATION DE L'UTILISATION DE LA PALETTE "A"... CODES M"
			s_M_ROT_PO_1 = s_M_ROT_PO_P1_1
			s_M_ROT_PO_2 = s_M_ROT_PO_P1_2
			s_M_ROT_NE_1 = s_M_ROT_NE_P1_1
			s_M_ROT_NE_2 = s_M_ROT_NE_P1_2
			]
		if Var_17_question > 0, [	# ACTIVATION DE L'UTILISATION DE LA PALETTE "B"... CODES M..."
			s_M_ROT_PO_1 = s_M_ROT_PO_P2_1
			s_M_ROT_PO_2 = s_M_ROT_PO_P2_2
			s_M_ROT_NE_1 = s_M_ROT_NE_P2_1
			s_M_ROT_NE_2 = s_M_ROT_NE_P2_2
			]
		#ROTATION HORAIRE 	
		if old_axeA = 0 & axeA = 90, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$													#0 		--> 90
		if old_axeA = 0 & axeA = 180, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$	#0 		--> 180
		if old_axeA = 90 & axeA = 180, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$												#90		--> 180
		if old_axeA = 180 & axeA = -90, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$												#180	--> -90
		if old_axeA = 180 & axeA = 0, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$	#180	--> 0 
		if old_axeA = -90 & axeA = 0, n$, s_M_ROT_PO_1, e$, n$, s_M_ROT_PO_2, e$												#-90 	--> 0
		
		#ROTATION ANTI-HORAIRE 		
		if old_axeA = 0 & axeA = -90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$												#0 		--> -90	
		if old_axeA = -90 & axeA = 180, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$												#-90	--> -180
		if old_axeA = 90 & axeA = 0, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$													#90		--> 0
		if old_axeA = 180 & axeA = 90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$												#180	--> 90	
		if old_axeA = -90 & axeA = 90, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$, n$, s_M_ROT_NE_1, e$, n$, s_M_ROT_NE_2, e$	#-90	--> 90		
		if old_axeA <> axeA, dwell$ = 2, p_temporisation 
		old_axeA = axeA
		]
#endregion

#region calculs_et_affichage_rotations_en_continu_et_substitution
p_calcul_AB_pos_Subs  # calcul de l'axe A/B en substitution
    @x$, @y$
    if diviseur = 1, axeAB_subs = (y$ * 360 / (pi$ * rotdia$)) * sens_A_B  		# pour 4eme axe autour de X (substituer Y)
    if diviseur = 2, axeAB_subs = (x$ * 360 / (pi$ * rotdia$)) * sens_A_B   	# pour 4eme axe autour de Y (substituer X)
	if diviseur = 1, result = nwadrs(s_axe_rot_A, axeAB_subs)
	if diviseur = 2, result = nwadrs(s_axe_rot_B, axeAB_subs)			
	p_Z_dev
	
	# ---- pour Ajouter/Soustraire l angle du plan "en positionné"
	# ROTATION SUR X	& old_rotaxis <> 0, 
	if rotaxis$ = -2, axeAB_subs = ((axeAB_subs +180) - memo_AB_subs)* -1		#TYPE MC : SENS TRIGO sur X 
	if rotaxis$ = 2, axeAB_subs = axeAB_subs + memo_AB_subs						#TYPE MC : SENS HORAIRE sur X 	
	# ROTATION SUR Y
	if rotaxis$ = -1, axeAB_subs = ((axeAB_subs +180) - memo_AB_subs)* -1		#TYPE MC : SENS TRIGO sur Y 
	if rotaxis$ = 1, axeAB_subs = axeAB_subs - memo_AB_subs						#TYPE MC : SENS HORAIRE sur Y 
	if rot_AB_un_sens = 1, while axeAB_subs < 0, axeAB_subs = axeAB_subs +360
	delta_A_sub = old_axeA - axeAB_subs
	delta_A_sub = abs(delta_A_sub)
	
	if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0           						# diviseur tourne autour de Y (X sbstitue)
    if rotaxis$ = -2 | rotaxis$ = 2, yabs = 0                  					# diviseur tourne autour de X (Y sbstitue)
	
	if drillcyc$ >= 0, [
		# rotaxis$ = -2 OK avec les parcours --> les autres restent à définir
		if rotaxis$ = -1 | rotaxis$ = 1, axeAB_subs = (axeAB_subs + 360) * -1   # diviseur tourne autour de Y (X sbstitue)
		if rotaxis$ = -2, axeAB_subs = (axeAB_subs + 360) 						# diviseur tourne autour de X (Y sbstitue) ANTI-HORAIRE OK
		if rotaxis$ = 2, n$, "PROBLEME VEUILLEZ METTRE LE SENS EN ANTI-HORAIRE", e$
		]
			
p_Z_dev   # calcul du Z en substitution
	@z$, @rotdia$
	zabs  = z$ +(rotdia$ /2)    # Z pour continue substitution en ABS

p_calcul_rot_posit      # calcul rotation plateau
	@old_axeA, @nbrtour
    if diviseur = 1, axeA = atan2(m8$,m9$) + (360 * nbrtour)  # pour un diviseur tourne autour de X	
    if diviseur = 2, axeA = atan2(m7$,m9$) + (360 * nbrtour)  # pour un diviseur tourne autour de Y
    axeA = axeA * sens_A_B
    epsi = axeA - old_axeA
    sensA = 0
    if epsi > 0, sensA = 1
    if epsi < 0, sensA = -1
    epsi = abs(epsi)
    if Mode_reglage_PP = 0, n$, "--> p_calcul_rot_posit", "epsi", *epsi, "sensA", *sensA, "nbrtour", *nbrtour, e$
    @epsi, @sensA
    if epsi > 180, [
        axeA = axeA - (360 * sensA)
        epsi = axeA - old_axeA
        sensA = 0
        if epsi > 0, sensA = 1
        if epsi < 0, sensA = -1
        ]
    nbrtour = int (axeA / 360)
	memo_AB_subs = axeA
	if Mode_reglage_PP = 0,  "--> p_calcul_rot_posit div:", *diviseur, "old:", *old_axeA, "axe:", *axeA, "epsi:", *epsi, "sens:", *sensA, "nbrTour:", *nbrtour, e$

p_rotation_tlchg0_nul_continu   	# affichage de l'angle au chg outil nul pour continue
    #Perreur_origine_plan    		
    Perreur_nom_RUD         		
    perreur_tranf_plan      		
    if subout$ = 0, [           	# afficher les angles que dans le prog principal
       if useaxe <> 0, [
            @old_axeA, @axeA
            epsi = old_axeA - axeA
            epsi = abs(epsi)
            if Mode_reglage_PP = 0, n$, "--> p_rotation_tlchg0_nul_continu", "old:", *old_axeA, "axe:", *axeA, "epsi:", *epsi, e$
            if epsi <> 0,    [
                p_degage_4_axes, e$
                if mi7$ = 1, bloque = 2, n$, sbloque, e$			# déblocage de l'axe A/B  
                n$, "L", *axeA, "R0", sgcode, e$   #!axeAi,
                if mi7$ = 1, bloque = 1, n$, sbloque, e$     		# bloquer l'axe A/B
                ]
            ]
        old_axeA = axeA
        ]
#endregion

#region corps_Pheader_a_Peof

#region Pbloc_appelEs

#---------------------------------
P_f_val_origine_depart_idem 
    Old_Val_origine_Z = Val_origine_Z
    Old_Val_origine_Y = Val_origine_Y
    Old_Val_origine_X = Val_origine_X
    Sold_snom_RUD = snom_RUD

p_rot_perc_profond  # ROT BROCHE POUR PERCAGE PROFOND	
	if posi_p_prof = 1, 	# hors matière
		[
		ssa = ssa * 0.1
		if ssa > 500, ssa = 500
		]
	if posi_p_prof = 2, ssa = ss$	# dans la matière
   
p_Z_mini_maxi_OP
	if output_z = 1, [
		spaces$ = 1
		n$, s_com_open, "MAX OUTIL ", *max_depth, s_com_close, e$
    	n$, s_com_open, "MIN OUTIL ", *min_depth, s_com_close, e$	
		]

p_dec_renvoi_angle
	#20001
	#135.00 / 90.00 - Numéro porte-outil	#valeurs suivant ANGLES-DROIT 1-Horizontal et 2-Vertical 90= à plat
	#135.00 / 30.00 - Numéro porte-outil	#valeurs suivant ANGLES-CIRCULAIRE 1-Horizontal et 2-Vertical "5 AXES"
	#20008
	#0. 0. 1. 0 0. 0. 0 0. 29.99	29.99--> longueur de L'AXE Z à la FACE du PORTE PINCE (TOUT ANGLES)
	#1028
	#1 1 0.8660254 -0.5 0. -0.70710678 0.70710678 0. 222 0 0 0	
	#1029
	#0. 0. 0. 0. 0. 0. 1.999 2.999 3.999 0 0 	decalage renvoie X1.999 Y2.999 Z3.999	val-->11	0=fixe 1=rotatif
	#20007
	#0. 13. 41.99 27. 8. 50. 25. 0 100. 100. 1 41.99 25.	41.99 longueur sortie outil
	# PRMCODE --> # Nci 1029 val 11	0=fixe 1=rotatif 15813 à 15829
	#rotaxtyp$ = 4	#POINTS depuis la vue de dessus NE FONCTIONNE PAS EN V2023 !
	if m8$ = 1, n$, "G52 Y#599", e$		# suivant G18 XZ
	if m8$ = -1, n$, "G52 Y-#599", e$	# suivant G18 XZ		
	if m7$ = 1, n$, "G52 X#599", e$		# suivant G19 YZ
	if m7$ = -1, n$, "G52 X-#599", e$	# suivant G19 YZ
	#if m7$ <> 0 & m8$ <> 0, [
	   	Angle_PLAN_MC_renvoie_angle = atan2(-m8$,-m7$)	
		decX = (cos(Angle_PLAN_MC_renvoie_angle)*50) * -1
		decY = (sin(Angle_PLAN_MC_renvoie_angle)*50) #* -1	
		if ra_rot_head$ = 1, n$, s_com_open, "RENVOIE D ANGLE -CIRCULAIRE-", s_com_close, e$
		if ra_rot_head$ = 0, n$, s_com_open, "RENVOIE D ANGLE -FIXE-", s_com_close, e$
		n$, "Q510 = ", *Angle_PLAN_MC_renvoie_angle, s_com_open, "ANGLE A plat MasterCam", s_com_close, e$
		n$, "Q511 = (cos(Q510)*Q599) * -1", e$
		n$, "Q512 = (sin(Q510)*Q599) ", e$	
		n$, "CYCL DEF 7.0 POINT ZERO", e$
        n$, "CYCL DEF 7.1 Q511", e$
        n$, "CYCL DEF 7.2 Q512", e$
        n$, "CYCL DEF 7.3 0", e$
		n$, s_com_open, "DECALAGE CALCUL PP:", *decX, *decY, s_com_close, e$
		n$, s_com_open, "ANGLE DU PLAN= ", *Angle_PLAN_MC_renvoie_angle, s_com_close, e$
		n$, s_com_open, "INFOS DU PORTE OUTIL :", s_com_close, e$
		ANGLE_XY_renvoie_angle = atan2(ra_svecx$,-ra_svecy$)-90
		n$, s_com_open, "ANGLE PHYSIQUE XY = ", *ANGLE_XY_renvoie_angle, s_com_close, e$
		if ra_svecz$ = 0, ANGLE_Z_renvoie_angle = 90
		n$, s_com_open, "ANGLE PHYSIQUE A PLAT=90D :", *ANGLE_Z_renvoie_angle, s_com_close, e$
		n$, s_com_open, "NUM. du RENVOI MC= ", *ra_block$, s_com_close, e$
		n$, s_com_open, "0=FIXE 1=ROTATIF MC=", *ra_rot_head$, s_com_close, e$	# Nci 1029 val 11	0=fixe 1=rotatif
		n$, s_com_open, "TYPE DE RENVOI MC= ", *ra_type$, s_com_close, e$		# 0=No special HEAD 1= Right-Angle 2=Compound 3=Block drill 4=UST
		n$, " ", e$
		#]
	# Sauvegarde de la configuration avant de forcer la config avec le renvoie d'angle 
	old_usecandrill = usecandrill$    	# utiliser cycle percage lamage
    old_usecanpeck  = usecanpeck$    	# utiliser cycle debourrage
    old_usecanchip  = usecanchip$    	# utiliser cycle brise copeaux
    old_usecantap   = usecantap$    	# utiliser cycle taraudage
    old_usecanbore1 = usecanbore1$    	# utiliser cycle alesage a l'alesoir
    old_usecanbore2 = usecanbore2$    	# utiliser cycle alesage a la barre
    old_usecanmisc1 = usecanmisc1$    	# utiliser cycle divers 1
    old_usecanmisc2 = usecanmisc2$    	# utiliser cycle divers 2
	# Forcer cette configuration avec le renvoie d'angle
	usecandrill$ = 0   	# utiliser cycle percage lamage
	usecanpeck$  = 0   	# utiliser cycle debourrage
	usecanchip$  = 0   	# utiliser cycle brise copeaux
	usecantap$   = 0   	# utiliser cycle taraudage
	usecanbore1$ = 0   	# utiliser cycle alesage a l'alesoir
	usecanbore2$ = 0  	# utiliser cycle alesage a la barre
	usecanmisc1$ = 0	# utiliser cycle divers 1
	usecanmisc2$ = 0   	# utiliser cycle divers 2
	
	if ss$ > 2000, ss$ = S_maxi_renvoi_angle	
	sauve_ra_tc_type_ = ra_tc_type$ 
	sauve_ra_block_ = ra_block$
	p_erreur_num_block_renvoie_angle
	if ra_rot_head$ = 0, p_erreur_angles_renvoie_angle
	#if type_renvoie_angle = 2, p_erreur_angles_renvoie_angle_2 # SI CONTRAINTE ANGULAIRE exemple 4*90deg .... 
	old_Angle_PLAN_MC_renvoie_angle = Angle_PLAN_MC_renvoie_angle 
	
p_test_arcs_tete_renvoi
	if ra_type$ = 1 & ra_block$ >0, [
		if m8$ <> 1 & m8$ <> -1 & m7$ <> 1 & m7$ <> -1 & m9$ <> 1, linarc$ = 1		# Casse les arcs en lignes si pas G17-G18-G19
		else, linarc$ = 0
		]	

#endregion

#region pheader
p_Type_appel_outil
	if Type_appel_outil	= 1, [
		nom_outil    		= 0    	# Affiche le NOM de l'outil
		outils_param 		= 0    	# pour Valider / dévalider l'affichage des outils en parametres
		]
	if Type_appel_outil	= 2, [
		nom_outil    		= 1
		outils_param 		= 0
		]	
	if Type_appel_outil	= 3, [
		nom_outil    		= 0
		outils_param 		= 1
		]	
pheader$
    if Mode_reglage_PP = 0, [
		n$, *axis_label, *srot_label, *rot_zero, *rot_dir, *rot_index, *rot_angle, *rot_type, *min_speed, 
			*maxfrinv_m, *maxfrdeg, *maxfeedpm_m, *all_cool_off, *v9_coolant, e$
		]	
	if force_n0, # Force sequence numbering to START at '0' and increment by '1'
        [
        seqno$ = 0
        n$ = seqno$
        seqinc$ = 1
        ]
	debut = 1               # flag pour le debut de prog
	p_Type_appel_outil 
    entete_ = 1 # --> on passe dans ENTETE 
    p_affiche_infos_config_armoire	
	if utilise_palette = 1 | utilise_palette = 11, palette = 1
    if change_nom = 1,	[
        pnom_nc
        ptest_nom
        spaces$ = 0  
        snomprogentete = ucase(snomprogentete)
        n$, " BEGIN PGM ", snomprogentete, " MM", e$ 
        n$, " ; ", *snom_entete, e$    # snom_entete,
        spaces$ = 1 
        ]
    else, n$, " BEGIN PGM ", sprogname$, " MM", e$
	spaces$ = 1 
    n$, s_com_open, "*************************************", s_com_close, e$
	s_nom_machine_entete = ucase (s_nom_machine_entete)
	n$, s_com_open, "MASTERCAM BY FICAM - POST V:", no_spc$, scustpost_revision, s_com_close, e$
	n$, s_com_open, "MACHINE:", s_nom_machine_entete, s_com_close, e$
	if rotation_A = 1 & diviseur = 1, n$, s_com_open, "EQUIPEE D UN AXE :", s_axe_rot_A, s_com_close, e$
	if rotation_B = 1 & diviseur = 2, n$, s_com_open, "EQUIPEE D UN AXE :", s_axe_rot_B, s_com_close, e$
	n$, s_com_open, "PROGRAMME CREE LE ", date$, " A ", time$, s_com_close, e$
	if nom_programmeur_PC <> 0, [
		s_nom_ORDI = sysinfo(result, 2)
		posi_nom_programmeur = strstr(s_slash, s_nom_ORDI)
		posi_nom_programmeur = posi_nom_programmeur + 1
		s_nom_programmeur = brksps(posi_nom_programmeur, s_nom_ORDI)
		posi_nom_programmeur = posi_nom_programmeur - 2
		s_nom_ORDI2 = brksps(posi_nom_programmeur, s_nom_ORDI)
		s_nom_ORDI = ucase (s_nom_ORDI)
		s_nom_programmeur = ucase (s_nom_programmeur)
		if nom_programmeur_PC <> 1, n$, s_com_open, "NOM DE L'ORDINATEUR :", *s_nom_ORDI, s_com_close, e$
		if nom_programmeur_PC <> 2, n$, s_com_open, "NOM DU PROGRAMMEUR :", *s_nom_programmeur, s_com_close, e$		
		]	
	n$, s_com_open, "*************************************", s_com_close, e$
	n$, s_com_open, "FICHIER MC: ", *smcname$, no_spc$, *smcext$, s_com_close, e$
    n$, s_com_open, "FICHIER ISO: ", *snamenc$, no_spc$, *sextnc$, s_com_close, e$
	if entete_questions = 2, p_questions_entete     # nouvelles questions d'entête
    if entete_questions = 3, p_entete_questions_3   # ANCIEN SYSTEME questions
    if entete_questions = 1,	[					# Depuis une OP NOTE 
        if entete_ = 1 & longTexte = 0,    [
            n$, "; *****************************", e$
            n$, "; *****OP POUR MODIF*****", e$       
            ]
        ]
    spaces$ = 1
    if Liste_outils, [
		n$, ";", e$
    	n$, "; *LISTE D OUTILS*", e$
		]
    if outils_param = 1, [
        n$, "; MODIFIER LES NUMEROS D OUTILS", e$
        n$, "; UNIQUEMENT DANS LA LISTE D OUTILS APRES LE =", e$
        n$, "; NE PAS MODIFIER DANS LES -TOOL CALL- DU PROGRAMME", e$
        n$, ";", e$
        if appel_param_outils = 1, n$, "LBL 999", e$
        ]
    entete_ = 0 
#endregion

#region prEparation outils en NOM 
# Tool Preselect variables
next_tlchg_gcode   	: 0
is_next_tlchg_phys 	: no$
sinvalid          	= "-99999"
read_counter 		: 0     #Used as a counter in pstagetool
first_op_id  		: 0     #op_id$ for first operation
#strings
stoolname    		: ""    #Return string for functions
#sblank       		: ""
s_plus_outil 		: "-99999"
stoolname_err      	: "ERREUR - OUTIL APPELE SANS NOM." + no2asc(13) + no2asc(13) +
                       "See tool_as_name in pst to set tool call format and tool definition in operation to set tool name."
#endregion	

#region appel_outils
pstagetool      #Pre-stage tools	# en plus pour afficher le NOM DE L'OUTIL SUIVANT
    if bldnxtool$ = 1, [
        if nom_outil = 1,  #Tool call uses tool name
          [  
          if ttblend$,  #If this is the last toolchange of the program
            [
            if type_prep_outil = 1,  #stage first tool at last toolchange
              [
              first_op_id = streaminfo(1, 1)             #Get the operation ID for the first operation in the sequence
              stoolname = opinfo(10094, first_op_id, 1)  #Get the tool name for the first operation
              if stoolname = sblank, stoolname = "ERROR-BLANK_NAME"
              n$, 'TOOL DEF "', no_spc$, stoolname, no_spc$, '"', e$  #Stage first tool
              ]
            ]        
		  #else,  #stage tool at every toolchange
            #[
			next_tlchg_gcode = opinfo(92, 1)
            if next_tlchg_gcode = 1002, stoolname = opinfo(10094, 1)
            else,	[
            read_counter = 1
              is_next_tlchg_phys = no$
              while is_next_tlchg_phys = no$,
              [
              read_counter = read_counter + 1
                next_tlchg_gcode = opinfo(92, read_counter)
                if next_tlchg_gcode = 1000, is_next_tlchg_phys = no$
                else,
                  [
                  stoolname = opinfo(10094, read_counter)
                  is_next_tlchg_phys = yes$
                  ]
                ]
              ]
            if stoolname = sblank, stoolname = "ERREUR-OUTIL SANS NOM"
            if stoolname <> s_plus_outil, n$, 'TOOL DEF "', no_spc$, stoolname, no_spc$, '"',  e$  #Stage first tool
            #]
          ]
        ]

p_info_outils
	strtool$ = ucase(strtool$)
	if Type_infos_outil	= 1, n$, "* - ", strtool$, e$
	if Type_infos_outil	= 2, n$, "* - ", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$ 
	if Type_infos_outil	= 3, n$, "* - ", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$ 
	if Type_infos_outil	= 4, n$, "* - ", strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$ 

p_affiche_outil
    if test_bris_outils = 1 & (mi6$ = 1 | mi6$ = 3), p_test_bris_outil 
	if ra_tc_type$ <> 2, [	#pas de renvois d'angle et mode de changemnt automatique
		if nom_outil = 1, [
			n$, "TOOL CALL ", 34, no_spc$, strtool$, no_spc$, 34, "Z", [if nextdc$ < 8 | nextdc$ > 18, *ssa], p_DR, e$
			if rpd_typ$ <> 7, [	
				if affiche_M6, n$, "M6", e$
				if bldnxtool$ = 1, [	#pstagetool
					if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, pstagetool
					]
				]
			]
		if outils_param = 0 & nom_outil = 0, [  				# sans les parametres
	        n$, "TOOL CALL ", t$, "Z", [if nextdc$ < 8 | nextdc$ > 18, *ssa], p_DR, e$		
			if rpd_typ$ <> 7, [	
				if affiche_M6, n$, "M6", e$
				if bldnxtool$ = 1, [ 
					#(ra_type$ = 0 & outil_suivant < 61 & outil_suivant > 63), n$, "TOOL DEF ", next_tool$, e$
					if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, n$, "TOOL DEF ", next_tool$, e$
					]
				]
	        ]
	    if outils_param = 1 & nom_outil = 0, [ 					# AVEC les parametres
	        if appel_param_outils = 1, n$, "CALL LBL 999", e$
	        outil_paramT2 = t$ + 1800   
	        next_tool_ = next_tool$ + 1800  
	        n$, "TOOL CALL", *outil_paramT2, "Z", [if nextdc$ < 8 | nextdc$ > 18, *ssa], p_DR, e$
	        if rpd_typ$ <> 7, [	
				if affiche_M6, n$, "M6", e$
				if bldnxtool$ = 1, [
					#(ra_type$ = 0 & next_tool$ < 61 & next_tool$ > 63), n$, "TOOL DEF", next_tool_, e$ 
					if ra_type$ = 1 & prepa_out_renvoi = 1 | ra_type$ = 0, n$, "TOOL DEF", next_tool_, e$ 
					]			
				]
	        ]
		]
	if ra_tc_type$ = 2, [	#renvois d'angle à changement manuel
		n$, s_com_open, "OUTIL A RENVOIE D ANGLE A CHARGER MANUELLEMENT", s_com_close, e$
		n$, sm00, e$
		n$, s_com_open, "OUTIL NUMERO : ", *t$, s_com_close, e$
		]	
	if program_stop = 11, pcan1, "/", n$, sm00, e$
    if program_stop = 22, pcan1, "/", n$, sm01, e$
	if ra_type$ = 1 & ra_block$ >0, [	# 1 =renvoie d'angle actif et NUM choix du multibroche
		lg_port_out_outil_block = paramT49 + paramT22
		n$, "Q599 =", *lg_port_out_outil_block,  s_com_open, "LONGUEUR TOTALE DU PORTE OUTIL ET OUTIL :RENVOI D ANGLE ", s_com_close, e$
		n$, s_com_open, "DEPUIS L AXE BROCHE AU BOUT D OUTIL", s_com_close, e$
		n$, s_com_open, "POUR INFO, LONG. DE SORTIE OUTIL SOUS LA PINCE:", *paramT22, s_com_close, e$
		n$, s_com_open, "COTE DEPUIS L AXE Z A LA FACE DU PORTE OUTIL:", *paramT49, s_com_close, e$
		p_dec_renvoi_angle 
		]
	old_t = t$
	old_ssa = ssa       
    perreur_vit_broche
	
p_DR	# USURE-INVERSE pour la SIMULATION 
	if use_DR = 1, [		
        if Type_Comp_OP = 2 | Type_Comp_OP = 3, [
			DR = 0
			DR = tldia$/-2
        	*DR
			]
         ]
		 
#region correction_rayon
# -------------------------LECTURE DES PARAMETRES DE surep_XY_2D ET DE TYPE DE CORRECTION--------------------------------------------
param_comp   # Type de correction d'outil au changement d'operation	--- TEXTE
    if info_corr = 1, [
        if op_id$ <> old_op_id, [       
			#cc_comp 41 42 0
	        #cc_pos   1  2 0
	        @cc_computer$, @cc_pos$, @cc$                  		# rappel des variables
			#*cc$, *cc_pos$, *cc_computer$, *opcode$, *tool_op$, e$
	        if cc$ = 0 & cc_computer$ = 0, type_comp = 0    #AUCUNE
	        if cc$ = 42 & cc_computer$ = 0, type_comp = 1   #ARMOIRE DROITE
	        if cc$ = 41 & cc_computer$ = 0, type_comp = 2   #ARMOIRE GAUCHE
	        if cc$ = 0 & cc_computer$ = 42, type_comp = 3   #ORDINATEUR DROITE
	        if cc$ = 0 & cc_computer$ = 41, type_comp = 4   #ORDINATEUR GAUCHE
	        if cc$ = 42 & cc_computer$ = 42, type_comp = 5  #USURE DROITE
	        if cc$ = 41 & cc_computer$ = 41, type_comp = 6  #USURE GAUCHE
	        if cc$ = 41 & cc_computer$ = 42, type_comp = 7  #USURE INVERSE DROITE
	        if cc$ = 42 & cc_computer$ = 41, type_comp = 8  #USURE INVERSE GAUCHE
			# filetages à la fraise --> bricollage
			if cc$ = 41 & cc_computer$ = 42 & tool_op$ = 100, type_comp = 6	#USURE GAUCHE
			#
	        if opcode$ = 19, type_comp = 0           							# mis sur aucune a la place d'ordinateur
	        if opcode$ <> 3 & opcode$ <> 16, n$, s_com_open, *stype_comp, s_com_close, e$   # pour ne pas afficher si percage
	        ]
    	]
#endregion

#region Surepaisseurs
param_surep
    if info_surep = 1,	[
		# surep XY & Z OPs 2D 
		if opcode$ <> 3 & opcode$ < 5  & opcode$ <> 19,	[	
            if (surep_XY_2D <> old_surep_XY_2D) | (surep_Z_2D <> old_surep_Z_2D),	[
                n$, s_com_open, *surep_XY_2D, s_com_close, e$
                n$, s_com_open, *surep_Z_2D, s_com_close, e$
				old_surep_XY_2D = surep_XY_2D
	    		old_surep_Z_2D = surep_Z_2D
                ]
            ]
        # surep 3d
		if opcode$ <> 3 & opcode$ >= 5 & opcode$ <> 19, [
            if surep_XY_3D <> old_surep_XY_3D, n$, s_com_open, *surep_XY_3D, s_com_close, e$
            if surep_Z_3D <> 0, n$, s_com_open, *surep_Z_3D, s_com_close, e$
			old_surep_XY_3D = surep_XY_3D
			old_surep_Z_3D = surep_Z_3D
			]
        # surep pour surfaçage
		if opcode$ = 19, [
            if surep_Z_surf_2D <> old_surep_Z_2D, n$, s_com_open, *surep_Z_surf_2D, s_com_close, e$
            old_surep_Z_2D = surep_Z_surf_2D
			]         		
		]  
#endregion

#region psof_debut
p_palette_debut
	if utilise_palette > 0, [	# PALETTES
	 	if useaxe = 1, [		# VALEURS UNIQUEMENT SI ON UTILISE L AXE A
			if deg_palette_deb_fin > 0, [
				old_degageX    	= degageX
				old_degageY    	= degageY
				old_degageZ    	= degageZ			
				degageX    		= degageX_pal
				degageY    		= degageY_pal
				degageZ    		= degageZ_pal
				deg_debut 		= deg_palette_deb_fin
				p_degage_debut
				degageX    		= old_degageX
				degageY    		= old_degageY
				degageZ    		= old_degageZ				
				]
			n$, "TOOL CALL 0 Z", [if affiche_M6, "M6"], s_com_open, "DECHARGE DE L'OUTIL EN BROCHE", s_com_close, e$
			n$, s_com_open, "POUR ROTATION PALETTE AVEC L AXE -A-B-", s_com_close, e$
			]
		if Var_16_question > 0, n$, "M127", s_com_open, "ROTATION PALETTE A", s_com_close, e$
		if Var_17_question > 0, n$, "M128", s_com_open, "ROTATION PALETTE B", s_com_close, e$
		n$, "M44", s_com_open, "RIDEAUX EAU ON", s_com_close, e$
		#n$, "G0 G17 G49 G80 G90", e$
		]	

psof0$			# DEBUT DE PROGRAMME pour T=0
    psof$

fmt  "OP. MC. :" 4 op_number  #Operation number as seen in the Operations Manager
p_num_op_MC	
	if affiche_num_op_MC = 1, [ 
		sOpId = no2str(op_id$)
		result = dll(sdllTimeOp,sOpId)
		if spost_arg_2$ <> s_old_spost_arg_2, n$, s_com_open, "OP. MC. :", spost_arg_2$, s_com_close, e$
		s_old_spost_arg_2 = spost_arg_2$
		]
	#if affiche_num_op_MC = 2, if comm_cnt$ = zero, n$, s_com_open, *op_number, scomm$, s_com_close, e$  #Comment using MSG("") - When no op comment was entered, output just the op number
	if affiche_num_op_MC = 2, n$, s_com_open, *op_number, s_com_close, e$  #Comment using MSG("") - When no op comment was entered, output just the op number

p_affiche_type_op_MC
	if affiche_type_op_MC = 1 & affiche_type_op_MC <> old_affiche_type_op_MC, 
		[
		if tool_op$ > 99 & tool_op$ < 109, tool_op$ = tool_op$ + 18
		if tool_op$ > 200 & tool_op$ < 240, tool_op$ = tool_op$ + 83
		if tool_op$ > 415 & tool_op$ < 462, tool_op$ = tool_op$ + 77
		n$, s_com_open, *s_too_lop, s_com_close, e$ 
		old_affiche_type_op_MC = affiche_type_op_MC	
		!tool_op$ 
		]
					
psof$			# DEBUT DE PROGRAMME T<>0
    p_restriction_PP
	P_f_val_origine_depart_idem 
    perreur_pas_fil  
    p_erreur_dif_T_H_D 
    if rotation_axe = 2, result = mprint(serreur2)
    if Mode_reglage_PP = 0, [
         "************A:", *rotation_A, " B:", *rotation_B, " rotation gEnErale", *rotation_axe, " div:" *diviseur, e$
        " syncax", *syncaxis$, " old_sync", *old_syncaxis, " nbr_combi", *nbr_combi, " compt_axes_rot", *compt_axes_rot, e$
        " M1", *m1$, " M5", *m5$, " M7", *m7$, " M8", *m8$, " M9", *m9$, e$
		]
    if lire_def_machine = 0, [                                    # affecter les valeurs suivant inclinaisons du programme
        if rotation_A = 1, [
            if diviseur = 2, p_erreur_choix_axe
            diviseur = 1, useaxe = 1
            ]
        if rotation_B = 1, [
            if diviseur = 1, p_erreur_choix_axe
            diviseur = 2, useaxe = 1
            ]
        ]
	if rotation_A =1 | rotation_B =1 & rotation_axe = 1, useaxe = 1
		else, useaxe = 0
	if lire_def_machine = 1, [
		if diviseur = 1 & rotation_B = 1, result = mprint(serreur3)	# erreur: rotation sur B avec du A
		if diviseur = 2 & rotation_A = 1, result = mprint(serreur4) # erreur: rotation sur A avec du B
		]
	if rotation_A = 1, result = nwadrs(s_axe_rot_A, axeA)
	if rotation_B = 1, result = nwadrs(s_axe_rot_B, axeA)
	# TEMPS
	info_temps = 2, p_temps_affectation
	if Affiche_temps_dll = 1, [ 	# TEMPS DE L OUTIL			
		if Types_Temps_DLL = 2, [
			p_Convert_time_dll 
			n$, "  ", s_com_open, "TPS OUT. = ", *Heure, *min, *sec, s_com_close, e$
			]	
		]	
	info_temps = 3, p_temps_affectation
	if Affiche_temps_dll = 1 & Types_Temps_DLL = 3, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS BRUT TOTAL MC ", *Heure, *min, *sec, s_com_close, e$	
		]
	time_total = 0
	Tot_time_Out = 0	
	#
    if outils_param = 1 & appel_param_outils = 1, n$, "LBL 0", e$
    spaces$ = 0
    n$, "  ", e$
	if affiche_ori_entete = 1, mergesub$							# ICI les origines utilisés par MC (depuis pwrtt$)
	if affiche_ori_entete = 11 & compteur_workofs > 1, mergesub$	# ICI les origines utilisés par MC (depuis pwrtt$)
	if affiche_ori_entete = 1 | affiche_ori_entete = 11, clearsub$	# Sup. des origines dans la mémoire
	spaces$ = 1
    n$, ";", e$
    if block_form, p_block_form
    n$, ";", e$
	# ICI descripteur si actif dans la machine et config PP
	comment$ 
	debut = 2	#pour le 1er cycle 247
	#
	ptravel
    pwritbuf5
	if output_z = 1, n$, s_com_open, "TRAVAIL MAX PIECE ", *z_tmax, s_com_close, e$
    if output_z = 1, n$, s_com_open, "TRAVAIL MIN PIECE ", *z_tmin, s_com_close, e$
    spaces$ = 1
	#old_mi1 = - 2			# force l'affichage du cycle 247 au départ
	old_workofs = - 2		# pas de DEF 7 tout en haut
	if convoyeur = 1, n$, s_convoyeur_ON, e$
	p_palette_debut	# PALETTES
	p_ori_usi
	debut = 0
	n$, ";", e$
    n$, "CYCL DEF 32.0 TOLERANCE", e$
    n$, "CYCL DEF 32.1 T0.02", e$
    n$, "CYCL DEF 32.2 HSC-MODE:0 TA0.02", e$
    n$, ";", e$
	p_degage_debut
	comment$ 
    gcode$ = 0
    ssa = abs(ss$)  
	if ra_type$ = 1 & ra_block$ >0 & ssa > S_maxi_renvoi_angle, result = mprint(s_erreur_S_maxi_renvoi_angle), ssa = S_maxi_renvoi_angle
    if nextdc$ = 19, posi_p_prof = 1, p_rot_perc_profond  # ROT BROCHE POUR PERCAGE PROFOND
    pnomgroupe 
	p_num_op_MC
	p_affiche_type_op_MC  
	if Position_info_outil = 1, p_info_outils
	p_affiche_outil
	if Position_info_outil = 2, p_info_outils
	#temps DLL
	Tot_time_op = 0	#remise à 0 entre l'entete et OPs
	Types_Temps_DLL = plcval (s_Types_Temps_DLL, 4)
	p_temps_dll	# lecture du temps de l'OP dans la DLL
    #
    spaces$=0
    p_Z_mini_maxi_OP
    spaces$ = 1
    n$, ";", e$  
	param_comp                        			
    param_surep
	#old_mi1 = -2	# force l'affichage du cycle 247 au 1ER outil
    old_workofs = -1
	p_ori_usi 
    pfrvar
	if tool_op$ = 114, cant_no$ = 0 #tool_op$ 114 = perCage AVANCE #pour ne pas afficher un arrosage erroné au debut
	pcan # arrosages vx et textes
    p_placement_apres_chang_outil
	p_test_arcs_tete_renvoi
	if opcode$ = 16, drill_4_axes = 1 
    old_rotaxis = rotaxis$
    old_x = xabs
    old_y = yabs
    old_z = zabs
	old_op_id = op_id$
	#time
	old_x = xh$ 
	old_y = yh$
	old_z = zh$
	p_erreur_choix_axe_substitution	
	c_mmlt$     # Multiple tool subprogram call
	c_msng$ 	# Single tool subprogram call
#endregion

#region placement_apres_chang_outil
p_placement_apres_chang_outil
	if Mode_reglage_PP = 0, "--> p_placement_apres_chang_outil", e$
	@rotaxis$                   		# mise a jour du type de substitution d'axe
	if nextop$ = 11, [   				# si  4 axes avec fonction 5 axes
		gcode$ = 0              		# Force le gcode a 0 pour faire un G0 apres
        x$ = xr$
        y$ = yr$
        z$ = zr$
        axeA = 0
        axeA1_dep = 0
        old_axeA1 = 0
        debutpmx = 1					# flag pour faire l'appel outil
        ]
    
	# en plus par rapport au pp Fanuc !!?? ---> ne passe pas dans le pmx$ ????
	if opcode$ = 16,    [       		# perçage 5 axes		
		#p_debut_pmx
        ]

	if nextop$ <> 11, [  				# utilisation en positionné ou substitution
        gcode$ = 0       				# Force le gcode a 0 pour faire un G0 apres
        x$ = xr$						# prise en compte de XYZ
        y$ = yr$
        z$ = zr$
        xabs = x$
        yabs = y$
        zabs = z$
        !x$, !y$, !z$, !xabs, !yabs, !zabs, e$      	#!xinc, !yinc, !zinc,  mise a jour des position
		n$, p_lubrif_ON, e$ 
		if ra_block$ >0, p_calcul_xyz_tete_renvoie 		# RENVOIE D'ANGLE
        if rotaxis$ = 0, [       						# 4 axes positionnés OU à PLAT(dessus)
            if diviseur <> 0 & rotation_axe <> -9999, [
                p_calcul_rot_posit
                old_axeA = memo_old_axeA
                p_rotation_tlchg
                ]
			p_bloc_O, n$, "L", *xabs, *yabs, *sgcode, [ if nextdc$ <> 18, p_lubrif_ON ], strcantext, e$
			pcan2
            if nextdc$ < 8 | nextdc$ > 19, p_bloc_O, n$, *spdlon, e$	# ROT BROCHE SAUF BROSSE, PALPAGES & PERCAGE PROFOND		   
            p_bloc_O, n$, "L", *zr$, *sgcode, strcantext, e$
            ]
        if rotaxis$ <> 0, [      # en substitution (mouvement en Z)
            !zdev, #!zdevi
            #zabs = zdev
			p_calcul_rot_posit 				#CALCUL PLAN A AJOUTER/ENLEVER
            p_calcul_AB_pos_Subs      
			if rotaxis$ = -1 | rotaxis$ = 1, xabs = 0   	# 4 axes continues en substitution diviseur tourne autour de Y (X sbstitue)
			if rotaxis$ = -2 | rotaxis$ = 2, yabs = 0     	# 4 axes continues en substitution diviseur tourne autour de X (Y sbstitue)  
			if mi7$ = 1, bloque = 2, n$, sbloque, e$		# déblocage de l'axe A/B  
			p_bloc_O, n$, "L", *axeAB_subs, *sgcode, e$  #sinc_abs, !A_posi,
			if mi7$ = 1, bloque = 1, n$, sbloque, e$					# si ROT - Bloque
	        pcan1, p_bloc_O, n$, "L", *xabs, *yabs, !xr$, !yr$, sgcode, p_lubrif_ON, strcantext, e$ 	
			pcan2
			if nextdc$ < 8 | nextdc$ > 19, p_bloc_O, n$, "L", *spdlon, e$  	# ROT BROCHE SAUF BROSSE, PALPAGES & PERCAGE PROFOND		 
            p_bloc_O, n$, "L", *zabs, *sgcode, !zr$, strcantext, e$   #*zabs,
            ]
        ]
	if tool_op$ = 100, p_bloc_O, n$, ";PAS DU FILETAGE = ", *pas_filetage, e$ # affichage de la valeur du vrai filetage
#endregion

#region ptlchg0	
ptlchg0$
    @rotaxis$, @old_rotaxis
    gcode$ = 0
    Perreur_nom_RUD  
    p_erreur_dif_T_H_D
    perreur_pas_fil
	drill_4_axes = 0 
    if Mode_reglage_PP = 0, "syncax", *syncaxis$, "old_syn", *old_syncaxis, "nbr_combi", *nbr_combi, "erreur", *erreur, "compt_axes_rot", *compt_axes_rot, e$
	pcan # arrosages vx et textes
	if Test_bris_outils = 1, [
		pcool_off 
		n$, *sm_01, e$
		p_test_bris_outil
		pcan1_cool
		#if coolant$ = 0 | coolant$ = 1 & lub_centre = 0, n$, "M8", e$
		#if coolant$ = 2 , "M88" ,e$
		n$, *spdlon, *ssa, e$
		] 
	if op_id$ <> old_op_id, [	
		#temps DLL	
		info_temps = 4, p_temps_affectation
	    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
			p_Convert_time_dll
			n$, s_com_open, "TEMPS DE L OPE. = ", *Heure, *min, *sec, s_com_close, e$
			]
		p_temps_dll
		# 
	    pnomgroupe                          # Nom du groupe d'operation
	    p_num_op_MC
		p_affiche_type_op_MC
		param_comp                        	# afficher le type de compensation
		param_surep
		]
	affiche_m0 = 1
	comment$ 
    ssa = ss$ 
    pspindchng
    #if M_zero = 1, n$, *spdlon, e$, old_lubrif = -1, M_zero = 0
    #if coolant$ <> old_lubrif & drlcst7 = 0, n$, p_lubrif_ON, e$ #PAS AVEC PERCAGE TRES PROFOND
	if old_lubrif <> -1 & op_id$ <> old_op_id, n$, p_lubrif_ON, e$
    pfrvar
	if ra_type$ = 1 & ra_block$ >0, [				# Renvoi d'ANGLE
		Angle_PLAN_MC_renvoie_angle = atan2(-m8$,-m7$)
		if Angle_PLAN_MC_renvoie_angle <> old_Angle_PLAN_MC_renvoie_angle, [
			if type_renvoie_angle = 9, result = mprint(s_erreur_angle_renvoi_fixe) 
			p_degage_4_axes
			n$, "TRANS X0 Y0 Z0", e$
			p_dec_renvoi_angle     					# 1 =renvoie d'angle actif et NUM choix du multibroche
			]
		]
    if nextop$ <> 11, [      # = positionné    Si pas en 5 axes      
		x$ = xr$
        y$ = yr$
        z$ = zr$
        xabs = x$
        yabs = y$
        zabs = z$
        if rotaxis$ = 0, [  # 4 axes positionné
            if diviseur <> 0 & rotation_axe <> -9999, [
                p_calcul_rot_posit
                p_rot_tlchg0
                ]
            ]
        if rotaxis$ <> 0, 	# si on passe de positionné à SUBSTITUTION
			[
			p_calcul_rot_posit 
			!x$,!y$,!z$
            p_calcul_AB_pos_Subs
            axeA = axeAB_subs
            p_rotation_tlchg0_nul_continu
            !axeAB_subs
            !A_posi
			]	
        if (rotaxis$ = 1 & old_rotaxis <> 1) | (rotaxis$ = -1 & old_rotaxis <> -1), [  # 4 axe continues en substitution diviseur tourne autour de Y (X sbstitue) 
            n$, "L", sgcode, "X0.", *yr$, e$   #!yinc,
            n$, "L", sgcode, zdev, strcantext, !z$, e$ #!zdevi,  !zinc,
            ]
         if (rotaxis$ = 2 & old_rotaxis <> 2) | (rotaxis$ = -2 & old_rotaxis <> -2), [  # 4 axes continues en substitution diviseur tourne autour de X (Y sbstitue)
            n$, "L", sgcode, *xr$, "Y0.", e$   #!xinc,
            n$, "L", sgcode, zdev, strcantext, !z$, e$ #!zinc, !zdevi,
            ]
        ]
    if nextop$ = 11, [   # si 5 axes
		if op_id$ <> old_op_id, [
	        old_axeA1 = 0
	        axeA1_dep = 0
	        ]
    	]
    if opcode$ = 16, drill_4_axes = 1
	p_ori_usi  
    c_mmlt$     # Multiple tool subprogram call
	c_msng$		# Single tool subprogram call
    old_rotaxis = rotaxis$
	old_op_id = op_id$
#endregion

#region ptlchg
#Toolchange setup
pspindle        #Spindle speed calculations for RPM
	ssa = abs(ss$)
	@old_ssa 
	if ssa, [
		if ssa > maxss$, ssa = maxss$
		if ssa < min_speed, ssa = min_speed
		]
	spdir2 = fsg3(spdir$) 
	
pspindchng      #Spindle speed change
	if prv_spdir2 <> spdir2 & old_ssa <> zero, p_bloc_O, n$, *sm_01, e$
	if old_ssa <> ssa | prv_spdir2 <> spdir2, [
		if ssa <> 0, [
			n$, "; POUR AUTRE ROTATION DE BROCHE", e$
	 		n$, "TOOL CALL ", ssa, e$
			]	
		if spdir2 <> 1, n$, *spdlon, e$
		old_ssa = ssa
		]
	if tool_op$ <> 114, perreur_vit_broche
	!ssa, !spdir2
	
ptoolend$        #End of tool path, before reading new tool data
	!ssa, !spdir2
	Test_bris_outils = mi6$

ptlchg$	
	increment_op_outil = 1 
    pas = 0
    memo_old_axeA = old_axeA
    if nbrtour <> 0, [         # pour remise a zero du diviseur
        old_axeA = 0
        axeA = 0
        nbrtour = 0
        ]
	n$, *sm_01, e$
    p_lubrif_OFF
	if Test_bris_outils = 1, p_test_bris_outil 
	if sauve_ra_block_ >0, [				# Annulation du décallage FIN du renvoie d'angle  
		n$, "CYCL DEF 7.0 POINT ZERO", e$
        n$, "CYCL DEF 7.1 0", e$
        n$, "CYCL DEF 7.2 0", e$
        n$, "CYCL DEF 7.3 0", e$
		usecandrill$ = old_usecandrill
	    usecanpeck$  = old_usecanpeck
	    usecanchip$  = old_usecanchip
	    usecantap$   = old_usecantap
	    usecanbore1$ = old_usecanbore1
	    usecanbore2$ = old_usecanbore2
	    usecanmisc1$ = old_usecanmisc1
	    usecanmisc2$ = old_usecanmisc2	
		#p_cycles_valides					# réactives les cycles utilisables après le Renvoi
		sauve_ra_block_ = 2 	
		]	
	p_ori_usi_annul
	p_degage_ptlchg				
	old_lubrif = -1
	gcode$ = 0
	if program_stop = 1, pcan1, "/", n$, sm00, e$
    if program_stop = 2, pcan1, "/", n$, sm01, e$
    if sauve_ra_tc_type_ = 2 & sauve_ra_block_ = 2, n$, sm00, s_com_open, "VEUILLEZ RETIRER L'OUTIL MANUELLEMENT", s_com_close, e$, sauve_ra_block_ = -1	
	#temps DLL
	info_temps = 4, p_temps_affectation	
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS DE L OPE. = ", *Heure, *min, *sec, s_com_close, e$
		]  
	info_temps = 5, p_temps_affectation
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 5, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS DE L OUTIL= ", *Heure, *min, *sec, s_com_close, e$
		Tot_time_op = 0
		Tot_time_Out = 0	
		]			
	#
	n$, " ", e$
    comment$
    ssa = abs(ss$)
	if ra_type$ = 1 & ra_block$ >0 & ssa > 2000, result = mprint(s_erreur_S_maxi_renvoi_angle), ssa = 2000
    if nextdc$ = 19, posi_p_prof = 1, p_rot_perc_profond  # ROT BROCHE POUR PERCAGE PROFOND
    pnomgroupe
	p_num_op_MC 
	p_affiche_type_op_MC
	if Position_info_outil = 1, p_info_outils
	p_affiche_outil
	if Position_info_outil = 2, p_info_outils
	#temps DLL
	Types_Temps_DLL = plcval (s_Types_Temps_DLL, 4)
	p_temps_dll	# lecture du temps de l'OP dans la DLL		
   	#
	if deg_apres_outil > 0, [
		old_type_deg = deg_outil		# Memo Valeur
		deg_outil = deg_apres_outil		# Affectation pour Valeur deg. apres outil
		p_degage_ptlchg					# Retour suivant Valeur deg. apres outil	
		deg_apres_outil = old_type_deg	# Réaffectation de la valeur de base
		]
    spaces$=0
    p_Z_mini_maxi_OP
    spaces$ = 1
	pcan # arrosages vx et textes
    n$, ";", e$
    perreur_pas_fil  
    perreur_num_outil   
    p_erreur_dif_T_H_D 
	param_comp
    param_surep
	#old_mi1 = -2	# force l'affichage du cycle 247 au tlchg
	old_workofs = -1
	p_ori_usi
	if opcode$ = 16, drill_4_axes = 1
    debut_out = 1    
    pfrvar
	if tool_op$ = 114, cant_no$ = 0 #pour ne pas afficher un arrosage erroné au debut
	pcan
	p_placement_apres_chang_outil
	p_test_arcs_tete_renvoi
    c_mmlt$     # Multiple tool subprogram call
	c_msng$		# Single tool subprogram call
    old_rotaxis = rotaxis$
    old_x = xabs
    old_y = yabs
    old_z = zabs
#endregion

#region peof_fin
p_palette_fin
	if utilise_palette > 0, [
		if useaxe = 1, [
			n$, "TOOL CALL 0 Z", [if affiche_M6, "M6"], s_com_open, "DECHARGE DE L'OUTIL EN BROCHE", s_com_close, e$
			n$, s_com_open, "POUR ROTATION PALETTE AVEC L AXE -A-", s_com_close, e$
			]
		n$, "M45", s_com_open, "RIDEAUX EAU OFF", s_com_close, e$
		if useaxe = 1, [
			if deg_palette_deb_fin > 0, [
				old_degageX     = degageX
                old_degageY     = degageY
                old_degageZ     = degageZ
                degageX        	= degageX_pal
                degageY        	= degageY_pal
                degageZ        	= degageZ_pal
                deg_fin 		= deg_palette_deb_fin
                p_degage_fin
                degageX        	= old_degageX
                degageY        	= old_degageY
                degageZ        	= old_degageZ
				]
			]	
		if Var_16_question > 0, n$, "M128", s_com_open, "RETOUR ROTATION PALETTE B", s_com_close, e$
		if Var_17_question > 0, n$, "M127", s_com_open, "RETOUR ROTATION PALETTE A", s_com_close, e$
		if useaxe = 1, p_degage_fin
		# COMPTEURS FANUC PALETTES
		if Var_16_question > 0, n$, s_com_open, "#500=#500+", no_spc$, *Var_16_question, s_com_open, "COMPTEUR PALETTE A", s_com_close, e$
		if Var_17_question > 0, n$, s_com_open, "#500=#500+", no_spc$, *Var_17_question, s_com_open, "COMPTEUR PALETTE B", s_com_close, e$
		if Var_16_question > 0 & Var_17_question > 0, result = mprint(s_erreur_choix_palette)
		if Var_16_question < 1 & Var_17_question < 1, result = mprint(s_erreur_choix_palette)
		]

peof0$
    peof$

peof$	 
	#zabs = z$, gcode$ =0, n$, *sgcode, *zabs, e$
    #if tool_op$ <> 114, p_lubrif_OFF
	p_lubrif_OFF
	if sauve_ra_block_ >0, [				# Annulation du décallage FIN du renvoi d'angle  
		n$, "CYCL DEF 7.0 POINT ZERO", e$
        n$, "CYCL DEF 7.1 0", e$
        n$, "CYCL DEF 7.2 0", e$
        n$, "CYCL DEF 7.3 0", e$
		sauve_ra_block_ = -1 	
		]	
	if Test_bris_outils = 1, p_test_bris_outil
	p_ori_usi_annul
	p_degage_fin
	if bldnxtool$ = 1 & type_prep_outil = 2,	[	
        if nom_outil = 1, [ 							# Tool call uses tool name
			first_op_id = streaminfo(1, 1)             	# Get the operation ID for the first operation in the sequence
			stoolname = opinfo(20001, first_op_id, 1)  	# Get the tool name for the first operation
			if stoolname = sblank, stoolname = "ERREUR-OUTIL SANS NOM"
			n$, 'TOOL DEF "', stoolname, '"', e$ 
			]
        if outils_param = 0 & nom_outil = 0, n$, "TOOL DEF", next_tool$, e$  # sans les parametres
	    if outils_param = 1 & nom_outil = 0, n$, "TOOL DEF", next_tool_, e$  # AVEC les parametres
        ]	
    # Déchargement de l'outil en broche
	if bldnxtool$ <> 1 & type_prep_outil < 1 & decharge_outil_fin = 1,	[	
		if outils_param = 0 & nom_outil = 0, n$, "TOOL CALL 0", e$ 
	    if outils_param = 1 & nom_outil = 0, next_tool_ = 1800, n$, "TOOL CALL", *next_tool_, e$                  	
		]
	if convoyeur = 1, n$, s_convoyeur_OFF, e$
	if compteur_pieces	= 1, n$, s_compteur_piece, e$ 
	p_palette_fin	# PALETTES
	if bldnxtool$ = 1 & affiche_M6, n$, "M6", e$ 
	if renvoi_d_angle = 1, n$, "LBL 9999", e$
	#n$, "TOOL CALL 0", e$
	#temps DLL
	info_temps = 4, p_temps_affectation
	p_temps_dll	
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 4, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS OPE. = ", *Heure, *min, *sec, s_com_close, e$
		]  
	info_temps = 5, p_temps_affectation
    if Affiche_temps_dll = 1 & Types_Temps_DLL = 5, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS OUTIL = ", *Heure, *min, *sec, s_com_close, e$
		Tot_time_op = 0
		Tot_time_Out = 0	
		]	
	info_temps = 6, p_temps_affectation
	if Affiche_temps_dll = 1 & Types_Temps_DLL = 6, [
		p_Convert_time_dll
		n$, s_com_open, "TEMPS TOTAL CORRIGE ", *Heure, *min, *sec, s_com_close, e$
		]  
	# 
    n$, "M2", e$
    n$, ";", e$
	n$, "LBL 99 ; ANNULATION", e$
    n$, "CYCL DEF 7.0 POINT ZERO", e$
    n$, "CYCL DEF 7.1 X0", e$
    n$, "CYCL DEF 7.2 Y0", e$
    n$, "CYCL DEF 7.3 Z0", e$
	n$, "LBL 0 ; ANNULATION", e$ 
    # Ajout pour les sous-programmes
    n$, " ", e$                             # Sauter une ligne
    subout$ = 0                             # Ecriture dan le NC
	
    mergesub$								# Ecriture du sous-prog "transformation"
	clearsub$								# Effacer les fichiers ".sub"
	#mergeext$
	#clearext$
	
	mergeaux$								# SOus-programme interne /passes en Z ..
	clearaux$ 								# Effacer les fichiers ".AUX" /passes en Z ..
    #if affiche_ori_entete = 2, mergeext$   # dans un autre fichier ".AUX"
    #if affiche_ori_entete = 22 & workofs_pwrtt > 54, mergeext$    # dans un autre fichier ".AUX"
    #clearext$                              # Effacer les sous-prog
    if affiche_ori_entete = 1 | affiche_ori_entete = 11, clearsub$	# Effacer les fichiers "sub" ORIGINES
    if change_nom = 1, [
        spaces$ = 0  
        n$, " END PGM ", snomprogentete," MM", e$
        spaces$ = 1  
        ]
    else, n$, "END PGM ", sprogname$,"MM", e$
#endregion

#endregion
#endregion

#region tool_inspection
ptool_insp      # inspection des plaquettes/outil
    p_lubrif_OFF
	pdeg_inspection_plaquette
    if prmcode$ = 29999, [   #seulement le commentaire dans le controle d'outil
        sparameter$ = ucase(sparameter$)
        n$, "M0 ;", sparameter$, e$
        ]
    else, n$, "M0", e$
    n$, "; controle de l etat des plaquettes - outil", e$
    if Position_info_outil = 1, p_info_outils
	p_affiche_outil
	if Position_info_outil = 2, p_info_outils
    n$, *spdlon, e$
    old_lubrif = -1
    n$, p_lubrif_ON, e$
	gcode$ = 0
	pcan1, p_bloc_O, n$, "L", pxyz, sgcode, strcantext, e$
	pcan1, p_bloc_O, n$, "L", *z$, sgcode, strcantext, e$
#endregion

#region test_bris_outil
sbris_outil  : "CALL PGM TNC:\USINAGE\L_BREAK_TEST.H"   # macro appel de sous programme pour test bris_outil  
sbris_outil1 : "CALL PGM TNC:\dmg\BRIS-FORET.H"    		# macro appel de sous programme pour test bris_outil
sbris_outil2 : "CALL PGM TNC:\dmg\BRIS-FRAISE.H"    	# macro appel de sous programme pour test bris_outil

p_test_bris_outil                    # controle bris outil
	type_test_bris_outils = mi5$
	Test_bris_outils = mi6$ 
    if type_test_bris_outils <> 0, 	[
		if type_test_bris_outils = 1,	[
			n$, ";TEST BRIS OUTIL FORET", e$ 
			#n$, sbris_outil1, e$
			n$, "TCH PROBE 481 LONGUEUR D'OUTIL ~", e$
			"    Q340=+1    ;CONTROLE ~", e$
			"    Q260=+100  ;HAUTEUR DE SECURITE ~", e$
			"    Q341=+0    ;ETALONNAGE DENTS", e$
			#n$, "FN 9: IF +Q199 EQU +2 GOTO LBL 249", e$
			#n$, "FN 9: IF +Q199 EQU +1 GOTO LBL 249", e$
			]
		if type_test_bris_outils = 2,	[
			n$, ";TEST BRIS OUTIL FRAISE", e$ 
			n$, sbris_outil2, e$
			]
		if type_test_bris_outils = 3,	[
			n$, "TCH PROBE 586 CONTROLE DE BRIS ~", e$
			"    Q356=+1    ;DIRECTION DE MESURE ~", e$
			"    Q357=+0    ;DECALAGE RADIAL", e$		  									
			#n$, "FN 9: IF +Q199 EQU +2 GOTO LBL 69", e$
			#n$, "FN 9: IF +Q199 EQU +1 GOTO LBL 249", e$
			]		
		type_test_bris_outils = 0
		Test_bris_outils = 0
		]
#endregion

#region deplacements
p_temporisation
	n$, "CYCL DEF 9.0 TEMPORISATION", e$
	n$, "CYCL DEF 9.1 TEMPO ", *dwell$, e$

pdwl_spd$        #Call from NCI gcode 4	*** ROTATION BROCHE / TEMPO / ARROSAGES
	#"ICI : pdwl_spd$", e$
	pspindle
	comment$
	pspindchng	#p_chang_S_broche
	pcan 
	if fmtrnd(dwell$), pcan1, p_bloc_O, p_temporisation, e$
	else, pcan1, p_bloc_O, #n$, strcantext, e$
	pcan2

prapid$     # Ligne rapide	
	#"ICI : prapid$", e$
	p_correc_time_G0
	if ra_block$ > 0, [        #avec le renvoie d'angle
		pcan1, p_bloc_O, n$, sgcode, pxyz, p_lubrif_ON, strcantext, e$
		]
	if ra_block$ = 0, [ #RENVOIE D'ANGLE	
		if workofs_ >0, [         #si décallages actif : force l'affichage des positions X ET Y
			pcan1, p_bloc_O, n$, "L", *x$, *y$, z$, sgcode, p_lubrif_ON, strcantext, e$	
			]
		else, pcan1, p_bloc_O, n$, "L", pxyz, sgcode, p_lubrif_ON, strcantext, e$
		prvz = z$  
		] 
	
pzrapid$    # Ligne Z rapide
	#"ICI : pZrapid$", e$
	p_correc_time_G0
	if ra_block$ = 0, [ #RENVOIE D'ANGLE
		pcan1, p_bloc_O, n$, "L", pxyz, sgcode, p_lubrif_ON, strcantext, e$
		prvz_pzr = z$
		]
	
plin$       # Ligne travail	
	#"ICI : plin$ ", e$
	p_percages_decomposes
	pcan
	pcan1, p_bloc_O, n$, sgcode, pxyz, pcord, pfr, p_lubrif_ON, strcantext, e$
	if drillcyc$ >= 0 & dwell$ > 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1), p_temporisation
	prvz = z$
	if rpd_typ$ = 7, ptool_insp      # inspection des plaquettes/outil
	
pz$         # z en avance rapide
	#"ICI : pz$", e$
	pcan1, p_bloc_O, n$, sgcode, pxyz, pfr, p_lubrif_ON, strcantext, e$
	prvz = z$  

pcir0$   # verif des arcs --> conversion en lignes si besoin
	@plane$
	if sauve_ra_block_ <= 0, linarc$ = 0
	if rotaxis$ <> 0, linarc$ = 1	# Convertir les arcs en lignes si travail en substitution 
	#if plane$ <> 0, linarc$ = 1	# pas d'arcs si G18 ou G19
	if ra_block$ >0, if m8$ <> 1 & m8$ <> -1 & m7$ <> 1 & m7$ <> -1, linarc$ = 1
	
pcir$      # Circulaire
	#"ICI : pcir$ ", e$
    perreurCC_COR   # "ATTENTION PRISE DE CORRECTION OU ANNULATION SUR UN CERCLE"
    if plane$ = 0,[
        @z$
        if arctype$ = 1, n$, s_CC, i$, j$, e$																# ABSOLU
		if arctype$ = 5 & z$ <> prvz, n$, `s_CC, *xc$, *yc$, e$												# RAYON
        if z$ <> prvz, n$, s_CP, sweep$, *z$, sgcode, pcord, pfr, strcantext, e$, helice = 1  
        else, [
			if arctype$ = 1, n$, "C", pxyz, sgcode, pcord, pfr, strcantext, [if ra_block$ >0, rayon = arcrad$, s_com_open, *rayon, s_com_close ], e$	# en CENTRE ABSOLU
			#if arctype$ = 5, n$, s_CR, *x$, *y$, z$, arcrad$, sgcode, pcord, pfr, strcantext, e$			# EN Rayon
			if arctype$ = 5, [																				# Avec la correction du problème de R après l'hélice
				if abs(sweep$) < 180, n$, s_CR, *x$, *y$, z$, *arcrad$, sgcode, pcord, pfr, strcantext, e$	# EN Rayon
				else, [
					n$, `s_CC, xc$, yc$, e$
		            n$, "C", *x$, *y$, *sgcode, pcord, pfr, strcantext, e$
		        	]
		        helice = 0	
				]
			]
        if arctype$ = 1 & z$ <> prvz & z$ = nextz$ & (nextop$ = 2 | nextop$ = 3), n$, "L" , pxyz, strcantext, e$ #"; EN +", e$	
        !i$, !x$,!y$
        ]
    if plane$ = 1,[
        if arctypexz$ = 1, [
			n$, s_CC, j$, k$, e$
        	n$, "C", pxyz, sgcode, pcord, pfr, strcantext, [if ra_block$ >0, rayon = arcrad$, s_com_open, *rayon, s_com_close ], e$	# en CENTRE ABSOLU
			]
		if arctypexz$ = 5, n$, s_CR, *x$, y$, *z$, arcrad$, sgcode, pcord, pfr, strcantext, e$	 
        !i$, !z$,!y$
        ]
    if plane$ = 2,[
        if arctypeyz$ = 1, [
			n$, s_CC, i$, k$, e$
        	n$, "C", pxyz, sgcode, pcord, pfr, strcantext, [if ra_block$ >0, rayon = arcrad$, s_com_open, *rayon, s_com_close ], e$	# en CENTRE ABSOLU
			]
		if arctypeyz$ = 5, n$, s_CR, x$, *y$, *z$, arcrad$, sgcode, pcord, pfr, strcantext, e$		
        !i$, !x$,!z$
        ]
   prvz = z$ 
   old_xc = xc$ 
   old_yc = yc$ 
   old_zc = zc$
   old_sweep = sweep$

pcord
    if cc$ = 41, "RL"
    if cc$ = 42, "RR"
    if cc$ = 140, "R0"
	old_cc = cc$
#endregion

#region approches_degagements	
#   Gestion du degagement de la machine au debut de prog
p_degage_debut       #   Gestion du degagement de la machine au debut de prog
    if deg_debut <> 0, [
	    gcode$ = 0              			# Degagement en Rapide
    	if deg_debut >= 1 & deg_debut < 6, n$, "L", *degageZ, smode_deg, e$  				# si degager en Z		# degager en Z
	    if deg_debut = 2 | deg_debut = 4, n$, "L", *degageX, smode_deg, e$  				# si degager en Z et X	# degager en X
	    if deg_debut = 3 | deg_debut = 4, n$, "L", *degageY, smode_deg, e$  				# si degager en Z et Y	# degager en Y
	    if deg_debut = 5, n$, "L", *degageX, *degageY, smode_deg, e$         				# si degager en Z et XY	# degager en X Y
		if deg_debut = 6, n$, S_macro_deg, e$, #n$, "autres fonctions apres MACRO", e$ 		# si Mode degagement uniquement en MACRO
        ]
		
#   Gestion du degagement de la machine avant appel outil
p_degage_ptlchg     #   Gestion du degagement de la machine avant appel outil
    if deg_outil <> 0, [
	    gcode$ = 0              			# Degagement en Rapide
	    if deg_outil >= 1 & deg_outil < 6, n$, "L", *degageZ, smode_deg, e$      			# si degager en Z		# degager en Z
	    if deg_outil = 2 | deg_outil = 4, n$, "L", *degageX, smode_deg, e$ 					# si degager en Z et X	# degager en X
	    if deg_outil = 3 | deg_outil = 4, n$, "L", *degageY, smode_deg, e$ 					# si degager en Z et Y	# degager en Y
	    if deg_outil = 5, n$, "L", *degageX, *degageY, smode_deg, e$             			# si degager en Z et XY	# degager en X Y
		if deg_outil = 6, n$, S_macro_deg, e$, #n$, "autres fonctions apres MACRO", e$ 		# si Mode degagement uniquement en MACRO
        ]

#   Gestion du degagement de la machine fin de prog
p_degage_fin #   Gestion du degagement de la machine fin de prog
   	if deg_fin <> 0, [
		gcode$ = 0              			# Degagement en Rapide
	    if deg_fin >= 1 & deg_fin < 6, n$, "L", *degageZ_fin, smode_deg, e$ 				# si degager en Z		# degager en Z
	    if deg_fin = 2 | deg_fin = 4, n$, "L", *degageX_fin, smode_deg, e$    				# si degager en Z et X	# degager en X
	    if deg_fin = 3 | deg_fin = 4, n$, "L", *degageY_fin, smode_deg, e$  				# si degager en Z et Y 	# degager en Y
	    if deg_fin = 5, n$, "L", *degageX_fin, *degageY_fin, smode_deg, e$              	# si degager en Z et XY # degager en X Y
		if deg_fin = 6, n$, S_macro_deg, e$, #n$, "autres fonctions apres MACRO", e$ 		# si Mode degagement uniquement en MACRO
        ]

#   Gestion du degagement de la machine avant rotation plateau
p_degage_4_axes        #   Gestion du degagement de la machine avant rotation plateau
	if deg_4_axes <> 0, [
	    gcode$ = 0              	# Degagement en Rapide
	    if mi2$ = 0, [				# Si différent de "0" alors pas de passage suivant config PP --> utilise UNIQUEMENT le Z sécu de l'op		        
			#p_casse_modalite       # casser la modalite pour rappel des XYZ
		    if deg_4_axes >= 1 & deg_4_axes < 6, n$, "L", *degageZ4, smode_deg, e$   			# si degager en Z		# degager en Z
		    if deg_4_axes = 2 | deg_4_axes = 4, n$, "L", *degageX4, smode_deg, e$   			# si degager en Z et X 	# degager en X
		    if deg_4_axes = 3 | deg_4_axes = 4, n$, "L", *degageY4, smode_deg, e$  				# si degager en Z et Y	# degager en Y
		    if deg_4_axes = 5, n$, "L", *degageX4, *degageY4, smode_deg, e$          			# si degager en Z et XY	# degager en X Y
			if deg_4_axes = 6, n$, S_macro_deg, e$, #n$, "autres fonctions apres MACRO", e$ 	# si Mode degagement uniquement en MACRO
			]
		#if mi2$ = 1, n$, "L", *zr$, *sgcode, strcantext, e$	# FORCE le Z sécu de l'op si la config est remonter en Z HAUT 
		]
	#else, gcode$ = 0, n$, "L", *zr$, *sgcode, strcantext, e$	# Sinon valeur de sécu de la valeur de l'opération MC

#   Gestion du degagement de l'outil lors de l'inspection de l'état de la plaquette 
pdeg_inspection_plaquette
	if deg_inspection_plaq <> 0, [
	    gcode$ = 0              		# Degagement en Rapide
	    #p_casse_modalite            	# casser la modalite pour rappel des XYZ
	    if deg_inspection_plaq = 1, n$, "L", *deg_insp_Z, smode_deg, e$             				# si degager en Z		# degager en Z
	    if deg_inspection_plaq = 2 | deg_inspection_plaq = 4, n$, "L", *deg_insp_X, smode_deg, e$   # si degager en Z et X 	# degager en X
	    if deg_inspection_plaq = 3 | deg_inspection_plaq = 4, n$, "L", *deg_insp_Y, smode_deg, e$  	# si degager en Z et Y	# degager en Y
	    if deg_inspection_plaq = 5, n$, "L", *deg_insp_X, *deg_insp_Y, smode_deg, e$          		# si degager en Z et XY	# degager en X Y
		if deg_inspection_plaq = 6, n$, S_macro_deg, e$, #n$, "autres fonctions apres MACRO", e$ 	# si Mode degagement uniquement en MACRO
	    ]
	else, gcode$ = 0, n$, "L", *zr$, *sgcode, strcantext, e$	#Sinon valeur de sécu dans l'opération MC	
#endregion

#region tous perçages 

#region percages
passage_drillcyc : 0
p_percages_decomposes
	#"p_percages_decomposes : ", *drillcyc$, *usecanDRILL, *usecanPECK, " ", *usecanCHIP, " ", *perc_1er_perc_pour_C_ou_mm, e$
	if drillcyc$ >= 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1) & passage_drillcyc = 0, 
		[
		if drillcyc$ = 0, n$, s_com_open, "PERCAGE LAMAGE TEMPO -G82-", s_com_close, e$ 
		if drillcyc$ = 1, n$, s_com_open, "PERCAGE DEBOURRAGE -G83-", s_com_close, e$
		if drillcyc$ = 2, n$, s_com_open, "PERCAGE DEBOURRAGE BRISE COPEAUX -G83-", s_com_close, e$ 
		#if drillcyc$ = 3, n$, s_com_open, "TARAUDAGE G84", s_com_close, e$ 
		passage_drillcyc = 1
		]	
	if drillcyc$ >= 0 & (usecanDRILL = 1 | usecanPECK = 1 | usecanCHIP = 1) & perc_1er_perc_pour_C_ou_mm >= 0 & perc_Val_pour_Cent_mm <> 0,  
		[
		n$, s_com_open, "AVEC AMORCE DE PERCAGE", s_com_close, e$ 
		# Avances
		if perc_AVANCE_pour_Cent_mm > 0, [			# %		
			avance = (frplunge$ * perc_AVANCE_pour_Cent_mm) / 100
			]
		if perc_AVANCE_pour_Cent_mm < 0, [			# mm
			avance = perc_AVANCE_pour_Cent_mm * -1
			]
		# Profondeurs
		if perc_1er_perc_pour_C_ou_mm = 0, [		# VALEUR EN mm	
			P_er_perc_0 = perc_Val_pour_Cent_mm 
			P_er_perc_2 = refht$ - P_er_perc_0	
			]	
		if perc_1er_perc_pour_C_ou_mm = 1, [		# Valeur en %
			angle_foret = 90 - (paramT8 / 2)
			P_er_perc_0 = refht$ - z$
			P_er_perc_1 = (P_er_perc_0 * perc_Val_pour_Cent_mm) / 100 
			P_er_perc_2 = refht$ - P_er_perc_1					
			]
		n$, "L", *P_er_perc_2, *avance, e$
		if dwell$ > 0, p_temporisation
		p_erreur_perc_decomposes
		perc_1er_perc_pour_C_ou_mm = -1	# pour ne pas l'afficher sur les autres profondeurs
		]

pdrill0$
    p_correc_time_G0
	if usecanDRILL = 1, usecandrill$ = no$
	if usecanPECK = 1, usecanpeck$ = no$
	if usecanCHIP = 1, usecanchip$ = no$
	passage_drillcyc = 0
	
p_val_cycles_percage    # calcul de (bq200, bq203, bq201, 204)
	@depth$, @refht$, @bq203, @initht$
	if rotaxis$ = 0,  [   		# XY CLASIQUE
		if opcode$ <> 16, [		# NON PERCAGE 5 axes
			#bq204 = initht$
			bq203 = tosz$
			bq200 = refht$ - tosz$
			#bq201 = depth$
			#DPR = abs (depth$ - tosz$)
			bq204 = initht$ - tosz$  
			bq201 = depth$ - tosz$
			]		
		if opcode$ = 16, [ 		# PERCAGE 5 axes				
		    if axeA = 0, [			
				bq201 = abs(w$ - z$) * -1 #depth$ - tosz$				# en - (relatif) depuis le Z haut face pièce				
				bq203 = w$ #z$ + depth$ #drl_sel_tos$ 		# Z face pièce en absolu
				bq204 = zr$ - bq203					# en + (relatif) depuis le Z haut face pièce	
				#DPR = depth$ - refht$	
		    	bq200 = refht$	#zr$ - w$			# en + (relatif) depuis le Z HAUT   
				]	    			
			if axeA <> 0, [
				#if diviseur = 1, bq201 = z$*cos(axeA) - y$*sin(axeA) * -1				
				#if diviseur = 2, bq201 = z$*cos(axeA) - x$*sin(axeA)								
									
				prof_perc_abs_5x = zabs - (drl_sel_ini$ - depth$)
				
				p_calcul_rot_pmx	#Pts X & Y	
				
				bq200 = refht$ - drl_sel_tos$				
				bq201 = (drl_sel_ini$ + abs(depth$)) * -1	#abs(depth$)
				bq203 = zabs + abs(bq201) 
				bq204 = drl_sel_tos$
				#if drl_sel_ini$ > bq200, bq204 = bq204 + drl_sel_ini$ - bq200			
				]
		    if Mode_reglage_PP = 0, [
				#"zabs = fond du trou en ABSOLU VAL MC", e$	
				#"zabs = VALEUR DE REFERENCE POUR TOUS LES CALCULS DE ****Zs****", e$
				spaces$ = 1
				*z$, *bq204, " ", *bq203, " ",  *bq201, " ", *bq200, " ", *y$, " ", *znci$, *ynci$,  e$ 
				*drl_ref_z$, *drl_sel_ini$, *drl_sel_ref$, *drl_sel_tos$, e$
				*drl_init_z$, *drl_tos_z$, *drl_zdrl_z$, " ",  *w$, " ", *z$, *znci$, e$
				*depth$, " ", *refht$, *zabs, e$	#*prof_perc_abs_5x, 
				*drl_depth_z$, *zr$, e$
				spaces$ = 0
				]
			#if type_dec_4x_percage = 1, garde_abs = 0	
			]
		]
	if rotaxis$ <> 0, [    # SUBSTITUTION
		p_calcul_AB_pos_Subs	
		if rotaxis$ = -1 | rotaxis$ = 1, x$ = 0, xabs = x$            						# diviseur tourne autour de Y (X sbstitue)
    	if rotaxis$ = -2 | rotaxis$ = 2, y$ = 0, yabs = y$  
		bq204 = initht$ + (rotdia$/2)
		bq203 = tosz$ + (rotdia$/2)
		bq201 = depth$ + (rotdia$/2)
		#DPR = depth$ - tosz$
		gcode$ = 0
		@axeAB_subs, @old_axeA
		if axeAB_subs <> old_axeA, 
			[
			if mi7$ = 1, bloque = 2, n$, sbloque, e$		# déblocage de l'axe A/B  		
			n$, "L", axeAB_subs, sgcode, e$
			if mi7$ = 1, bloque = 1, n$, sbloque, e$		# si ROT - Bloque 
			old_axeA  = axeAB_subs
			]       
		]
	#bq202 = abs (depth$ - tosz$)	
	bq202 = peck1$
	bq205 = peck2$
	bq206 = frplunge$ 
	bq211 = dwell$
	if tool_typ$ = 5, bq239 = n_tap_thds$ * -1
    if tool_typ$ = 4, bq239 = n_tap_thds$ 
	
p_position_trou # Positions de percages
	#p_correc_time_G0
	pcan1, p_bloc_O, n$, "L", *x$, *y$, sgcode, "M99", strcantext, e$
	pcan2
    !x$,!y$,!z$,!xr$,!yr$,!zr$

pdrill$     # Cycle de percage G81
	if drill_4_axes = 1, p_drill_5axes
    gcode$ = 0
	p_val_cycles_percage
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	#bq202 = abs(bq203 - bq201) 	# Prof passe = profondeur
	bq202 = bq201 * -1 	# Prof passe = profondeur
    n$, "CYCL DEF 200 PERCAGE~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq202, "  ; PROFONDEUR DE PASSE~", e$
    "     Q210 = 0 ", "  ; TEMPO. EN HAUT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~", e$
    "    ", bq211, "  ; TEMPO. AU FOND", e$
    #bq204 valeur relative
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y
    old_bq203 = bq203
    old_bq201 = bq201

pdrill_2$   # Canned Drill Cycle
    if drill_4_axes = 1, p_drill_5axes_2 
	gcode$ = 0
    p_val_cycles_percage
    !bq201
    @bq201 ,@old_bq201 , @old_bq203 , @bq203
    if bq201 <> old_bq201 | old_bq203 <> bq203, pdrill_3
	if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y

pdrill_3
    gcode$ = 0
	bq202 = abs(bq203 - bq201) 	# Prof passe = profondeur	
    n$, "CYCL DEF 200 PERCAGE~",e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq202, "  ; PROFONDEUR DE PASSE~", e$
    "     Q210 = 0 ", "  ; TEMPO. EN HAUT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~", e$
    "    ", bq211, "  ; TEMPO. AU FOND", e$
    old_bq203 = bq203
    old_bq201 = bq201

ppeck$      # Cycle de debourrage
	if drill_4_axes = 1, p_drill_5axes
	gcode$ = 0
	p_val_cycles_percage
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	bq202 = peck1$
    n$, "CYCL DEF 200 PERCAGE~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq202, "  ; PROFONDEUR DE PASSE~", e$
    "     Q210 = 0 ", "  ; TEMPO. EN HAUT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~", e$
    "    ", bq211, "  ; TEMPO. AU FOND", e$
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y
    old_bq203 = bq203
    old_bq201 = bq201 

ppeck_2$    # Canned Peck Drill Cycle
	if drill_4_axes = 1, p_drill_5axes_2
	p_val_cycles_percage
    !bq201
    gcode$ = 0
    @bq201 ,@old_bq201, @old_bq203, @bq203
    if bq201 <> old_bq201 | old_bq203 <> bq203, ppeck_3
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y

ppeck_3
    gcode$ = 0
	bq202 = peck1$
    n$, "CYCL DEF 200 PERCAGE~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq202, "  ; PROFONDEUR DE PASSE~", e$
    "     Q210 = 0 ", "  ; TEMPO. EN HAUT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~",e$
    "    ", bq211, "  ; TEMPO. AU FOND", e$
    old_bq203 = bq203
    old_bq201 = bq201

pchpbrk$    # Cycle de brise copeaux
    if drill_4_axes = 1, p_drill_5axes
	gcode$ = 0
	p_val_cycles_percage
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
	bq202 = peck1$
	bq205 = peck2$ 
    bq256 = shftdrl$
	bq211 = dwell$
    bq212 = peckclr$
    bq213 = retr$
    n$, "CYCL DEF 203 PERCAGE UNIVERSEL~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq202, "  ; PROFONDEUR DE PASSE~", e$
    "     Q210 = 0   ; TEMPO. EN HAUT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~", e$
    "    ", bq212, "  ; VALEUR DE REDUCTION~", e$
    "    ", bq213, "  ; NB BRISE-COPEAUX~", e$
    "    ", bq211, "  ; TEMPO. AU FOND~", e$
    "     Q211 = 0   ; TEMPO. AU FOND~", e$
    "     Q208 = +9999 ", "  ; AVANCE RETRAIT~", e$
    "    ", bq256, "  ; RETR. BRISE COPEAUX", e$
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y
    perreurPar_perc 
    old_bq203 = bq203
    old_bq201 = bq201
    #perreurTaraud   

pchpbrk_2$  # Canned Chip Break Cycle
    if drill_4_axes = 1, p_drill_5axes_2
	p_val_cycles_percage
    !bq201
    gcode$ = 0
    @bq201 ,@old_bq201 , @old_bq203 , @bq203
    if bq201 <> old_bq201 | old_bq203 <> bq203, pchpbrk_3
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y

pchpbrk_3
    gcode$ = 0
	bq202 = peck1$
	bq205 = peck2$ 
    bq256 = shftdrl$
	bq211 = dwell$
    bq212 = peckclr$
    bq213 = retr$
    n$, "CYCL DEF 203 PERCAGE UNIVERSEL~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq202, "  ; PROFONDEUR DE PASSE~", e$
    "     Q210 = 0   ; TEMPO. EN HAUT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~", e$
    "    ", bq212, "  ; VALEUR DE REDUCTION~", e$
    "    ", bq213, "  ; NB BRISE-COPEAUX~", e$
    "    ", bq205, "  ; PROF. PASSE MINI~", e$
    "    ", bq211, "  ; TEMPO. AU FOND~", e$
    "     Q208 = +9999 ", "  ; AVANCE RETRAIT~", e$
    "    ", bq256, "  ;RETR. BRISE COPEAUX", e$
    old_bq203 = bq203
    old_bq201 = bq201

ptap$     # nouveau Cycle taraudage rigide 207
    if drill_4_axes = 1, p_drill_5axes
	gcode$ = 0
	p_val_cycles_percage
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
    bq214 = peckclr$
    bq239 = n_tap_thds$
    n$, "CYCL DEF 207 NOUV. TARAUDAGE RIG.~",e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", *bq239, "  ; PAS DE VIS~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE", e$
	if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y
    old_bq203 = bq203
    old_bq201 = bq201

ptap_2$     # Canned Tap Cycle3
	if drill_4_axes = 1, p_drill_5axes_2
	p_val_cycles_percage
    !bq201
    gcode$ = 0
    @bq201 ,@old_bq201 , @old_bq203 , @bq203
    if bq201 <> old_bq201 | old_bq203 <> bq203, ptap_3
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y

ptap_3
    gcode$ = 0	
    bq214 = peckclr$
    bq336 = retr$
    bq239 = n_tap_thds$   
    n$, "CYCL DEF 207 NOUV. TARAUDAGE RIG.~",e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq239, "  ; PAS DE VIS~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE", e$
    old_bq203 = bq203
    old_bq201 = bq201

pbore1$     # Cycle d'alésage à l'ALESOIR
    if drill_4_axes = 1, p_drill_5axes
	gcode$ = 0
	p_val_cycles_percage
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
    bq211 = dwell$ 
    bq208 = peckclr$
    n$, "CYCL DEF 201 ALESAGE AVEC ALESOIR~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~" , e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq211, "  ; TEMPO. AU FOND~", e$
    "    ", bq208, "  ; AVANCE RETRAIT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE", e$
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y
    old_bq203 = bq203
    old_bq201 = bq201
    perreurTaraud 

pbore1_2$   # Canned Bore #2 Cycle
    if drill_4_axes = 1, p_drill_5axes_2
	p_val_cycles_percage
    !bq201
    gcode$ = 0
    @bq201 ,@old_bq201 , @old_bq203 , @bq203
    if bq201 <> old_bq201 | old_bq203 <> bq203, pbore1_3
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y

pbore1_3    # Canned Bore #3 Cycle
    gcode$ = 0
    bq211 = dwell$ 
    bq208 = peckclr$
    n$, "CYCL DEF 201 ALESAGE AVEC ALESOIR~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~" , e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq211, "  ; TEMPO. AU FOND~", e$
    "    ", bq208, "  ; AVANCE RETRAIT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE", e$
    old_bq203 = bq203
    old_bq201 = bq201

pbore2$     # Cycle d'alésage indexé
    if drill_4_axes = 1, p_drill_5axes
	gcode$ = 0
	p_val_cycles_percage
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
    bq211 = dwell$ 
    bq208 = 1000
    bq214 = retr$
    #bq336 = retr$
    if paramT2 = 7 & paramT16 = 1, bq214 = 1
    else, bq214 = 0
    n$, "CYCL DEF 202 ALESAGE A L'OUTIL~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq211, "  ; TEMPO. AU FOND~", e$
    "    ", bq208, "  ; AVANCE RETRAIT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~", e$
    "    ", bq214, "  ; SENS DEGAGEMENT~", e$
    "     Q336 = 0", "  ; ANGLE BROCHE", e$
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y
    old_bq203 = bq203
    old_bq201 = bq201
    perreurTaraud

pbore2_2$   # Cycle d'alésage indexé
    if drill_4_axes = 1, p_drill_5axes_2
	p_val_cycles_percage
    !bq201
    gcode$ = 0
    @bq201 ,@old_bq201 , @old_bq203 , @bq203
    if bq201 <> old_bq201 | old_bq203 <> bq203, pbore2_3
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y

pbore2_3    # Cycle d'alésage indexé
    gcode$ = 0
    bq211 = dwell$ 
    bq208 = 1000
    bq214 = retr$
    #bq336 = retr$
    if paramT2 = 7 & paramT16 = 1 , bq214 = 1 #4
    else, bq214 = 0
    n$, "CYCL DEF 202 ALESAGE A L'OUTIL~", e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", bq206, "  ; AVANCE PLONGEE PROF.~", e$
    "    ", bq211, "  ; TEMPO. AU FOND~", e$
    "    ", bq208, "  ; AVANCE RETRAIT~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; SAUT DE BRIDE~", e$
    "    ", bq214, "  ; SENS DEGAGEMENT~", e$
    "     Q336 = 0", "  ; ANGLE BROCHE", e$
    old_bq203 = bq203
    old_bq201 = bq201

pmisc1$        # Cycle de taraudage 209
    if drill_4_axes = 1, p_drill_5axes
	gcode$ = 0
	p_val_cycles_percage
	if rotaxis$ <> 0, n$, s_com_open, "SUBSTITUTION D AXE", s_com_close, e$
    bq239 = n_tap_thds$
    if peck1$ = 0, [
		bq257 = bq201, e$
        bq256 = 0, e$
		]
	else, [
		bq257 = peck1$, e$
	    bq256 = peckclr$, e$ 
		]
    n$, "CYCL DEF 209 TARAUD. BRISE-COPEAUX~",e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", *bq239, "  ; PAS DE VIS~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; 2EME DISTANCE D'APPROCHE~", e$
    "    ", bq257, "  ; PROF. PERC. BRISE-COPEAUX~", e$
    "    ", bq256, "  ; RETR BRISE-COPEAUX~", e$
    "     Q336 = 0", "  ; ANGLE BROCHE~", e$
	"     Q403 = 1", "  ; FACTEUR VIT. ROT.", e$
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y
    old_bq203 = bq203
    old_bq201 = bq201

pmisc1_2$      # Canned Tap Cycle
    if drill_4_axes = 1, p_drill_5axes_2
	p_val_cycles_percage
    !bq201
    gcode$ = 0
    @bq201 ,@old_bq201 , @old_bq203 , @bq203
    if bq201 <> old_bq201 | old_bq203 <> bq203, pmisc1_3
    if drill_4_axes = 1, n$, "L", *xabs, *yabs, sgcode, "M99", strcantext, e$
	else, p_position_trou	# X Y

pmisc1_3
    gcode$ = 0
    bq239 = n_tap_thds$
    if peck1$ = 0, [
		bq257 = bq201, e$
        bq256 = 0, e$
		]
    else, [
		bq257 = peck1$, e$
        bq256 = peckclr$, e$ 
		]
    n$, "CYCL DEF 209 TARAUD. BRISE-COPEAUX~",e$
    "    ", bq200, "  ; DISTANCE D'APPROCHE~", e$
    "    ", bq201, "  ; PROFONDEUR~", e$
    "    ", *bq239, "  ; PAS DE VIS~", e$
    "    ", bq203, "  ; COORD. SURFACE PIECE~", e$
    "    ", bq204, "  ; 2EME DISTANCE D'APPROCHE~", e$
    "    ", bq257, "  ; PROF. PERC. BRISE-COPEAUX~", e$
    "    ", bq256, "  ; RETR BRISE-COPEAUX~", e$
    "     Q336 = 0", "  ; ANGLE BROCHE~", e$
	"     Q403 = 1", "  ; FACTEUR VIT. ROT.", e$
    old_bq203 = bq203
    old_bq201 = bq201

pmisc2$     # Cycle d'alesage indexe G76

pmisc2_2$   # Canned Misc #2 Cycle

#endregion

#region palpage/perçage tres profond
pdrlcst$     # Test de l'appel des cycles et embranchements 
    x_pt_zero = x$      
    y_pt_zero = y$
    z_pt_zero = depth$
	if Cycles_palpage_YN = 1 & drillcyc$ >7 & drillcyc$ <16, [
	    if drl_prm10$ <>0, n$, "*********", e$
	    if drl_prm10$ >0, n$, "; VALEUR VERS TABLEAU POINT 0", e$
	    if drl_prm10$ =0 & (drillcyc$ <> 19), n$, "; NOUVEAU POINT D ORIGINE", e$ 
	    if drl_prm10$ <>0, n$, "*********", e$
	    if drillcyc$ = 8, pdrlcst_8     	#Cycle de palpage "410 (et 411) Pt de réf. int. (exter) rectangulaire"  
	    if drillcyc$ = 9, pdrlcst_9      	#Cycle de palpage "412 (et 413) Pt de réf. int. (exter) circulaire" 
	    if drillcyc$ = 10, pdrlcst_10     	#Cycle de palpage "414 Pt de réf. exter Coin"   
	    if drillcyc$ = 11, pdrlcst_11     	#Cycle de palpage "415 Pt de réf. inter Coin"   
	    if drillcyc$ = 12, pdrlcst_12     	#Cycle de palpage "417 Pt de réf. int. dans l'axe du palpeur"   
	    if drillcyc$ = 15, pdrlcst_15     	#Cycle de palpage "408 Pt de réf. CENTRE RAINURE"   
		]
	if Cycles_palpage_YN = 0 & drillcyc$ >7 & drillcyc$ <16, p_erreur_cycle_palpage
	if drillcyc$ = 18, pdrlcst_18 	# Cycle Brossage EBAVURAGE 
	if drillcyc$ = 19, pdrlcst_19   # perçage très profond avec trous d'huile
	
pdrlcst_2$ #Cycles suivants
	if drillcyc$ = 18, pdrlcst_18_2 	# Cycle Brossage EBAVURAGE 
    if drillcyc$ = 19, pdrlcst_19_2   # perçage très profond avec trous d'huile
    gcode$ = 0              

pcom_cycl_palp  # Commentaires communs pour les cycles de palpages
    n$, "; Q303=0 dans Def.7 -- activer le tableau *.D", e$
    n$, "; Q303=1 dans le tableau Preset -ORIGINE- *.PR", e$
    n$, "; Q333=+1  ; POINT DE REFERENCE", e$

pdrlcst_8        #Cycle de palpage "410 (et 411) Pt de réf. int. (exter) rectangulaire"
    gcode$ = 0
    bq261 = depth$
    bq260 = initht$ 
    bq323 = peck1$
    bq324 = peck2$
    bq321 = x1
    bq322 = y2

    if drl_prm1$ = 1 , n$, "TCH PROBE 410 PT REF INT. RECTANGLE~", e$
    if drl_prm1$ = 1 ,
        [
        bq323 = bq323 - 4
        bq324 = bq324 - 4
        ]   # SECURITE EN INTER
    if drl_prm2$ = 1 , n$, "TCH PROBE 411 PT REF EXT. RECTANGLE~", e$
    if drl_prm2$ = 1 ,
        [
        bq323 = bq323 + 5
        bq324 = bq324 + 5
        ]   # SECURITE EN EXTER
    perreurPalp1   # "1 ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
    "    ", bq321, "  ; CENTRE 1ER AXE~", e$
    "    ", bq322, "  ; CENTRE 2EME AXE~", e$
    "    ", bq323, "  ; 1ER COTE~", e$
    "    ", bq324, "  ; 2EME COTE~", e$
    "    ", bq261, "  ; HAUTEUR DE MESURE~", e$
    "     Q320 = 0  ; DISTANCE D'APPROCHE~", e$
    "    ", bq260, "  ; HAUTEUR DE SECURITE~", e$
    if drl_prm1$ = 1 ,"     Q301 = 0  ; DEPLACEMENT HAUT. SEC.~", e$
    if drl_prm2$ = 1 ,"     Q301 = 1  ; DEPLACEMENT HAUT. SEC.~", e$
    "     Q305 = ", drl_prm10$, "  ; NO. DANS TABLEAU~", e$ 
    "     Q331 = ", *x_pt_zero, "  ; POINT DE REF.~", e$   
    "     Q332 = ", *y_pt_zero, "  ; POINT DE REF.", e$    
    "     Q303 = -1  ; TRANSF. VAL. MESURE~", e$
    "     Q381 = 0  ; PALP. DS AXE PALPEUR~", e$
    "     Q382 = 0  ; 1. CO. POUR AXE PALP.~", e$
    "     Q383 = 0  ; 2. CO. POUR AXE PALP.~", e$
    "     Q384 = 0  ; 3. CO. POUR AXE PALP.~", e$
    "     Q333 = +1  ; POINT DE REFERENCE", e$

pdrlcst_9        #Cycle de palpage "412 (et 413) Pt de réf. int. (exter) circulaire" 
    gcode$ = 0
    bq261 = depth$
    bq260 = initht$ 
    bq262 = peck1$
    bq321 = x1
    bq322 = y2
    if drl_prm1$ = 1 , n$, "TCH PROBE 412 PT REF INT. CERCLE~", e$
    if drl_prm1$ = 1 , bq260 = bq260 - 4   # SECURITE EN INTER
    if drl_prm2$ = 1 , n$, "TCH PROBE 413 PT REF EXT. CERCLE~", e$
    if drl_prm2$ = 1 , bq260 = bq260 + 4   # SECURITE EN EXTER
    perreurPalp1  # "1 ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
    "    ", bq321, "  ; CENTRE 1ER AXE~", e$
    "    ", bq322, "  ; CENTRE 2EME AXE~", e$
    "    ", bq262, "  ; DIAMETRE NOMINAL~", e$
    "     Q325 = +0  ; ANGLE INITIAL~", e$
    "     Q247 = +90  ; PAS ANGULAIRE~", e$
    "    ", bq261, "  ; HAUTEUR DE MESURE~", e$
    "     Q320 = 0  ; DISTANCE D'APPROCHE~", e$
    "    ", bq260, "  ; HAUTEUR DE SECURITE~", e$
    if drl_prm1$ = 1 ,"     Q301 = 0  ; DEPLACEMENT HAUT. SEC.~", e$
    if drl_prm2$ = 1 ,"     Q301 = 1  ; DEPLACEMENT HAUT. SEC.~", e$
    "     Q305 = ", drl_prm10$, "  ; NO. DANS TABLEAU~", e$ 
    "     Q331 = ", *x_pt_zero, "  ; POINT DE REF.~", e$   
    "     Q332 = ", *y_pt_zero, "  ; POINT DE REF.", e$    
    "     Q303 = -1  ; TRANSF. VAL. MESURE~", e$
    "     Q381 = 0  ; PALP. DS AXE PALPEUR~", e$
    "     Q382 = 0  ; 1. CO. POUR AXE PALP.~", e$
    "     Q383 = 0  ; 2. CO. POUR AXE PALP.~", e$
    "     Q384 = 0  ; 3. CO. POUR AXE PALP.~", e$
    "     Q333 = +1  ; POINT DE REFERENCE", e$

pdrlcst_10    #Cycle de palpage "414 Pt de réf. exter Coin"   
    gcode$ = 0
    bq261 = depth$
    bq260 = initht$
    n$, "TCH PROBE 414 PT REF. EXT. COIN~", e$
    "     Q263 = ", drl_prm4$, "  ; 1ER POINT 1ER AXE~", e$
    "     Q264 = ", drl_prm5$, "  ; 1ER POINT 2EME AXE~", e$
    "     Q326 = ", drl_prm6$, "  ; DIST.1ER AXE~", e$
    "     Q296 = ", drl_prm7$, "  ; 3EME POINT 1ER AXE~", e$
    "     Q297 = ", drl_prm8$, "  ; 3EME POINT 2EME AXE~", e$
    "     Q327 = ", drl_prm9$, "  ; DIST. DU 2EME AXE~", e$
    "    ", bq261, "  ; HAUTEUR DE MESURE~", e$
    "     Q320 = 2  ; DISTANCE D'APPROCHE~", e$
    "    ", bq260, "  ; HAUTEUR DE SECURITE~", e$
    "     Q301 = 1  ; DEPLACEMENT HAUT. SEC.~", e$
    "     Q304 = ", drl_prm3$, "  ; ROTATION DE BASE~", e$
    "     Q305 = ", drl_prm10$, "  ; NO. DANS TABLEAU~", e$ 
    "     Q331 = ", *x_pt_zero, "  ; POINT DE REF.~", e$   
    "     Q332 = ", *y_pt_zero, "  ; POINT DE REF.", e$   
    "     Q303 = -1  ; TRANSF. VAL. MESURE~", e$
    "     Q381 = 0  ; PALP. DS AXE PALPEUR~", e$
    "     Q382 = 0  ; 1. CO. POUR AXE PALP.~", e$
    "     Q383 = 0  ; 2. CO. POUR AXE PALP.~", e$
    "     Q384 = 0  ; 3. CO. POUR AXE PALP.~", e$
    "     Q333 = +1  ; POINT DE REFERENCE", e$
    perreurPalp2  # "2 ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"


pdrlcst_11    #Cycle de palpage "415 Pt de réf. inter Coin"   
    gcode$ = 0
    bq261 = depth$
    bq260 = initht$ 
    n$, "TCH PROBE 415 PT REF INT. COIN~", e$
    "     Q263 = ", drl_prm4$, "  ; 1ER POINT 1ER AXE~", e$
    "     Q264 = ", drl_prm5$, "  ; 1ER POINT 2EME AXE~", e$
    "     Q326 = ", drl_prm6$, "  ; DISTANCE 1ER AXE~", e$
    "     Q327 = ", drl_prm7$, "  ; DISTANCE 2EME AXE~", e$
    "     Q308 = ", drl_prm8$, "  ; COIN~", e$
    "    ", bq261, "  ; HAUTEUR DE MESURE~", e$
    "     Q320 = 2  ; DISTANCE D'APPROCHE~", e$
    "    ", bq260, "  ; HAUTEUR DE SECURITE~", e$
    "     Q301 = 1  ; DEPLACEMENT HAUT. SEC.~", e$
    "     Q304 = ", drl_prm3$, "  ; ROTATION DE BASE~", e$
    "     Q305 = ", drl_prm10$, "  ; NO. DANS TABLEAU~", e$ 
    "     Q331 = ", *x_pt_zero, "  ; POINT DE REF.~", e$   
    "     Q332 = ", *y_pt_zero, "  ; POINT DE REF.", e$    
    "     Q303 = -1  ; TRANSF. VAL. MESURE~", e$
    "     Q381 = 0  ; PALP. DS AXE PALPEUR~", e$
    "     Q382 = 0  ; 1. CO. POUR AXE PALP.~", e$
    "     Q383 = 0  ; 2. CO. POUR AXE PALP.~", e$
    "     Q384 = 0  ; 3. CO. POUR AXE PALP.~", e$
    "     Q333 = +1  ; POINT DE REFERENCE", e$
    perreurPalp3  # "ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"

pdrlcst_12    #Cycle de palpage "417 Pt de réf. int. dans l'axe du palpeur"   
    gcode$ = 0
    bq294 = depth$ - tosz$
    bq260 = initht$
    bq333 = peck1$
    bq263 = x1
    bq264 = y2
    n$, "TCH PROBE 417 PT REF AXE TS~", e$
    "    ", bq263, "  ; 1ER POINT 1ER AXE~", e$
    "    ", bq264, "  ; 1ER POINT 2EME AXE~", e$
    "    ", bq294, "  ; 1ER POINT 3EME AXE~", e$
    "     Q320 = 5  ; DISTANCE D'APPROCHE~", e$
    "    ", bq260, "  ; HAUTEUR DE SECURITE~", e$
    "    ", bq333, "  ; POINT DE REF.~", e$
    "     Q305 = ", drl_prm10$, "  ; NO. DANS TABLEAU~", e$ 
    "     Q303 = ", *z_pt_zero, "  ; POINT DE REF.", e$  

pdrlcst_13

pdrlcst_14

pdrlcst_15        #Cycle de palpage "408 Pt de réf. CENTRE RAINURE"   
    gcode$ = 0
    bq261 = depth$
    bq260 = initht$ 
    bq311 = peck1$
    bq321 = x$  
    bq322 = y$  
    if peck2$ = 1 , n$, "; PALPAGE EN X", e$
    if peck2$ = 2 , n$, "; PALPAGE EN Y", e$
    n$, "TCH PROBE 408 PT REF. CENTRE RAINURE~", e$
    #perreurPalp1   # "1 ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
    "    ", bq321, "  ; CENTRE 1ER AXE~", e$
    "    ", bq322, "  ; CENTRE 2EME AXE~", e$
    "    ", bq311, "  ; LARGEUR RAINURE~", e$
    #if drl_prm1$ = 1 ,"     Q272 = 1  ; -X- AXE DE MESURE~", e$
    #if drl_prm2$ = 1 ,"     Q272 = 2  ; -Y- AXE DE MESURE~", e$
    if peck2$ = 1 ,"     Q272 = 1  ; -X- AXE DE MESURE~", e$
    if peck2$ = 2 ,"     Q272 = 2  ; -Y- AXE DE MESURE~", e$
    "    ", bq261, "  ; HAUTEUR DE MESURE~", e$
    "     Q320 = 10  ; DISTANCE D'APPROCHE~", e$
    "    ", bq260, "  ; HAUTEUR DE SECURITE~", e$
    "     Q301 = 1  ; DEPLAC. HAUT. SECU.~", e$
    "     Q305 = ", drl_prm10$, "  ; NO. DANS TABLEAU~", e$ 
    "     Q405 = 0  ; POINT DE REFERENCE~", e$
    "     Q303 = +1  ; TRANSF. VAL. MESURE~", e$
    "     Q381 = 0  ; PALP. DS AXE PALPEUR~", e$
    "     Q382 = 0  ; 1. CO. POUR AXE PALP.~", e$
    "     Q383 = 0  ; 2. CO. POUR AXE PALP.~", e$
    "     Q384 = 0  ; 3. CO. POUR AXE PALP.~", e$
    "     Q333 = 0  ;POINT DE REFERENCE", e$    
    #"     Q333 = ", *z_pt_zero, "  ;POINT DE REFERENCE", e$    

fmt "Z" 4 nombre_Va_et_Vient
fmt "Z" 2 Z_dep_brosse
fmt "Z" 2 Z_fin_brosse
fmt "Z" 2 initht_
pdrlcst_18 	# Cycle Brossage EBAVURAGE  
	n$, s_com_open, "CYCLE DECOMPOSE D EBAVURAGE A LA BROSSE", s_com_close, e$
	if drill_4_axes = 1, p_drill_5axes    
	Z_dep_brosse = drl_sel_tos$
	Z_fin_brosse = z$
	initht_ = initht$
	n$, "M3 S20", e$
	n$, "G01", *Z_fin_brosse, "F300", e$
	n$, *ssa, *spdlon, e$
	while nombre_Va_et_Vient < peck2$, [
		nombre_Va_et_Vient = nombre_Va_et_Vient +1
		n$, *Z_dep_brosse, e$		
		n$, *Z_fin_brosse, e$			
		]
	nombre_Va_et_Vient = 0
	n$, *Z_dep_brosse, e$
	n$, "M5", e$
	gcode$ = 0
	n$, *sgcode, *initht_, e$	
	perreurTaraud
	
pdrlcst_18_2 	# Cycle Brossage EBAVURAGE  
	if drill_4_axes = 1, p_drill_5axes_2  
	xabs = x$
	yabs = y$
	gcode$ = 0
	n$, *sgcode, xabs, yabs, e$
	Z_dep_brosse = drl_sel_tos$
	Z_fin_brosse = z$
	initht_ = initht$
	n$, "M3 S20", e$
	n$, "G01", *Z_fin_brosse, "F300", e$
	n$, *ssa, *spdlon, e$
	while nombre_Va_et_Vient < peck2$, [
		nombre_Va_et_Vient = nombre_Va_et_Vient +1
		n$, *Z_dep_brosse, e$		
		n$, *Z_fin_brosse, e$			
		]
	nombre_Va_et_Vient = 0
	n$, *Z_dep_brosse, e$
	n$, "M5", e$
	gcode$ = 0
	n$, *sgcode, *initht_, e$
	
p_affiche_S_perc_prof
    if nom_outil = 1, n$, "TOOL CALL ", 34, no_spc$, strtool$, no_spc$, 34, "Z", ssa, e$
    if outils_param = 0 & nom_outil = 0, n$, "TOOL CALL ", t$, "Z", *ssa, e$
    if outils_param = 1 & nom_outil = 0, [
        outil_paramT2 = t$ + 1800
        n$, "TOOL CALL", outil_paramT2, "Z", *ssa, e$
        ]

pdrlcst_19    # perçage très profond avec trous d'huile   
    gcode$ = 0
	p_erreur_lub_perc_prof
    #result = mprint(s_mess_per_prof)
    #result = mprint(s_mess_per_prof2)
    #if ssa > 500, result = mprint(s_mess_per_prof3)    # "ATTENTION -S- DE DEPART > 500 Tr/mn A MODIFIER DANS L'ISO !"
    f_p_profond = abs(frplunge$ *2)
    z_dep_p_prof = tosz$ +2
    #f_p_profond = abs(f_p_profond)
    n$, "; PERCAGE TRES PROFOND", e$
    n$, "M4 ",  e$
    n$, "L", *refht$, f_p_profond, e$   # Z secu dehors
    n$, "L", *z_dep_p_prof, "; Z depart + garde de 2mm", e$ # Z départ
    n$, "M3", e$
    n$, "CYCL DEF 9.0 TEMPORISATION", e$
    n$, "CYCL DEF 9.1 TEMPO. 1.0", e$
	posi_p_prof = 2
	p_rot_perc_profond, p_affiche_S_perc_prof
    n$, *scoolantx, e$
    n$, "CYCL DEF 9.0 TEMPORISATION", e$
    n$, "CYCL DEF 9.1 TEMPO. 1.0", e$
    n$, "L", *depth$, *frplunge$, e$
    #n$, "L", *dwell$, e$
    n$, "L", *tosz$, "F1000", e$
	n$, "M9", e$
	posi_p_prof = 1
	p_rot_perc_profond, p_affiche_S_perc_prof
    n$, "L", *initht$, e$
    drillcyc$ = -1
    drlcst7 = 1
    perreurTaraud

pdrlcst_19_2    # perçage très profond avec trous d'huile   
    gcode$ = 0
    pdrlcst_autres
    #result = mprint(s_mess_per_prof)
    #result = mprint(s_mess_per_prof2)
    f_p_profond = abs(frplunge$ *2)
    z_dep_p_prof = tosz$ +2
    #f_p_profond = abs(f_p_profond)
    n$, "; PERCAGE TRES PROFOND", e$
    n$, "M4 ",  e$
    n$, "L", *refht$, f_p_profond, e$   # Z secu dehors
    n$, "L", *z_dep_p_prof, ";Z depart + garde de 2mm", e$ # Z départ
    n$, "M3", e$
    n$, "CYCL DEF 9.0 TEMPORISATION", e$
    n$, "CYCL DEF 9.1 TEMPO. 1.0", e$
	posi_p_prof = 2
	p_rot_perc_profond, p_affiche_S_perc_prof
    n$, *scoolantx, e$
    n$, "CYCL DEF 9.0 TEMPORISATION", e$
    n$, "CYCL DEF 9.1 TEMPO. 1.0", e$
    n$, "L", *depth$, *frplunge$, e$
    n$, "M9", e$
    #n$, "L", *dwell$, e$
    n$, "L", *tosz$, "F1000", e$
	posi_p_prof = 1
	p_rot_perc_profond, p_affiche_S_perc_prof
    n$, "L", *initht$, e$
    drillcyc$ = -1
    drlcst7 = 0

pdrlcst_autres  # Positions de percages
    xabs = x$
	yabs = y$
	n$, "L", *xabs, *yabs, sgcode, e$    
    !x$,!y$
		
#endregion

#region fin percages
pcanceldc$  # Cancel canned drill cycle
   if opcode$ = 16, pdril5x_annul, ex$    
   gcode$ = 0
   if rotaxis$ = 0, n$, "L", *zr$, sgcode, e$

pcancelcc$  # Cancel canned drill cycle
#endregion

#region percages_5axes

#region si_dev_avec_decallage_G52
p_drill_5axes_commun_debut
	if Mode_reglage_PP = 0, n$, "--> pdrill_5_commun VOIR: ", e$ 	
	gcode$ = 0
	vx = u$ - x$
	vy = v$ - y$
	vz = w$ - z$
	longvec=sqrt(vx * vx + vy * vy + vz * vz)
	vx2 = (vx/longvec)
	vy2 = (vy/longvec)
	vz2 = (vz/longvec)
	if Mode_reglage_PP = 0, n$, "--> pdrill_5_commun VOIR: ", *vx, *vy, *vz, *longvec, *vx2, *vy2, *vz2, *m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$ 
	if diviseur = 1, [
		#m7$ = vx2
		m8$ = vy2
		m9$ = vz2
		]
	if diviseur = 2, [
		m7$ = vx2
		#m8$ = vy2
		m9$ = vz2
		]
	if type_dec_4x_percage = 1, [	#PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0
		tox4_ = 0	#((vx2 * abs(depth$)) + x$)
		toy4_ = 0 	#((vy2 * abs(depth$)) + y$)
		toz4_ = w$ 	#((vz2 * abs(depth$)) + z$)
		]
	if type_dec_4x_percage = 0, [	#PERCAGE EN ABSOLU PTs MC CLASSIQUE
		#n$, s_com_open, "PERCAGE EN ABSOLU PTs MC CLASSIQUE", s_com_close, e$
		]

p_drill_5axes_commun_fin
	n$, "--> p_drill_5axes_commun_fin", e$
	n$, sgcode, *xp, *yp, spdlon, e$
	n$, sgcode, *zp, p_lubrif_ON, e$  
	old_tox4 = tox4$    #memorisation pour affichage si changement dans ptlchg ou ptlchg 0
	old_toy4 = toy4$
	old_toz4 = toz4$
	old_x=xr$
	old_y=yr$
	old_z=zr$
	x$ = 0
	y$ = 0
	!x$,!y$,!z$,!xr$,!yr$,!zr$
#endregion 

p_drill_5axes   # ecriture pour TOUS LES percageS en 4 axes continus **AVEC** ZONE DE SECU G1 OU G0 
	if Mode_reglage_PP = 0, n$, "--> pdrill_5_1 VOIR", *x$, *y$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$, 
		*m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$ 
	if old_op = 11, [	#force le "A/B" après le pmx$
		gcode$ = 0
		p_calcul_rot_pmx 
		n$, "L", p_axeAB_pmx, *sgcode, e$
		if mi7$ = 1, bloque = 2, bloque = 1, n$, sbloque, e$ 
		old_op = -1
		]
	#p_Z_mini_maxi_OP
	gcode$ = 0	
	#xabs = xnci$ 
	#yabs = ynci$
	#p_drill_5axes_commun_debut 
	p_calcul_rot_pmx 
	
	bq204 = drl_sel_tos$	# test s'il y a une distance de sécurité 	
	n$, "L", *xabs, *yabs, p_lubrif_ON, *sgcode, e$ 	
	if mi7$ = 1, bloque = 2, n$, sbloque, e$ 
	n$, "L", p_axeAB_pmx, *sgcode, e$  
	if mi7$ = 1, bloque = 1, n$, sbloque, e$
	
	if drillref = 0 & drl_sel_ini$ = bq204, [				# ne pas remonter à la sécu entre 2	# reste en bas
		zabs_deb_fin_secu_p_5x = zabs + abs(depth$) + drl_sel_ref$ + refht$ + drl_sel_ini$ 	
		n$, *zabs_deb_fin_secu_p_5x, e$
		zabs_deb_fin_secu_p_5x = zabs + abs(depth$) + refht$
		n$, *zabs_deb_fin_secu_p_5x, e$
		] 		
	if drl_sel_ini$ > bq204, [
		zabs_deb_fin_secu_p_5x = zabs + drl_sel_ini$ + abs(depth$) + bq204 		# AVEC la SECU
		n$, *zabs_deb_fin_secu_p_5x, e$
		]
	#if drl_sel_ini$ = SDIS, zabs = zabs + abs(depth$) + drl_sel_ref$ 		# SANS la SECU
			
	debutpmx = 1
	if t$ <> old_t, [
		#n$, "TRANS", tox4$, toy4$, toz4$, e$
		#n$, "; ATTENTION PERCAGE 4 AXES", e$
		#p_degage_4_axes
		#old_t = t$
		]
	comment$
	if type_dec_4x_percage = 1, [	#PERCAGES EN RELATIF DEPUIS LE NOUVEAU PT XYZ0	
		n$, "TRANS", *tox4$, *toy4$, *toz4$, e$
		xnci$ = 0
		ynci$ = 0
		]
	if type_dec_4x_percage = 0, [	#PERCAGE EN ABSOLU PTs MC CLASSIQUE
		#"ICI 4 AXES -------------------------", e$
		]

p_drill_5axes_2   # ecriture DE TOUS LES percageS SUIVANTS en 4 axes continus **SANS** la ZONE DE SECU
	if Mode_reglage_PP = 0, n$, "--> pdrill_5_2 VOIR", *x$, *y$, *xnci$, *ynci$, *znci$, *u$, *v$, *w$, 
		*m9$, *m8$, *m7$, *m6$, *m5$, *m4$, *m3$, *m2$, *m1$, e$ 	
	#p_drill_5axes_commun_debut
	p_correc_time_G0
	if type_dec_4x_percage = 1, [
		if tox4$ <> old_tox4 | toy4$ <> old_toy4 | toz4$ <> old_toz4 | w$ <> old_w_, [ 
			n$, "; SUIVANT VALEURS MC", e$
            n$, "CYCL DEF 7.0 POINT ZERO", e$
            n$, "CYCL DEF 7.1 ", tox4$, e$
            n$, "CYCL DEF 7.2 ", toy4$, e$
            n$, "CYCL DEF 7.3 ", toz4$, e$
			]
    	xnci$ = 0
    	ynci$ = 0
    	z$ = refht$
    	zp = z$
		]
    p_calcul_rot_pmx 
	
	if axeA = 0, bq204 = zr$ - bq203	 
	else, bq204 = refht$ - drl_sel_tos$	# test s'il y a une distance de sécurité 	
	
	if drillref = 0 & drl_sel_ini$ = bq204, [				# ne pas remonter à la sécu entre 2	# reste en bas
		zabs_deb_fin_secu_p_5x = zabs + abs(depth$) + refht$ 	
		] 		
	if drl_sel_ini$ > bq204, [
		zabs_deb_fin_secu_p_5x = z$ + drl_sel_ini$ + abs(depth$) 								# AVEC la SECU
		]
	#if drl_sel_ini$ = SDIS, zabs = zabs + abs(depth$) + drl_sel_ref$ 							# SANS la SECU				
		
	pdril5x_annul
	#*old_axeA, *epsi, e$	
	if epsi <> 0, [
		p_Z_SECU_ret_5x
		if mi7$ = 1, bloque = 2, n$, sbloque, e$	# si ROT - Débloque
		gcode$ = 0
		n$, "L", p_axeAB_pmx, *sgcode, e$	
		if mi7$ = 1, bloque = 1, n$, sbloque, e$	# si ROT - Bloque
		epsi = 0
		]
	old_bq203_5x = bq203

p_Z_SECU_ret_5x	# si après rotation le Z est > alors remonter au Z suivant avant
	if opcode$ = 16 & bq204 > old_bq204, [
			if axeA = 0, zabs = bq203 + bq204
			gcode$ = 0
			n$, "L", *zabs, *sgcode, e$
			]	
						
pdril5x_annul   # annulation percage 5 axe A  la FIN des trous sur un mEme plan
	if Mode_reglage_PP = 0, n$, "--> pdril5x_annul", e$
	spaces$ = 1
	if epsi <> 0 | nextop$ = 80 | gcode$ = 80 | nextop$ = 1003, [
		gcode$ = 0
		if drillref = 0, [
			zabs_deb_fin_secu_p_5x = zabs + drl_sel_ini$ + abs(depth$) + bq204
			n$, "L", *zabs_deb_fin_secu_p_5x, *sgcode, e$
			]
		]
	if type_dec_4x_percage = 1, p_ori_usi_annul
	gcode$ = 0
#endregion

#endregion

#region erreurs
#-------------------------------------------------------------------------
s_erreur_message_0 		: ""
s_erreur_message 		: ""
serreur         		: ""
serreur2        		: "nbr_combi_axes > 1, qu'une combinaison d'axe par programme"
serreur2_2        		: "Utilisation d'un BLOCK de revoie d'angle ou nbr_combi_axes > 1, qu'une combinaison d'axe par programme"
serreur3        		: "combinaison d'axe impossible, rotation en X sur B MODIFIER LE PLAN DE ROTATION"
serreur4        		: "combinaison d'axe impossible, rotation en Y sur A MODIFIER LE PLAN DE ROTATION"
serreurTar      		: "Erreur - Taraud avec un autre cycle"
serreurCC_Cor   		: "ATTENTION PRISE DE CORRECTION OU ANNULATION SUR UN CERCLE"
serreurPar_perc 		: "ATTENTION BQ256 NE PEUT ETRE A 0"
serreurPalp1    		: "ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
serreurPalp2    		: "ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
serreurPalp3    		: "ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
serreur_vit_broche 		: "ATTENTION -BROCHE SANS VITESSE-"
s_erreur_origine_plan 	: "ATTENTION coordonnée de l'origine du plan incliné ne correspond à l'origine de base"  
s_erreur_Nom_RUD 		: "ATTENTION *** RUDs DIFFERENTS dans un meme programme ****"  
s_erreur_prof_passe 	: "ATTENTION ***renseigner la profondeur de passe au PERCAGE"
s_erreur_pas_fil 		: "ATTENTION RENSEIGNER LE PAS DU FILETAGE à la fraise"    
#s_mess_per_prof 		: "ATTENTION METTRE S/10 SUR LE FORET TRES LONG. LE PP *10" 
#s_mess_per_prof2 		: "ATTENTION METTRE -F- A LA BONNE VALEUR SUR LE FORET TRES LONG."
#s_mess_per_prof3 		: "ATTENTION -S- DE DEPART > 500 Tr/mn A MODIFIER DANS L'ISO !"
s_erreur_pas_fil2 		: "ATTENTION l'outil et l'opération non pas le meme PAS !" 
s_erreur_num_outil 		: "ATTENTION le numéro d'outil dépasse les 30 !" 
s_erreur_tranf_plan 	: "ATTENTION transformation PLAN à plat ! Rotation sur Z !" 
s_erreur_origine_plan2 	: "- POUR INFO - il peut Etre utilisE avec plusieurs piEces"  
s_erreur_dif_T_H_D 		: "ATTENTION num. d'outil est different du num -H- ou -D- !" 
s_erreur_avance_fil 	: "ATTENTION l'avance de filetage à la fraise est TROP importante !" 
s_erreur_avanceS 		: "ATTENTION **INFORMER LA VALEUR DE --F-- DANS L OUTIL***" 
s_erreur_choix_axe 		: "ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
s_erreur_nbr_axes_rot 	: "le pst ne supporte q'un axe rotatif"
s_erreur_choix_cycle_palpage 		: "CYCLES DE PALPAGES NON AUTORISE, VEUILLEZ CONTACTER FICAM POUR LES UTILISER"
s_erreur_stock_shape 				: "ERREUR - CONFIG. DU BRUT - Seulement rectangulaire ou Cylindrique supportEs CN." + no2asc(13) + no2asc(13) + "Info dans l'ISO, Solide-Maillage, Stl"
s_erreur_inclinaison_OP_5axes 		: "ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"
s_erreur_num_block_renvoie_angle 	: "ATTENTION ! Le numéro d'outil doit etre identique au numéro du BLOCK ORIENTABLE !"
s_erreur_angles_renvoie_angle 		: "ATTENTION ! L'ANGLE du PLAN n'est pas identique à l'angle du BLOCK ORIENTABLE !"
s_erreur_lub_perc_prof 				: "ATTENTION ! Opération de perçage très profond : l'arrosage sélectionné n'est pas au CENTRE OUTIL"
s_erreur_choix_palette 				: "erreur de choix de palette 1(A) ou 2(B) indiquez le nbr de pièces sur une des 2 palettes"
s_erreur_choix_axe_substitution 	: "ATTENTION ! erreur sur le choix de l'axe de substitution ! A CHANGER"
s_erreur_config_type_arc			: "ATTENTION ! erreur de config d'arcs au niveau armoire UNIQUEMENT -ABSOLU- ou -R- en HEIDENHAIN"
s_erreur_config_type_arc2			: "Veuillez le modifier dans la config. armoire"
s_erreur_config_type_arc3			: "Pour utiliser ce mode mettre la variable-erreur_type_arcs- liqne 146 du post-pro à -0-"
s_erreur_angles_renvoie_angle_2     : "ATTENTION ! L'ANGLE du PLAN n'est pas pris en charge par l'angle du BLOCK ORIENTABLE !"
s_erreur_S_maxi_renvoi_angle		: "ATTENTION ! S de rotation > S autorisé avec le renvoi d'angle --> la vitesse de broche passe au MAXIMUM AUTORISE!" 
s_erreur_angle_renvoi_fixe			: "ATTENTION ! Ce renvoi d'angle n'autorise pas de rotations !" 
s_erreur_val_C_MM_perc				: "ATTENTION ! la valeur du choix du type % mm ne peut Etre à 0"  
s_erreur_val_inf_perc				: "ATTENTION ! la valeur Z de l'ammorce de perçage doit Etre inf."

p_erreur_messages
	if affiche_num_op_MC = 1, s_erreur_message_0 = "ATTENTION ERREUR A L'OP: " + s_old_spost_arg_2 + " AVEC L'OUTIL N° " + no2str(t$)
	if affiche_num_op_MC = 2, s_erreur_message_0 = "ATTENTION ERREUR A L'OP: " + no2str(op_number) + " AVEC L'OUTIL N° " + no2str(t$)
    result = mprint(s_erreur_message_0)

perreurTaraud   #"Erreur - Taraud avec un autre cycle"
    if paramT2 = 4 | paramT2 = 5, 
		[   
        "ERREUR NUM: 1", s_erreur_message_0, e$
        result = mprint(serreurTar)
		p_erreur_messages
        exitpost$
        ]

perreurCC_COR   #"ATTENTION PRISE DE CORRECTION OU ANNULATION SUR UN CERCLE"
    if cc$ =41 | cc$ = 42 | cc$ =40 | cc$ = 140, 
		[
        p_erreur_messages
		"ERREUR NUM: 2", s_erreur_message_0, e$
        result = mprint(serreurCC_Cor)
        exitpost$
        ]

perreurPar_perc #"ATTENTION BQ256 NE PEUT ETRE 0"
    if bq256 = 0, 
		[
        p_erreur_messages
		"ERREUR NUM: 3", s_erreur_message_0, e$
        result = mprint(serreurPar_perc)
        exitpost$
        ]

perreurPalp1    #"ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
    if (drl_prm1$ = 1 & drl_prm2$ = 1) | (drl_prm1$ = 0 & drl_prm2$ = 0), 
		[
		p_erreur_messages
        "ERREUR NUM: 4", s_erreur_message_0, e$
        result = mprint(serreurPalp1)
        exitpost$
        ]

perreurPalp2    #"ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
    if drl_prm6$ < 1, 
		[
		p_erreur_messages
        "ERREUR NUM: 5", s_erreur_message_0, e$
        result = mprint(serreurPalp2)
        exitpost$
        ]

perreurPalp3    #"ATTENTION SELECTIONNER LES PARAM. DU CYCLE **DANS PARAMETRES**"
    if drl_prm8$ < 1 , 
		[
		p_erreur_messages
        "ERREUR NUM: 6", s_erreur_message_0, e$
        result = mprint(serreurPalp3)
        exitpost$
        ]

perreur_vit_broche #"ATTENTION -BROCHE SANS VITESSE-"
    if ssa = 0 & (nextdc$ < 8 | nextdc$ > 19),    
		[
		p_erreur_messages
        #"ERREUR NUM: 7", s_erreur_message_0, e$
        result = mprint(serreur_vit_broche)
        #exitpost$
        ]

Perreur_origine_plan    #	OBSOLETE --> GENERE UN DECALLAGE DE COORDONNEES G52/TRANS/DEF 7 ... 
	if Val_origine_Z <> Old_Val_origine_Z | Val_origine_Y <> Old_Val_origine_Y | Val_origine_X <> Old_Val_origine_X,
    	[
		p_erreur_messages
        "ERREUR NUM: 8", s_erreur_message_0, e$
		result = mprint(s_erreur_origine_plan)
        result = mprint(s_erreur_origine_plan2)
        #exitpost$
        ]

Perreur_nom_RUD         # 2 ruds differents utilises dans un mEme programme
    if snom_RUD <> Sold_snom_RUD,
        [
		p_erreur_messages
        #"ERREUR NUM: 9", s_erreur_message_0, "REGENERER OPs SI BESOIN", e$
        #s_erreur_Nom_RUD, e$
        result = mprint(s_erreur_Nom_RUD)
        #exitpost$
        ]
    Sold_snom_RUD = snom_RUD

Perreur_prof_passe  #"ATTENTION ***renseigner la profondeur de passe au PERCAGE"
    if bq202 = 0, [
		p_erreur_messages
        "ERREUR NUM: 10", s_erreur_message_0, e$
        s_erreur_prof_passe, e$
        result = mprint(s_erreur_prof_passe)
        #exitpost$
        ]

perreur_pas_fil  # "ATTENTION RENSEIGNER LE PAS DU FILETAGE à la fraise"
    if tool_op$ = 100,    
		[
        if pas_filetage = 9.999, [  # "ATTENTION RENSEIGNER LE PAS DU FILETAGE à la fraise"
            p_erreur_messages
			"ERREUR NUM: 11", s_erreur_message_0, e$
            result = mprint(s_erreur_pas_fil)
            exitpost$
            ]
        if pas_filetage <> paramT7, [   # ""ATTENTION l'outil et l'opération non pas le meme PAS !""
            p_erreur_messages
			"ERREUR NUM: 12", s_erreur_message_0, e$
            result = mprint(s_erreur_pas_fil2)
            exitpost$
            ]
        p_erreur_avance_fil 
        ]

perreur_num_outil  # "ATTENTION le numéro d'outil dépasse les 30 !" 
    if t$ >60,    
		[
        #p_erreur_messages
		#"ERREUR NUM: 13", s_erreur_message_0, e$
        #result = mprint(s_erreur_num_outil) 
        #exitpost$
        ]

perreur_tranf_plan # "ATTENTION transformation PLAN à plat !  Rotation sur Z !" 
    if (diviseur = 1 & m1$ <> 1) | (diviseur = 2 & m5$ <> 1), 
		[
        p_erreur_messages
		"ERREUR NUM: 14", s_erreur_message_0, e$
        "ATTENTION VERIFIER SI LE NOUVEAU PLAN EST BIEN D EQUERRE PAR RAPPORT AU RUD", e$
        result = mprint(s_erreur_tranf_plan)
		n$, *m1$, *m2$, *m3$, *m4$, *m5$, *m5$, *m7$, *m8$, *m9$, e$		
        ]
    if diviseur = 1 & m1$ <> 1, 
		[
		p_erreur_messages
        "ERREUR NUM: 15", s_erreur_message_0, e$
		"ROTATION AXE MACHINE = ", s_axe_rot_A, e$
        "SOLUTION CREER LE NOUVEAU PLAN PAR RAPPORT AU RUD AVEC -PLAN ROTATION- DE X DEG. EN X,Y OU Z", e$
        ]
    if diviseur = 2 & m5$ <> 1, 
		[
		p_erreur_messages
        "ERREUR NUM: 16", s_erreur_message_0, e$
		"ROTATION AXE MACHINE = ", s_axe_rot_B, e$
        "SOLUTION CREER LE NOUVEAU PLAN PAR RAPPORT AU RUD AVEC -PLAN ROTATION- DE X DEG. EN X,Y OU Z", e$
        ]

p_erreur_dif_T_H_D # "ATTENTION num. d'outil est different du num -H- ou -D- !"
    if t$ <> tloffno$ | t$ <> tlngno$ & opcode$ <> 3,
        [
		#p_erreur_messages
        #"ERREUR NUM: 17", s_erreur_message_0, e$
        #s_erreur_dif_T_H_D, e$
        #result = mprint(s_erreur_dif_T_H_D)
		#result = mprint(s_erreur_message_0)
        #exitpost$
        ]

p_erreur_avance_fil # "ATTENTION l'avance de filetage à la fraise est TROP importante !"
    if fr$ > 500,    
		[
		p_erreur_messages
        "ERREUR NUM: 18", s_erreur_message_0, e$
		"ATTENTION l'avance de filetage à la fraise est TROP importante !", e$
        result = mprint(s_erreur_avance_fil)
        ]

p_erreur_avanceS    #: "ATTENTION **INFORMER LA VALEUR DE --F-- DANS L OUTIL***"
	if drillcyc$ > 0 & (frplunge$ = 0 | fr_pos$ = 0),    
		[
		p_erreur_messages
        "ERREUR NUM: 19", s_erreur_message_0, e$
		"ATTENTION l'avance -F- EST A --0-- !", e$
        #*drillcyc$, *frplunge$, *fr_pos$, *fr$, e$
        result = mprint(s_erreur_avanceS)
        ]

p_erreur_choix_axe    #: "ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
    p_erreur_messages
	"ERREUR NUM: 20", s_erreur_message_0, e$
	"ATTENTION **CE POST-PROCESSEUR N'EST PAS PREVU POUR CETTE ROTATION D'AXE !"
    result = mprint(s_erreur_choix_axe)
    if diviseur = 1, "ROTATION AXE :", s_axe_rot_B, e$
    if diviseur = 2, "ROTATION AXE :", s_axe_rot_A, e$
	
p_erreur_cycle_palpage
	p_erreur_messages
	"ERREUR NUM: 21", s_erreur_message_0, e$
	n$, "CYCLES DE PALPAGES NON AUTORISE, VEUILLEZ CONTACTER FICAM POUR LES UTILISER", e$
	result = mprint(s_erreur_choix_cycle_palpage)

p_erreur_inclinaison_OP_5axes    #: "ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"
    p_erreur_messages
	"ERREUR NUM: 22", s_erreur_message_0, e$
	"ATTENTION **UNE INCLINAISON IMPOSSIBLE SUR CETTE MACHINE EST DEMANDEE EN OPERATION 5 AXES !"	
	"VEUILLEZ BLOQUER UN AXE SI POSSIBLE DANS L'OPERATION OU CHANGER D'OPERATION"
    result = mprint(s_erreur_inclinaison_OP_5axes)
	exitpost$

p_erreur_num_block_renvoie_angle
	if t$ <> ra_block$, 
		[
		p_erreur_messages
		"ERREUR NUM: 23", s_erreur_message_0, e$
		result = mprint(s_erreur_num_block_renvoie_angle)
		exitpost$
		]

p_erreur_angles_renvoie_angle 
	if ANGLE_XY_renvoie_angle <> Angle_PLAN_MC_renvoie_angle, 
		[
		p_erreur_messages
		"ERREUR NUM: 24", s_erreur_message_0, e$
		result = mprint(s_erreur_angles_renvoie_angle)
		exitpost$
		]

p_erreur_lub_perc_prof
	if coolantx <> 4, [
		result = mprint(s_erreur_lub_perc_prof)
		]

p_erreur_choix_axe_substitution 
	if diviseur = 1 & (rotaxis$ = -1 | rotaxis$ = 1), [
		p_erreur_messages
		"ERREUR NUM: 27", s_erreur_message_0, e$
		result = mprint(s_erreur_choix_axe_substitution)
		exitpost$
		]
	if diviseur = 2 & (rotaxis$ = -2 | rotaxis$ = 2), [
		p_erreur_messages
		"ERREUR NUM: 28", s_erreur_message_0, e$
		result = mprint(s_erreur_choix_axe_substitution)
		exitpost$
		]

p_erreur_config_type_arc
	s_com_open, "ERREUR NUM: 29", s_com_close, e$
	result = mprint(s_erreur_config_type_arc)
	result = mprint(s_erreur_config_type_arc2)
	result = mprint(s_erreur_config_type_arc3)

p_erreur_angles_renvoie_angle_2		# ICI ANGLES FIXES A INDIQUER --> ICI TETE A 4 fois 90DEG
	if Angle_PLAN_MC_renvoie_angle <> 0 | Angle_PLAN_MC_renvoie_angle <> 90 | 
			Angle_PLAN_MC_renvoie_angle <> 180 | Angle_PLAN_MC_renvoie_angle <> 270, [
        p_erreur_messages
        "ERREUR NUM: 30", s_erreur_message_0, e$
        result = mprint(s_erreur_angles_renvoie_angle_2)
        exitpost$
        ]	
		
p_erreur_perc_decomposes
	#if perc_1er_perc_pour_C_ou_mm = 0, [
		#p_erreur_messages
		#"ERREUR NUM: 31", s_erreur_message_0, e$
		#result = mprint(s_erreur_val_C_MM_perc)
		#]
	if P_er_perc_0 < P_er_perc_1 | peck1$ < P_er_perc_1, [
		p_erreur_messages
		"ERREUR NUM: 32", s_erreur_message_0, e$
		result = mprint(s_erreur_val_inf_perc)
		]
					
#endregion

#region entete_OP_commentaires
#**************************** Affichage des commentaires de début d'OP en entete Prog.
stextentete : ""
stextecoupe : ""
svirgule : ","
sposiNomprog : "/PROGRAMMEUR/"
sposiClient : "/CLIENT/"
sposiPiece : "/NOM PIECE/"
sposiNumplan : "/NUM PLAN/"
sposiIndiceplan : "/INDICE/"
#Textes origines
sposiX  : "/X/"
sposiY  : "/Y/"
sposiZ  : "/Z/"
#Texte Orientation
sposiOrient : "/ORIENTATION/"
#Texte Divers
sposInfos : "/INFO/"
#sposivirgule : ""    # la virgule indique le saut à la ligne
sSlash : "/"

fmt 7 posiNomprog
fmt 7 posiClient
fmt 7 posiNomPiece
fmt 7 posiNumplan
fmt 7 posiIndiceplan
fmt 7 posiX
fmt 7 posiY
fmt 7 posiZ
fmt 7 posiOrientation
fmt 7 posiInfo
fmt 7 posivirgule
fmt 7 posicoupe
fmt 7 posiSlash
fmt 7 long_TEXTE

ptextentete

    stextentete = scomm$
    long_TEXTE = strlen(stextentete)    
    posiNomprog = strstr(sposiNomprog, stextentete)
    posiClient = strstr(sposiClient, stextentete)
    posiNomPiece = strstr(sposiPiece, stextentete)
    posiNumplan = strstr(sposiNumplan, stextentete)
    posiIndiceplan = strstr(sposiIndiceplan, stextentete)
    posiX = strstr(sposiX, stextentete)
    posiY = strstr(sposiY, stextentete)
    posiZ = strstr(sposiZ, stextentete)
    posiOrientation = strstr(sposiOrient, stextentete)
    posiInfo = strstr(sposInfos, stextentete)
    #posivirgule = strstr(svirgule, stextentete)
    posiSlash = strstr(sSlash, stextentete)

    longTexte = 1           
    if posiNomprog <>0,
        [
        posicoupe = posiNomprog+13
        pcoupetexte
        n$, " ; PAR:", stextecoupe, e$
        ]
    if posiClient >0,
        [
        posicoupe = posiClient+8
        pcoupetexte
        n$, " ; CLIENT:", stextecoupe, e$
        ]
    if posiNomPiece >0,
        [
        posicoupe = posiNomPiece+11
        pcoupetexte
        n$, " ; PIECE:", stextecoupe, e$
        ]
    if posiNumplan >0,
        [
        posicoupe = posiNumplan+10
        pcoupetexte
        n$, " ; PLAN:",stextecoupe, e$
        ]
    if posiIndiceplan >0,
        [
        posicoupe = posiIndiceplan+8
        pcoupetexte
        n$, " ; INDICE:",stextecoupe, e$
        ]
    if posiX >0,
        [
        posicoupe = posiX+3
        pcoupetexte
        n$, " ; ORIGINE:", e$, n$, " ; X:", stextecoupe, e$
        ]
    if posiY >0,
        [
        posicoupe = posiY+3
        pcoupetexte
        n$, " ; Y:", stextecoupe, e$
        ]
    if posiZ >0,
        [
        posicoupe = posiZ+3
        pcoupetexte
        n$, " ; Z:",stextecoupe, e$
        ]
    if posiOrientation >0,
        [
        posicoupe = posiOrientation+13
        pcoupetexte
        n$, " ; ORIENTATION PIECE: ",e$, n$, " ;", stextecoupe, e$
        ]
    if posiInfo >0,
        [
        posicoupe = posiInfo+6
        pcoupetexte
        n$, " ; *****************************",e$
        n$, " ;", stextecoupe, e$
        ]
    #if posivirgule > 0,
        #[
        #posicoupe = posivirgule+1
        #pcoupetexte
        #n$, " ;",stextecoupe, e$
        #]
    if posiSlash = 0 & long_TEXTE > 0,
        [
        n$, " ;", scomm$, e$
        ]

pcoupetexte #coupe le texte
            stextecoupe = brksps(posicoupe, stextentete)

#endregion

#region Type_d_opErations
# Type d'operation
s_too_lop_0    : "NON DEFINIT"
s_too_lop_1    : "CONTOUR"
s_too_lop_2    : "PERCAGE"
s_too_lop_3    : "POCHE"
s_too_lop_4    : "TRANSFORMATION-MIRROR ROTATE TRANSLATE"
s_too_lop_5    : "MULTI-SURF. EBAUCHE PARALLELLE"
s_too_lop_6    : "MULTI-SURF. EBAUCHE RADIALE"
s_too_lop_7    : "MULTI-SURF. EBAUCHE PROJECTION"
s_too_lop_8    : "MULTI-SURF. EBAUCHE ISOPARAM"
s_too_lop_9    : "MULTI-SURF. EBAUCHE CONTOUR"
s_too_lop_10   : "MULTI-SURF. EBAUCHE POCHE"
s_too_lop_11   : "MULTI-SURF. FINIT. PARALLELLE"
s_too_lop_12   : "MULTI-SURF. FINIT. RADIALE"
s_too_lop_13   : "MULTI-SURF. FINIT. PROJECTION"
s_too_lop_14   : "MULTI-SURF. FINIT. ISOPARAM"
s_too_lop_15   : "MULTI-SURF. FINIT. CONTOUR"
s_too_lop_16   : "OPERATION PAR C-HOOK"
s_too_lop_17   : "ENTREE MANUELLE"
s_too_lop_18   : "CERCLE"
s_too_lop_19   : "POINT"
s_too_lop_20   : "LIMITATION"
s_too_lop_21   : "REGLE"
s_too_lop_22   : "REVOLUTION"
s_too_lop_23   : "LETTRE"
s_too_lop_24   : "BALAYEE 2D"
s_too_lop_25   : "BALAYEE 3D"
s_too_lop_26   : "CARREAU"
s_too_lop_27   : "SECTION"
s_too_lop_28   : "PERCAGE 5-AXES"
s_too_lop_29   : "COURBE 5-AXES"
s_too_lop_30   : "PROJECT. SUR UN PLAN"
s_too_lop_31   : "PROJECT. SUR UN CYLINDRE"
s_too_lop_32   : "PROJECT. SUR UNE SPHERE"
s_too_lop_33   : "PROJECT. SUR UN CONE"
s_too_lop_34   : "PROJECT. SUR UNE SECTION"
s_too_lop_35   : "PROJECT. SUR UNE SURFACE"
s_too_lop_36   : "NON-ASSOCIATIF CONTOUR"
s_too_lop_37   : "NON-ASSOCIATIF PERCAGE"
s_too_lop_38   : "NON-ASSOCIATIF POCHE"
s_too_lop_39   : "MULTI-SURF. FINIT. PENCIL TRACE"
s_too_lop_40   : "MULTI-SURF. FINIT. LEFTOVER STOCK"
s_too_lop_41   : "MULTI-SURF. FINIT. STEEP"
s_too_lop_42   : "MULTI-SURF. FINIT. SHALLOW"
s_too_lop_43   : "MULTI-SURF. FINIT. CONSTANT SCALLOP"
s_too_lop_44   : "MULTI-SURF. EBAUCHE PLUNGE"
s_too_lop_45   : "MULTI-SURF. FINIT. 5-AXE ISOPARAM"
s_too_lop_46   : "MULTI-SURF. FINIT. 4-AXE"
s_too_lop_47   : "MERGED IN ASCII NCI"
s_too_lop_48   : "5-AXE SWARF"
s_too_lop_49   : "5-AXE ROLL DIE"
s_too_lop_50   : "NON DEFINIT"
s_too_lop_51   : "CONTOURNAGE AXIAL"
s_too_lop_52   : "CONTOURNAGE RADIAL"
s_too_lop_53   : "CONTOURNAGE AXE C"
s_too_lop_54   : "VE PERCAGE, NOT USED NON-ASSOCIATI"
s_too_lop_55   : "PERCAGE AXIAL"
s_too_lop_56   : "PERCAGE RADIAL"
s_too_lop_57   : "PERCAGE AXE C"
s_too_lop_58   : "NON DEFINIT"
s_too_lop_59   : "NON DEFINIT"
s_too_lop_60   : "EBAUCHE"
s_too_lop_61   : "FINITION"
s_too_lop_62   : "GORGE"
s_too_lop_63   : "FILETAGE"
s_too_lop_64   : "PERCAGE"
s_too_lop_65   : "POINT"
s_too_lop_66   : "DRESSAGE"
s_too_lop_67   : "TRONCONNAGE"
s_too_lop_68   : "GORGE"
s_too_lop_69   : "ENTREE MANUELLE"
s_too_lop_70   : "MERGED ASCII"
s_too_lop_71   : "NON DEFINIT"
s_too_lop_72   : "NON DEFINIT"
s_too_lop_73   : "NON DEFINIT"
s_too_lop_74   : "CONTOUR FIL"
s_too_lop_75   : "CYCLE FIL"
s_too_lop_76   : "POCHE FIL"
s_too_lop_77   : "ENTREE MANUELLE FIL"
s_too_lop_78   : "POINT FIL"
s_too_lop_79   : "4-AXES FIL"
s_too_lop_80   : "TRANSFORMATION FIL"
s_too_lop_81   : "ASSOCIATIVE TRIMMED FIL"
s_too_lop_82   : "MERGED IN ASCII NCI FIL"
 
s_too_lop_100  : "FILETAGE A LA FRAISE"				# +18
s_too_lop_101  : "EDIT COMMON OPERATION PARAMETERS"
s_too_lop_102  : "SURFACAGE"
s_too_lop_103  : "ASSOCIATIF LIMITATION"
s_too_lop_104  : "CONTROL OPERATION SOLID PERCAGE"
s_too_lop_105  : "SLOT MILL"
s_too_lop_106  : "HELIX BORE"
s_too_lop_107  : "MULTI-SURF. EBAUCHE REPRISE"
s_too_lop_108  : "ASSOCIATIF NESTING CONTAINER OPERATION"

s_too_lop_201  : "CYCLE FINITION"					# +83
s_too_lop_202  : "CYCLE EBAUCHE"
s_too_lop_203  : "CYCLE EBAUCHE ET FINITION"
s_too_lop_204  : "CYCLE EBAUCHE DRESSAGE"
s_too_lop_205  : "CYCLE EBAUCHE ET FINITION DRESSAGE"
s_too_lop_206  : "CYCLE MODEL REPETITION EBAUCHE"
s_too_lop_207  : "CYCLE MODEL REPETITION EBAUCHE ET FINITION"
s_too_lop_208  : "CYCLE GORGE EBAUCHE"
s_too_lop_209  : "CYCLE GORGE FINITION"
s_too_lop_210  : "RAPIDE EBAUCHE"
s_too_lop_211  : "RAPIDE FINITION"
s_too_lop_212  : "RAPIDE GORGE"
s_too_lop_213  : "OPERATION GENEREE PAR C-HOOK"
s_too_lop_214  : "TRANSFER BRUT"
s_too_lop_215  : "RETOURNE BRUT"
s_too_lop_216  : "AVANCE BARRE"
s_too_lop_217  : "SERRAGE - DESSERAGE MORS"
s_too_lop_218 : "Tailstock operation"
s_too_lop_219 : "Steadyrest operation"
s_too_lop_220 : "Pinch-turn operation"
s_too_lop_221 : "Custom operation with tool" 
s_too_lop_222 : "Custom operation without tool" 
s_too_lop_223 : "Custom operation reference"
s_too_lop_224 : "Plunge turn (chained geometry)"
s_too_lop_225 : "Plunge turn (point geometry)"
s_too_lop_226 : "Turret park operation"
s_too_lop_227 : "Custom threading"
s_too_lop_228 : "B-axis contour turning (Mill-Turn only)"
s_too_lop_229 : "--------"
s_too_lop_230 : "Simple bar feed (Mill-Turn only)"
s_too_lop_231 : "Bar feed with tool stop or tool pull (Mill-Turn only)"
s_too_lop_232 : "Spindle clamp/unclamp (Mill-Turn only)"
s_too_lop_233 : "Spindle advance/retract (Mill-Turn only)"
s_too_lop_234 : "Spindle sync (Mill-Turn only)"
s_too_lop_235 : "Tailstock advance/retract (Mill-Turn only)"
s_too_lop_236 : "Turret park (Mill-Turn only)"
s_too_lop_237 : "Center operation(Mill-Turn only)"
s_too_lop_238 : "Steady rest operation(Mill-Turn only)"
s_too_lop_239 : "Steady rest point operation(Mill-Turn only)" 

s_too_lop_416 : "ENGRAVING"  					# +77          
s_too_lop_439 : "ART"                  
s_too_lop_309 : "5AXMSURF"           
s_too_lop_441 : "SWARF 5AX"            
s_too_lop_442 : "MORPH 5AX"            
s_too_lop_443 : "PARALLEL 5AX"        
s_too_lop_444 : "ALONGCURVE 5AX"      
s_too_lop_445 : "MESH 5AX"           
s_too_lop_446 : "ROUGHING 5AX"         
s_too_lop_447 : "PROJECT 5AX"          
s_too_lop_448 : "CONVERT 5AX"          
s_too_lop_449 : "PORT EXPERT"          
s_too_lop_450 : "BLADE EXPERT"         
s_too_lop_451 : "ROTARY ADV"           
s_too_lop_459 : "DEBURR"               
s_too_lop_460 : "EBAUCHE 3+2 AUTOM."  
s_too_lop_461 : "UNIFIE"               

s_too_lop : ""
fstrsel s_too_lop_0 tool_op$ s_too_lop 147 -1
#endregion

#region infos_outils_liste
#------------------Liste des OUTILS---------------------------------------------------
smanu : ""
svide : " "
smand : ""                       	# string info outil texte dans "mandrin" (chuck name)
snom_porte_outil : ""             	#
snom_assemblage_outil_porte_outil : "" 	
sposi_porte_out_def : "Porte"   	# string test prEsence "porte outil par dEfaut"
fmt       7 posi_porte_out_defaut 	
fmt       7 longsmand             
fmt       4 paramT1                	# N° outil
fmt       2 paramT2                 # Type d'outil
fmt       2 paramT3                 # Matiere de l'outil 1=Rapide 2=carbure 3=carbure revetu 4=cermet 5=borzon
fmt       2 paramT4                 # Type de rayon de bout 0=aucun 1=torique 2=spherique
fmt "D=" 11 paramT5               	# Diametre
fmt "R=" 11 paramT6               	# Rayon de bout
fmt "P=" 11 paramT7             	# PAS / Nombre de filet par mm
fmt "A=" 11 paramT8               	# Angle de bout
fmt       2 paramT9                 # N° de correcteur de rayon
fmt       2 paramT10                # N° de correcteur de longeur
fmt       2 paramT11                # Avance travail
fmt       2 paramT12                # Avance plongee
fmt       2 paramT13                # Avance retraction
fmt       2 paramT14                # Vitesse de broche
fmt       2 paramT15                # Type de lubrification 0=arret 1=eau 2=air 3=broche 4=les 2
fmt "NBR-DENTS="  4 paramT16    	# Nombre de dents

# géométrie de l'outil
fmt   	  6 paramT20                # Diamètre pilote
fmt "EP=" 6 paramT21             	# Hauteur de coupe
fmt "HS=" 6 paramT22             	# Hauteur de sortie totale
fmt   	  6 paramT23                # Hauteur helice
fmt   	  6 paramT24                # Diametre de queue
fmt   	  6 paramT25                # Diametre porte-outil
fmt   	  6 paramT26                # Hauteur porte-outil
fmt   	  6 paramT27                # 0=sens horaire 1=sens horaire
fmt   	  6 paramT28                # % de la vitesse de coupe
fmt   	  6 paramT29                # % de l'avance par dent
fmt   	  4 paramT30                # 0=pouces 1=metrique

#RENVOIE D ANGLE Aggregate head parameters
fmt   	  3 paramT41   				# Head axis in X
fmt   	  3 paramT42   				# Head axis in Y
fmt   	  3 paramT43   				# Head axis in Z
fmt   	  3 paramT44   				# Head body type: (0 = cylinder, 1 = square)
fmt   	  3 paramT45   				# Head body diameter
fmt   	  3 paramT46   				# Head body length
fmt   	  3 paramT47   				# Station body type (0 = cylinder, 1 = square)
fmt   	  3 paramT48   				# Station body diameter
fmt   	  3 paramT49   				# LONG: SORTIE / pince--> face  pince -- Station body length

stypT00 : "FORME"
stypT01 : "FORET A C."
stypT02 : "FORET A P."
stypT03 : "FORET"
stypT04 : "TARAUD A D."
stypT05 : "TARAUD A G."
stypT06 : "ALESOIR"
stypT07 : "BARRE D ALES."
stypT08 : "FR. COUTEAU"
stypT09 : "FR. A EBAVUR."
stypT10 : "FR."
stypT11 : "FR. BOULE"
stypT12 : "FR. A CHANF."
stypT13 : "TOURTEAU"
stypT14 : "FR. 3 T."
stypT15 : "FR. CONCAVE"
stypT16 : "FR. QUEUE D ARONDE"
stypT17 : "FR. CONIQUE TRONQUEE"
stypT18 : "FR. SPHERIQUE"
stypT19 : "FR. TORIQUE"
stypT20 : "SPECIALE"
stypT21 : "FRAISE A GRAVER"
stypT22 : "FORET BRAD"
stypT23 : "BARRE D ALESAGE"
stypT24 : "FRAISE A FILETER"
stypT25 : "FRAISE TONNEAU"
stypT26 : "FRAISE DEPOUILLE"
stypT27 : "FRAISE LENTILLE"
stypT28 : "FRAISE LENTILLE TONNEAU"
stypT29 : "DIVERS"
stypeT : ""
fstrsel stypT00 paramT2 stypeT 30 -1

smatT0  : ""
smatT1  : "HSS"
smatT2  : "CA."
smatT3  : "CA. REVETU"
smatT4  : "CERMET"
smatT5  : "BORZON"
smatT6  : "BORZON"
smatT7  : "BORZON"
smatT8  : "BORZON"
smatT9  : "BORZON"
smatT10 : "INCONNU"
smatT : ""
fstrsel smatT0 paramT3 smatT 11 -1

ppas       # afficher ou non le pas
    if paramT7 > 0, *paramT7

ptypeBoutT # afficher on non le rayon de bout
    if paramT4 <> 0, *paramT6

pangleT    # afficher on non l'angle de l'outil
    if paramT2 = 2 | paramT2 = 3 | paramT2 = 9 | paramT2 = 12 | paramT2 = 13 | paramT2 = 16 | paramT2 = 17, *paramT8

phauteurT  # afficher la hauteur de dent pour une fraise 3 tailles
    if paramT2 = 14, paramT21

ptype      # Pour afficher le texte des outils perso suivant comment. dans "mandrin" (chuck name)
    longsmand = strlen(smand)
    #if longsmand > 5, *smand    # attention pas d'espaces dans cette case "mandrin"
    #else, *stypeT
    if longsmand > 3, *strtool$,
    else, *stypeT

pporte_outil
	posi_porte_out_defaut = strstr(sposi_porte_out_def, snom_porte_outil)
	spaces$ = 1
	if posi_porte_out_defaut < 1, [ 
		if Nom_porte_outil_entete = 1, n$, "; porte out.:", no_spc$, snom_porte_outil, *paramT22, e$ 
		if Nom_porte_outil_entete = 2, n$, "; Assemblage:", no_spc$, snom_assemblage_outil_porte_outil, *paramT22, e$
		if Nom_porte_outil_entete = 3, n$, "; porte out.:", no_spc$, snom_porte_outil, "Assemblage:", no_spc$, snom_assemblage_outil_porte_outil, *paramT22, e$
		if Nom_porte_outil_entete > 0 & ra_type$ = 1 & ra_block$ >0, n$, s_com_open, "RENVOIE D'ANGLE AVEC LONGUEUR DE L AXE Z A LA FACE DE :", *paramT49, s_com_close, e$ 
		]

pwrttparam$    # lire les parametres (des outils) avant la sortie de l'ISO
    if affiche_prmcodes = 0, "-->pwrttparam DONNEES avant la sortie de l'ISO", ~prmcode$, "=", ~sparameter$, e$
    if syncaxis$ <> old_syncaxis, nbr_combi = nbr_combi + 1
    old_syncaxis = syncaxis$
	if prmcode$ = 15166, workofs_pwrtt = rpar(sparameter$, 1)   #15166=Val origine de base 
																#15181=Val Numéro de l'origine actif
																#15333=Val départ incrément, op transformation 
	#if prmcode$ = 15334, workofs_dec = rpar(sparameter$, 1)	#15334=Val incrément, op transformation 
	if prmcode$ = 20002, smanu = sparameter$   
    if prmcode$ = 20003, smand = sparameter$   
    if prmcode$ = 20004, paramT1 = rpar(sparameter$, 16)
    if prmcode$ = 20007, paramT20 = rpar(sparameter$, 11)
    if prmcode$ = 20008, paramT41 = rpar(sparameter$, 9)
	if prmcode$ = 20005, perc_prof = rpar(sparameter$, 1)  	# lecture du type de perçage DE L'OUTIL ***valeur du cycle affecté à l'outil** 1= percage simple, 2 =débourrage ...
    #if prmcode$ = 12727, snom_porte_outil = sparameter$         
	if prmcode$ = 20020, snom_porte_outil = sparameter$ 
	if prmcode$ = 20021, snom_assemblage_outil_porte_outil = sparameter$ 
    longsmand = strlen (smand)

parrosage  # affichage de "arrosage au centre"
    if paramT15 = 2, "ARROSAGE AU CENTRE" 

s_cycle_dec	: ""
aff_cycle_dec	: 0	   	
pwrtt$      # Liste d'outils & infos (--> lecture avant traitement parcours)
    strtool$ = ucase(strtool$)
    # vErification des rotations avant le traitement ISO
    if m9$ <> 1, rotation_axe = 1               # Inclinaison des axes
    if nextop$ = 11, rotation_axe = 1			# useaxe = 1	#si pas de lecture def armoire en OP 5 axes seule
	if m1$ = 1 & m5$ <> 1, rotation_A = 1       # incliné en Y uniquement (et Z) = ROTATION SUR L'AXE X
    if m1$ <> 1 & m5$ = 1, rotation_B = 1       # incliné en X uniquement (et Z) = ROTATION SUR L'AXE Y
    if m1$ <> 1 & m5$ <> 1, rotation_axe = 2    # Erreur de plan
	if ra_type$ = 1 & ra_block$ >0, renvoi_d_angle = 1
	if ra_type$ = 1 & ra_block$ >0, rotation_axe = 0	# FORCE pas de 4 axes avec le RENVOI  
	
	# calcul nombre d'outils pour les temps
	# Temps de changement d'outil
	if t$ > 0, Nbr_outils = Nbr_outils + 1	# a changer
	
	if Affiche_temps_dll = 1, [ 	# TEMPS DE L OUTIL			
		if t$ > 0 & t$ <> old_t & old_t <> -9999, [		
			Types_Temps_DLL = plcval (s_Types_Temps_DLL, 2)
			if Types_Temps_DLL = 2, [
				p_Convert_time_dll 
				n$, "  ", s_com_open, "TPS OUT. = ", *Heure, *min, *sec, s_com_close, e$
				Tot_time_Out = 0
				]
			]
		]	

	# pour info : Type_infos_outil	 
	# 1 = NOM de l'outil "texte NOM" --> strtool$
	# 3 = NOM MC de l'outil et Infos géométrique réelle de l'outil
	# 4 = NOM de l'outil "texte NOM" & Infos géométrique réelle de l'outil --> = 0 + 2				
	if Liste_outils, [
	    if nom_outil = 1, [   
	        if t$ > 0, [
				n$, s_com_open, strtool$, 
					if Type_infos_outil	= 1, e$
					if Type_infos_outil	= 2 | Type_infos_outil= 4, "--", *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$ 
					if Type_infos_outil	= 3, "--", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, s_com_close, e$ 
				pporte_outil
				]
	        ]
	    if nom_outil = 0, [
	        if outils_param = 0, [	# sans les parametres
				if t$ > 0, [	            	
					if Type_infos_outil	= 1, n$, "; T", paramT1, strtool$, e$					
					if Type_infos_outil	= 2 | Type_infos_outil	= 3, n$, "; T", paramT1, ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  			
	            	if Type_infos_outil	= 4, n$, "; T", paramT1, strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  				
					pporte_outil
					]
				]
	        if outils_param = 1,  [  # avec les parametres
	            outil_paramT1 = paramT1
	            outil_paramT1 = outil_paramT1 + 1800    
				if t$ > 0, [
					if Type_infos_outil	= 1, n$, "FN 0: Q", outil_paramT1, "=", paramT1, "; T", paramT1, strtool$, e$	
					if Type_infos_outil	= 2 | Type_infos_outil	= 3, n$, "FN 0: Q", outil_paramT1, "=", paramT1, ";", ptype, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  
					if Type_infos_outil	= 4, n$, "FN 0: Q", outil_paramT1, "=", paramT1, ";", strtool$, *smatT, *paramT5, ptypeBoutT, pangleT, phauteurT, ppas, parrosage, e$  
					pporte_outil
					]					
				]
	        ]
		]		
	# Décalages d'origines en entête à afficher --> NE PAS LAISSER DE DECALLAGES VIDES --> METTRE UN "0"
	if affiche_ori_entete > 0, [	
		if affiche_ori_entete = 1 | affiche_ori_entete = 11, subout$ = 1	# sous la liste d'outil
		if affiche_ori_entete = 2 | affiche_ori_entete = 22, subout$ = 3	# dans un autre fichier
		compteur_workofs = compteur_workofs + 1
		if compteur_workofs = 1, n$, " ", e$, n$, s_com_open, "ORIGINES UTILISES : ", s_com_close, e$
		if workofs_pwrtt <> old_workofs, [
			if xform_op_id$ = op_id$, workofs_pwrtt_aff = workofs_pwrtt   						# OPERATIONS **NON** TRANSFORMEES 
			if xform_op_id$ <> op_id$ & workofs_dec > 0, workofs_pwrtt_aff = workofs$			# OPERATIONS TRANSFORMEES
			if Type_decalages = 2 & aff_cycle_dec = 0, s_cycle_dec = "CYCL DEF 247 : "
			if Type_decalages = 2 & aff_cycle_dec = 1, s_cycle_dec = "CYCL DEF 7 : " 
			if Type_decalages = 1, s_cycle_dec = "CYCL DEF 247 : "			# toujours 247
			#if (workofs_pwrtt_aff = -1 | workofs_pwrtt_aff = 0) & ori_1 =0, workofs_pwrtt_aff = 1, n$, s_com_open, "CYCLE DEF 247: ", *workofs_pwrtt_aff, s_com_close, e$, ori_1 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff <= 1 & ori_1 =0, workofs_pwrtt_aff = 1, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_1 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 2 & ori_2 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_2 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 3 & ori_3 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_3 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 4 & ori_4 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_4 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 5 & ori_5 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_5 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 6 & ori_6 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_6 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 7 & ori_7 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_7 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 8 & ori_8 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_8 = 1, aff_cycle_dec = 1
			if workofs_pwrtt_aff = 9 & ori_9 =0, n$, s_com_open, s_cycle_dec, *workofs_pwrtt_aff, s_com_close, e$, ori_9 = 1, aff_cycle_dec = 1				
			]	
		old_workofs = workofs_pwrtt_aff
		subout$ = 0
		] 
	#temps DLL POUR EVENTUELLEMENT L'AFFICHER EN ENTETE **BRUT DE Mc **SANS AFFINAGE POSSIBLE** & 
    sdllTimeOp = spathpst$ + "TimeOp.dll"	# A LAISSER DANS LE PWRTT$
	if Affiche_temps_dll = 1, [ 
	    if last_op_id_pwrtt <> op_id$,    [
	        sOpId = no2str(op_id$)
	        result = dll(sdllTimeOp,sOpId)
	        timeOp = rpar(spost_arg_1$,1)
	        timeTT = timeTT + timeOp
			Tot_time_Out = Tot_time_Out + timeOp		
			# TEMPS DE L OPERATION
			Types_Temps_DLL = plcval (s_Types_Temps_DLL, 1)
			if Types_Temps_DLL = 1, [
				p_Convert_time_dll 	#"aaaaa", *Tot_time_op, e$
				n$, "  ", s_com_open, "TPS OPE. = ", *Heure, *min, *sec, s_com_close, e$
				]
	        ]	
        strtool$ = ucase(strtool$)
		last_op_id_pwrtt = op_id$
		]
    if t$ <> old_t, old_t = t$
	if arctype$ <> 5 & arctype$ <> 1 & erreur_type_arcs = 1, p_erreur_config_type_arc
    ptravel
    pwritbuf5
	
#endregion

#region modif_nom_fichiers
#------------------------ RENOMMER LE FICHIER NC EN FONCTION DU NUMERO DE PROGRAMME -------------------------
snom_nc : ""           	# STRING de stockage du non du NC complet avec chemin et extension style c:\cfao\prog-cn\TOTO.NC
snom_numero : ""       	# STRING de stockage du non du NC sous forme O0123.nc avec chemin et extesion style c:\cfao\prog-cn\ous forme O0123.NC
spoint : ""          	# STRING du POINT pour l'extenssion (.NC)
#stringo            	# STRING du O pour le non (O0123) en nom du Numero PRG
#seditor : "C:\WINNT\system32\notepad.exe" 											# non de l'editeur pour les prog en nom du Numero PRG (avec chemin complet si pas dans Windows)
#seditor : "C:\WINDOWS\notepad.exe"    												# XP non de l'editeur pour les prog en nom du Numero PRG (avec chemin complet si pas dans Windows)
#seditor : "C:\Program Files\Microsoft Office\Office\WINWORD.EXE"  					# ouvrir avec WORD
#seditor : "C:\Mcam91\Common\Editors\Cedit\CIMCOEdit.exe"  							# ouvrir avec CIMCOEDIT (ne fonctionne pas)
#seditor : "C:\mcamx\common\editors\mastercam\MCXStart.exe"    						# ouvrir avec Editeur MCX
seditor  : "C:\Program Files\Mastercam 2022\Mastercam\Extensions\CodeExpert.exe"    # NOUVEL EDITEUR MC"

sdebut : "F"
smachine : "-BR"            # addition en fin de fichier en commentaire de 2ème ligne ex: FD260450-A-BR.H
snouv_nom : ""
schange_nom_fichier : ""    # nouveau nom uniquement, sans le chemin
snomprogentete : ""
#sfraisage_ "\FRAISAGE\"
#stous_clients "\TOUS_CLIENTS\"
sext : ""                   # extention
spoint2 : "."               # STRING du POINT pour l'extenssion (.NC) UNIQUEMENT pour les entêtes prog.
fmt 7 posipoint
#fmt 7 posiFraisage_
#fmt 7 posiTous_clients
sfileops : ""               # string du nom du fichier OPS
sops : ".ops"               # extention des fichier OPS
spathnc_ : "C:\MASTERCAM FICAM\ISO\" #chemin pour les fichiers ISO

sdebut2 : "PF"              
snom_entete : ""            
#sprogno = progno$

pnom_nc     # Génération des noms du fichier NC
    #snom_fichier = sdebut+snamenci+smachine+spoint+sextnc
    snom_nc = spathnc_+snamenc$+spoint+sextnc$             #spathnc$ Fichier NC en cours de creation sous forme toto.nc
    #snom_numero = no2str (progno)
    snouv_nom = spathnc_+sdebut2+snamenci$+spoint+sextnc$  #spathnc$ nouveau nom de fichier NC sous forme F15662-A-2-HE.H
    schange_nom_fichier = snouv_nom
    snom_entete = sdebut+smcname$+smachine+spoint+sextnc$ #0300 nouveau non de fichier NC sous forme F15662-A-2-HE.H  AFFICHE EN COMMENTAIRE

    #smcpath$ = ucase (smcpath$)    # retourne le chemin du fichier CN
    #smcname$ = ucase (smcname$)    # Nom du fichier NC
    #smcext$ = ucase (smcext$)      # retourne l'extention du pst
    #snamepst$ = ucase (snamepst$)  # retourne le nom du pst

ptest_nom   # test du non du fichier NC si O0123.NC
    #progno2 = progno
    if fexist (snouv_nom), pchange_nom
        #[
        #Q10
        #pchange_nom   #ex #snom_numero
        #if remplace = 0, pchange_nom
        #if remplace = 1, result = remove (snouv_nom)
        #pchange_nom
        #snouv_nom = schange_nom_fichier
        #]
    pmodif_nom_entete

pchange_nom     # changer le numéro de prog si fichier exite déja
    while fexist (snouv_nom),       #(snom_numero)
        [
        q20
        #snom_numero = no2str (progno)
        #snouv_nom = spathnc+sdebut+snouv_nom+smachine+spoint+sextnc
        snouv_nom = schange_nom_fichier
        ]
    pmodif_nom_entete

pmodif_nom_entete   #modif nom au début et fin de l'ISO
    snomprogentete = snouv_nom

    #posiTous_clients = strstr(stous_clients, snomprogentete)
    #posiTous_clients = posiTous_clients + 14

    snomprogentete = brksps(25,snomprogentete)

    #if posiTous_clients > 15,
        #[
        #snomprogentete = brksps(posiTous_clients,snomprogentete)
        #]
    #else,
        #[
        #posiFraisage_ = strstr(sfraisage_, snomprogentete)
        #posiFraisage_ = posiFraisage_ + 10
        #snomprogentete = brksps(posiFraisage_,snomprogentete)
        #]

    #enlever l'extention de fichier ex: .H
    #ex. string2 = brksps (posipoint, string1)
    #   string1 = O1235     string2 = txt
    posipoint = strstr(spoint2, snomprogentete) 
    sext = brksps (posipoint, snomprogentete)

ppost$       # traitement après post pro pour effacer le fichier OPS et renommer le fichier NC
    if change_nom = 0, ex$           			# pour 0 = pas de changement sur le fichier
    snouv_nom = ucase(snouv_nom)
    sfileops = spathnci$ + snamenci$ + sops     # non du fichier ops
    result = remove (sfileops)                  # éfface le fichier ops (si existant, en fonction de la question 1524 du PST
                                                # ou d'après la config MC, fichier utile pour les params surep...
    result = remove (snouv_nom)                 # efface fichier en nom numero
    result = rename (snom_nc, snouv_nom)        # renomer fichier NC en nom numero
    snouv_nom = sguillemet + snouv_nom + sguillemet 
    result = launch (seditor, snouv_nom)        # lancer le blocnote
#endregion

#region infos_limites_parcours
ptravel    # Tool travel limit calculation
    if x_min$ < x_tmin, x_tmin = x_min$
    if x_max$ > x_tmax, x_tmax = x_max$
    if y_min$ < y_tmin, y_tmin = y_min$
    if y_max$ > y_tmax, y_tmax = y_max$
    if z_min$ < z_tmin, z_tmin = z_min$
    if z_max$ > z_tmax, z_tmax = z_max$

# --------------------------------------------------------------------------
# Buffer 5  Read / Write Routines
# --------------------------------------------------------------------------
pwritbuf5   # Write Buffer 1
    b5_gcode = gcode$
    b5_zmin = z_min$
    b5_zmax = z_max$
    b5_gcode = wbuf(5, wc5)

preadbuf5   # Read Buffer 1
    size5 = rbuf(5,0)
    b5_gcode = 1000
    min_depth = 999
    max_depth = -999
    while rc5 <= size5 & b5_gcode = 1000,
        [
          if rc5 <= size5, b5_gcode = rbuf(5,rc5)
          if b5_zmin < min_depth, min_depth = b5_zmin
          if b5_zmax > max_depth, max_depth = b5_zmax
        ]
#endregion

[ENDBIN]

#region TEXTES_XML
[CTRL_TEXT_XML_BEGIN]  # All post text edits must be made through Control Definition Manager
<?xml version="1.0" encoding="UTF-8"?>
<mp_xml_post_text xml:space="preserve">
#region DEFAULT
	<control>
		<control_label>CTRL_MILL|DEFAULT</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>CYCLE 247 PT DE REF utilisé: 1,2,3...</text>
				<value>1</value>
			</misc_1>
			<misc_2>
				<text>En 4 axes utiliser le Z sécu de l'OP : 1</text>
				<value>1</value>
			</misc_2>
			<misc_3>
				<text>Val. angulaire index. broche (mortaisage)</text>
			</misc_3>
			<misc_4>
				<text>Parametres sur avances 0= OUI 0=NON</text>
			</misc_4>
			<misc_5>
				<text>Bris outil 1=TCH481 2=FRAISE 3=TCH586</text>
			</misc_5>
			<misc_6>
				<text>Test_Bris_Out =1 (en FIN d OPERATION)</text>
			</misc_6>
			<misc_7>
				<text>Blocage déblocage AXES ROT. 1=OUI 0=NON</text>
				<value>1</value>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<description>
				<text>Pointage Cycle 200</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Percage PROFOND Cycle 200</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>Prof. passe Q202</text>
			</first_peck>
			<subsequent_peck>
				<text>Prof. MINI en Décomposé</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Brise-copeaux cycle 203</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>Prof. de passe Q202</text>
			</first_peck>
			<subsequent_peck>
				<text>Profondeur MINI Q205</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Valeur réduction Q212</text>
			</peck_clearance>
			<retract_amount>
				<text>Nb brise-copeaux Q213</text>
			</retract_amount>
			<shift>
				<text>Retr. Brise-copeau Q256&gt;0</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>Cycle NOUV. Taraud. 207</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>""</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Plan de sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Alésage avec alésoir 201</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Avance retrait Q208</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>Alésage indexé 202</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Sens dégagt Q214 =1</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>Taraud. Brise Copeaux 209</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>""</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>Prof. de passe Q257</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Retr. Br-cop Q256</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc1>
		<misc2>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc2>
		<drill_cycle_9>
			<description>
				<text>Réf. Int. Exter rectangle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>Long. en X Q323</text>
			</first_peck>
			<subsequent_peck>
				<text>Larg. en Y Q324</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_9>
		<drill_cycle_10>
			<description>
				<text>Réf. Int. Exter Cercle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>Diametre nominal</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_10>
		<drill_cycle_11>
			<description>
				<text>Réf. Exter Coin</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_11>
		<drill_cycle_12>
			<description>
				<text>Réf. Inter Coin</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_12>
		<drill_cycle_13>
			<description>
				<text>Réf. en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Z réf.</text>
			</depth>
			<first_peck>
				<text>Dist. à Z+- (Brut)</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_13>
		<drill_cycle_14>
			<description>
				<text>Cycle spécial 14</text>
			</description>
			<feed_rate>
				<text></text>
			</feed_rate>
			<dwell>
				<text></text>
			</dwell>
			<clearance>
				<text></text>
			</clearance>
			<retract>
				<text></text>
			</retract>
			<depth>
				<text></text>
			</depth>
			<first_peck>
				<text></text>
			</first_peck>
			<subsequent_peck>
				<text></text>
			</subsequent_peck>
			<peck_clearance>
				<text></text>
			</peck_clearance>
			<retract_amount>
				<text></text>
			</retract_amount>
			<shift>
				<text></text>
			</shift>
		</drill_cycle_14>
		<drill_cycle_15>
			<description>
				<text>Cycle spécial 15</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MAT.</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_15>
		<drill_cycle_16>
			<description>
				<text>Réf. larg. rainure</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>LARGEUR</text>
			</first_peck>
			<subsequent_peck>
				<text>sur X=1 &amp; Y=2</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_16>
		<drill_cycle_17>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>1er Débour.</text>
			</first_peck>
			<subsequent_peck>
				<text>Déb. suivant</text>
			</subsequent_peck>
		</drill_cycle_17>
		<drill_cycle_18>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>1er Débour.</text>
			</first_peck>
			<subsequent_peck>
				<text>Déb. suivant</text>
			</subsequent_peck>
		</drill_cycle_18>
		<drill_cycle_19>
			<description>
				<text>Brosse Ebavurage trous</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>1er Débour.</text>
			</first_peck>
			<subsequent_peck>
				<text>Nombre de va et vient</text>
			</subsequent_peck>
		</drill_cycle_19>
		<drill_cycle_20>
			<description>
				<text>Percage tres profond</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MAT.</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 1</text>
			</description>
			<parameter_1>
				<text>1-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 2</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>2-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 3</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>3-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Rectangle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter rectangle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter rectangle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Cercle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter Cercle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter Cercle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Réf. Ext. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>Rotation base 1=O 0=N</text>
			</parameter_3>
			<parameter_4>
				<text>1ER PT dist X en +</text>
			</parameter_4>
			<parameter_5>
				<text>1ER PT dist Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>Dist. 2eme PT X G91 en +</text>
			</parameter_6>
			<parameter_7>
				<text>3EME PT dist X en +</text>
			</parameter_7>
			<parameter_8>
				<text>3EME PT dist Y en +</text>
			</parameter_8>
			<parameter_9>
				<text>Dist. 4eme PT Y en + G91</text>
			</parameter_9>
			<parameter_10>
				<text>&gt;0 Tab. pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Réf. Int. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>Rotation base 1=O 0=N</text>
			</parameter_3>
			<parameter_4>
				<text>1ER PT dist X en +</text>
			</parameter_4>
			<parameter_5>
				<text>1ER PT dist Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>Dist. 2eme PT X en + G91</text>
			</parameter_6>
			<parameter_7>
				<text>Dist. 3eme PT Y en + G91</text>
			</parameter_7>
			<parameter_8>
				<text>COIN:1=-135°,2=-45,3=45,4=135</text>
			</parameter_8>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Réf. en Z</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>""</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 15</text>
			</description>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Réf. larg. rainure</text>
			</description>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 17</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Percage tres profond</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Perçage Pointage</text>
			</simple_drill>
			<peck_drill>
				<text>Percage Profond</text>
			</peck_drill>
			<chip_break>
				<text>Percage Brise copeaux 203</text>
			</chip_break>
			<tapping>
				<text>Taraudage</text>
			</tapping>
			<boring_1>
				<text>Alésage ret. G1</text>
			</boring_1>
			<boring_2>
				<text>Alésage Indéxé</text>
			</boring_2>
			<misc_drill_1>
				<text>""</text>
			</misc_drill_1>
			<misc_drill_2>
				<text>""</text>
			</misc_drill_2>
			<custom_drill_9>
				<text>Ref. Int. Exter. Rectangle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Poche rectangul INTER-EXTER_1.bmp</resource>
			</custom_drill_9>
			<custom_drill_10>
				<text>REf. Int. Exter. Cercle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\CERCLE INTER-EXTER_1.bmp</resource>
			</custom_drill_10>
			<custom_drill_11>
				<text>REf. Exter Coin</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\COIN EXTER_1.bmp</resource>
			</custom_drill_11>
			<custom_drill_12>
				<text>REf. Inter Coin</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\COIN INTER_1.bmp</resource>
			</custom_drill_12>
			<custom_drill_13>
				<text>REf. en Z</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -Z-_1.bmp</resource>
			</custom_drill_13>
			<custom_drill_14>
				<text>Cycle 14</text>
			</custom_drill_14>
			<custom_drill_15>
				<text>Cycle 15</text>
			</custom_drill_15>
			<custom_drill_16>
				<text>REf. larg. rainure</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\RAINURE_1.bmp</resource>
			</custom_drill_16>
			<custom_drill_17>
				<text>Cycle 17</text>
			</custom_drill_17>
			<custom_drill_18>
				<text>Cycle 18</text>
			</custom_drill_18>
			<custom_drill_19>
				<text>Brosse Ebavurage</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Brosse Ebavurage.bmp</resource>
			</custom_drill_19>
			<custom_drill_20>
				<text>Percage trEs profond</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\PERCAGE TRES PROFOND_1.bmp</resource>
			</custom_drill_20>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>M00</text>
			</canned_text_1>
			<canned_text_2>
				<text>M01</text>
			</canned_text_2>
			<canned_text_3>
				<text>BLOC OPTIONNEL ON</text>
			</canned_text_3>
			<canned_text_4>
				<text>BLOC OPTIONNEL OFF</text>
			</canned_text_4>
			<canned_text_5>
				<text>REPRISE</text>
			</canned_text_5>
			<canned_text_6>
				<text>ZONE 1</text>
			</canned_text_6>
			<canned_text_7>
				<text>ZONE 2</text>
			</canned_text_7>
			<canned_text_8>
				<text>EBAUCHE</text>
			</canned_text_8>
			<canned_text_9>
				<text>FINITION</text>
			</canned_text_9>
			<canned_text_10>
				<text>AJOUT BRIDEs</text>
			</canned_text_10>
			<canned_text_11>
				<text>ENLEVER BRIDEs</text>
			</canned_text_11>
		</canned_text>
	</control>
#endregion 

<control>
		<control_label>CTRL_MILL|MILL_ST_HEIDENHAIN-ROTATION-A-OU-B</control_label>
		<language>fr-FR</language>
		<misc_integers>
			<misc_1>
				<text>CYCLE 247 PT DE REF utilisé: 1,2,3...</text>
				<value>1</value>
			</misc_1>
			<misc_2>
				<text>En 4 axes utiliser le Z sécu de l'OP : 1</text>
				<value>1</value>
			</misc_2>
			<misc_3>
				<text>Val. angulaire index. broche (mortaisage)</text>
			</misc_3>
			<misc_4>
				<text>Parametres sur avances 0= OUI 0=NON</text>
			</misc_4>
			<misc_5>
				<text>Bris outil 1=TCH481 2=FRAISE 3=TCH586</text>
			</misc_5>
			<misc_6>
				<text>Test_Bris_Out =1 (en FIN d OPERATION)</text>
			</misc_6>
			<misc_7>
				<text>Blocage déblocage AXES ROT. 1=OUI 0=NON</text>
				<value>1</value>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_integers>
		<misc_reals>
			<misc_1>
				<text>""</text>
			</misc_1>
			<misc_2>
				<text>""</text>
			</misc_2>
			<misc_3>
				<text>""</text>
			</misc_3>
			<misc_4>
				<text>""</text>
			</misc_4>
			<misc_5>
				<text>""</text>
			</misc_5>
			<misc_6>
				<text>""</text>
			</misc_6>
			<misc_7>
				<text>""</text>
			</misc_7>
			<misc_8>
				<text>""</text>
			</misc_8>
			<misc_9>
				<text>""</text>
			</misc_9>
			<misc_10>
				<text>""</text>
			</misc_10>
		</misc_reals>
		<simple_drill>
			<description>
				<text>Pointage Cycle 200</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</simple_drill>
		<peck_drill>
			<description>
				<text>Percage PROFOND Cycle 200</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>Prof. passe Q202</text>
			</first_peck>
			<subsequent_peck>
				<text>Prof. MINI en Décomposé</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</peck_drill>
		<chip_break>
			<description>
				<text>Brise-copeaux cycle 203</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>Prof. de passe Q202</text>
			</first_peck>
			<subsequent_peck>
				<text>Profondeur MINI Q205</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Valeur réduction Q212</text>
			</peck_clearance>
			<retract_amount>
				<text>Nb brise-copeaux Q213</text>
			</retract_amount>
			<shift>
				<text>Retr. Brise-copeau Q256&gt;0</text>
			</shift>
		</chip_break>
		<tap>
			<description>
				<text>Cycle NOUV. Taraud. 207</text>
			</description>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</tap>
		<bore1>
			<description>
				<text>Alésage avec alésoir 201</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Avance retrait Q208</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore1>
		<bore2>
			<description>
				<text>Alésage indexé 202</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>Tempo. au fond Q211</text>
				<value>0</value>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>Sens dégagt Q214 =1</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</bore2>
		<misc1>
			<description>
				<text>Taraud. Brise Copeaux 209</text>
			</description>
			<feed_rate>
				<text>Avance Q206</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Saut bride Q204</text>
			</clearance>
			<retract>
				<text>Garde Q200</text>
			</retract>
			<depth>
				<text>Profondeur Q201</text>
			</depth>
			<first_peck>
				<text>Prof. de passe Q257</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>Retr. Br-cop Q256</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc1>
		<misc2>
			<description>
				<text>""</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>""</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</misc2>
		<drill_cycle_9>
			<description>
				<text>Réf. Int. Exter rectangle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>Long. en X Q323</text>
			</first_peck>
			<subsequent_peck>
				<text>Larg. en Y Q324</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_9>
		<drill_cycle_10>
			<description>
				<text>Réf. Int. Exter Cercle</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>Diametre nominal</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_10>
		<drill_cycle_11>
			<description>
				<text>Réf. Exter Coin</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_11>
		<drill_cycle_12>
			<description>
				<text>Réf. Inter Coin</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_12>
		<drill_cycle_13>
			<description>
				<text>Réf. en Z</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Z réf.</text>
			</depth>
			<first_peck>
				<text>Dist. à Z+- (Brut)</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_13>
		<drill_cycle_15>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MAT.</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_15>
		<drill_cycle_16>
			<description>
				<text>Réf. larg. rainure</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité Q260</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<depth>
				<text>Prof.Centre B.</text>
			</depth>
			<first_peck>
				<text>LARGEUR</text>
			</first_peck>
			<subsequent_peck>
				<text>sur X=1 &amp; Y=2</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_16>
		<drill_cycle_17>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>1er Débour.</text>
			</first_peck>
			<subsequent_peck>
				<text>Déb. suivant</text>
			</subsequent_peck>
		</drill_cycle_17>
		<drill_cycle_18>
			<feed_rate>
				<text>Avance</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>1er Débour.</text>
			</first_peck>
			<subsequent_peck>
				<text>Déb. suivant</text>
			</subsequent_peck>
		</drill_cycle_18>
		<drill_cycle_19>
			<description>
				<text>Brosse Ebavurage trous</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>Tempo.</text>
			</dwell>
			<clearance>
				<text>Plan Sécurité</text>
			</clearance>
			<retract>
				<text>Garde</text>
			</retract>
			<first_peck>
				<text>1er Débour.</text>
			</first_peck>
			<subsequent_peck>
				<text>Nombre de va et vient</text>
			</subsequent_peck>
		</drill_cycle_19>
		<drill_cycle_20>
			<description>
				<text>Percage tres profond</text>
			</description>
			<feed_rate>
				<text>""</text>
			</feed_rate>
			<dwell>
				<text>""</text>
			</dwell>
			<clearance>
				<text>""</text>
			</clearance>
			<retract>
				<text>Z HORS MAT.</text>
			</retract>
			<depth>
				<text>""</text>
			</depth>
			<first_peck>
				<text>""</text>
			</first_peck>
			<subsequent_peck>
				<text>""</text>
			</subsequent_peck>
			<peck_clearance>
				<text>""</text>
			</peck_clearance>
			<retract_amount>
				<text>""</text>
			</retract_amount>
			<shift>
				<text>""</text>
			</shift>
		</drill_cycle_20>
		<simple_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 1</text>
			</description>
			<parameter_1>
				<text>1-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</simple_drill_custom_parameters>
		<peck_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 2</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>2-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</peck_drill_custom_parameters>
		<chip_break_drill_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 3</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>3-DEcomposer le cycle en G1-G0 =1 </text>
				<value>0</value>
			</parameter_3>
			<parameter_4>
				<text>1ere plongée Type val.[0=Inc,1=%]</text>
			</parameter_4>
			<parameter_5>
				<text>VALEUR 1ere plongée % ou mm</text>
			</parameter_5>
			<parameter_6>
				<text>Avance &gt; 0= % ou &lt; 0= mm</text>
			</parameter_6>	
		</chip_break_drill_custom_parameters>
		<tap_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 4</text>
			</description>
		</tap_custom_parameters>
		<bore1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 5</text>
			</description>
		</bore1_custom_parameters>
		<bore2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 6</text>
			</description>
		</bore2_custom_parameters>
		<misc1_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 7</text>
			</description>
		</misc1_custom_parameters>
		<misc2_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 8</text>
			</description>
		</misc2_custom_parameters>
		<drill_cycle_9_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Rectangle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter rectangle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter rectangle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_9_custom_parameters>
		<drill_cycle_10_custom_parameters>
			<description>
				<text>Réf. Int./Ext. Cercle</text>
			</description>
			<parameter_1>
				<text>Réf. Inter Cercle = 1</text>
			</parameter_1>
			<parameter_2>
				<text>Réf. Exter Cercle = 1</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_10_custom_parameters>
		<drill_cycle_11_custom_parameters>
			<description>
				<text>Réf. Ext. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>Rotation base 1=O 0=N</text>
			</parameter_3>
			<parameter_4>
				<text>1ER PT dist X en +</text>
			</parameter_4>
			<parameter_5>
				<text>1ER PT dist Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>Dist. 2eme PT X G91 en +</text>
			</parameter_6>
			<parameter_7>
				<text>3EME PT dist X en +</text>
			</parameter_7>
			<parameter_8>
				<text>3EME PT dist Y en +</text>
			</parameter_8>
			<parameter_9>
				<text>Dist. 4eme PT Y en + G91</text>
			</parameter_9>
			<parameter_10>
				<text>&gt;0 Tab. pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_11_custom_parameters>
		<drill_cycle_12_custom_parameters>
			<description>
				<text>Réf. Int. Coin</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>Rotation base 1=O 0=N</text>
			</parameter_3>
			<parameter_4>
				<text>1ER PT dist X en +</text>
			</parameter_4>
			<parameter_5>
				<text>1ER PT dist Y en +</text>
			</parameter_5>
			<parameter_6>
				<text>Dist. 2eme PT X en + G91</text>
			</parameter_6>
			<parameter_7>
				<text>Dist. 3eme PT Y en + G91</text>
			</parameter_7>
			<parameter_8>
				<text>COIN:1=-135°,2=-45,3=45,4=135</text>
			</parameter_8>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_12_custom_parameters>
		<drill_cycle_13_custom_parameters>
			<description>
				<text>Réf. en Z</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_13_custom_parameters>
		<drill_cycle_14_custom_parameters>
			<description>
				<text>""</text>
			</description>
			<parameter_1>
				<text>""</text>
			</parameter_1>
			<parameter_2>
				<text>""</text>
			</parameter_2>
			<parameter_3>
				<text>""</text>
			</parameter_3>
			<parameter_4>
				<text>""</text>
			</parameter_4>
			<parameter_5>
				<text>""</text>
			</parameter_5>
			<parameter_6>
				<text>""</text>
			</parameter_6>
			<parameter_7>
				<text>""</text>
			</parameter_7>
			<parameter_8>
				<text>""</text>
			</parameter_8>
			<parameter_9>
				<text>""</text>
			</parameter_9>
			<parameter_10>
				<text>""</text>
			</parameter_10>
		</drill_cycle_14_custom_parameters>
		<drill_cycle_15_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 15</text>
			</description>
		</drill_cycle_15_custom_parameters>
		<drill_cycle_16_custom_parameters>
			<description>
				<text>Réf. larg. rainure</text>
			</description>
			<parameter_9>
				<text>Q10 0= origine &gt;0 val. dans le</text>
			</parameter_9>
			<parameter_10>
				<text>Tableau pt 0  1=(54) 2=(55)..</text>
			</parameter_10>
		</drill_cycle_16_custom_parameters>
		<drill_cycle_17_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 17</text>
			</description>
		</drill_cycle_17_custom_parameters>
		<drill_cycle_18_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 18</text>
			</description>
		</drill_cycle_18_custom_parameters>
		<drill_cycle_19_custom_parameters>
			<description>
				<text>Paramètres de cycle spécial 19</text>
			</description>
		</drill_cycle_19_custom_parameters>
		<drill_cycle_20_custom_parameters>
			<description>
				<text>Percage tres profond</text>
			</description>
		</drill_cycle_20_custom_parameters>
		<drill_cycle_descriptions>
			<simple_drill>
				<text>Perçage Pointage</text>
			</simple_drill>
			<peck_drill>
				<text>Percage Profond</text>
			</peck_drill>
			<chip_break>
				<text>Percage Brise copeaux 203</text>
			</chip_break>
			<tapping>
				<text>Taraudage</text>
			</tapping>
			<boring_1>
				<text>Alésage ret. G1</text>
			</boring_1>
			<boring_2>
				<text>Alésage Indéxé</text>
			</boring_2>
			<misc_drill_1>
				<text>""</text>
			</misc_drill_1>
			<misc_drill_2>
				<text>""</text>
			</misc_drill_2>
			<custom_drill_9>
				<text>Ref. Int. Exter. Rectangle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Poche rectangul INTER-EXTER_1.bmp</resource>
			</custom_drill_9>
			<custom_drill_10>
				<text>REf. Int. Exter. Cercle</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\CERCLE INTER-EXTER_1.bmp</resource>
			</custom_drill_10>
			<custom_drill_11>
				<text>REf. Exter Coin</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\COIN EXTER_1.bmp</resource>
			</custom_drill_11>
			<custom_drill_12>
				<text>REf. Inter Coin</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\COIN INTER_1.bmp</resource>
			</custom_drill_12>
			<custom_drill_13>
				<text>REf. en Z</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\FACE EN -Z-_1.bmp</resource>
			</custom_drill_13>
			<custom_drill_14>
				<text>Cycle 14</text>
			</custom_drill_14>
			<custom_drill_15>
				<text>Cycle 15</text>
			</custom_drill_15>
			<custom_drill_16>
				<text>REf. larg. rainure</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\RAINURE_1.bmp</resource>
			</custom_drill_16>
			<custom_drill_17>
				<text>Cycle 17</text>
			</custom_drill_17>
			<custom_drill_18>
				<text>Cycle 18</text>
			</custom_drill_18>
			<custom_drill_19>
				<text>Brosse Ebavurage</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\Brosse Ebavurage.bmp</resource>
			</custom_drill_19>
			<custom_drill_20>
				<text>Percage trEs profond</text>
				<resource>C:\Users\Public\Documents\Shared Mastercam 2025\mill\Posts\IMAGES PPs\PERCAGE TRES PROFOND_1.bmp</resource>
			</custom_drill_20>
		</drill_cycle_descriptions>
		<canned_text>
			<canned_text_1>
				<text>M00</text>
			</canned_text_1>
			<canned_text_2>
				<text>M01</text>
			</canned_text_2>
			<canned_text_3>
				<text>BLOC OPTIONNEL ON</text>
			</canned_text_3>
			<canned_text_4>
				<text>BLOC OPTIONNEL OFF</text>
			</canned_text_4>
			<canned_text_5>
				<text>REPRISE</text>
			</canned_text_5>
			<canned_text_6>
				<text>ZONE 1</text>
			</canned_text_6>
			<canned_text_7>
				<text>ZONE 2</text>
			</canned_text_7>
			<canned_text_8>
				<text>EBAUCHE</text>
			</canned_text_8>
			<canned_text_9>
				<text>FINITION</text>
			</canned_text_9>
			<canned_text_10>
				<text>AJOUT BRIDEs</text>
			</canned_text_10>
			<canned_text_11>
				<text>ENLEVER BRIDEs</text>
			</canned_text_11>
		</canned_text>
	</control>
</mp_xml_post_text>
[CTRL_TEXT_XML_END]
#endregion
